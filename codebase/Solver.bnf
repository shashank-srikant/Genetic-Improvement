#create_syntax.awk Revision: 1.51  Tue Jul 11 17:14:53 BST 2017
#Solver_E.cc Solver
#clean_cpp.awk Revision: 1.2  "/home/justyna/Documents/minisatgirelease/sources/core/Solver.cc" Tue Jul 11 17:14:09 BST 2017
<Solver_3>	::=	"using namespace Minisat;\n"
<Solver_4>	::=	"static const char* _cat = \"CORE\";\n"
<Solver_5>	::=	"static DoubleOption opt_var_decay (_cat, \"var-decay\", \"The variable activity decay factor\", 0.95, DoubleRange(0, false, 1, false));\n"
<Solver_6>	::=	"static DoubleOption opt_clause_decay (_cat, \"cla-decay\", \"The clause activity decay factor\", 0.999, DoubleRange(0, false, 1, false));\n"
<Solver_7>	::=	"static DoubleOption opt_random_var_freq (_cat, \"rnd-freq\", \"The frequency with which the decision heuristic tries to choose a random variable\", 0, DoubleRange(0, true, 1, true));\n"
<Solver_8>	::=	"static DoubleOption opt_random_seed (_cat, \"rnd-seed\", \"Used by the random variable selection\", 91648253, DoubleRange(0, false,\n"
<Solver_9>	::=	"(__builtin_huge_val())\n"
<Solver_10>	::=	", false));\n"
<Solver_11>	::=	"static IntOption opt_ccmin_mode (_cat, \"ccmin-mode\", \"Controls conflict clause minimization (0=none, 1=basic, 2=deep)\", 2, IntRange(0, 2));\n"
<Solver_12>	::=	"static IntOption opt_phase_saving (_cat, \"phase-saving\", \"Controls the level of phase saving (0=none, 1=limited, 2=full)\", 2, IntRange(0, 2));\n"
<Solver_13>	::=	"static BoolOption opt_rnd_init_act (_cat, \"rnd-init\", \"Randomize the initial activity\", false);\n"
<Solver_14>	::=	"static BoolOption opt_luby_restart (_cat, \"luby\", \"Use the Luby restart sequence\", true);\n"
<Solver_15>	::=	"static IntOption opt_restart_first (_cat, \"rfirst\", \"The base restart interval\", 100, IntRange(1, (2147483647)));\n"
<Solver_16>	::=	"static DoubleOption opt_restart_inc (_cat, \"rinc\", \"Restart interval increase factor\", 2, DoubleRange(1, false, (__builtin_huge_val()) , false));\n"
<Solver_17>	::=	"static DoubleOption opt_garbage_frac (_cat, \"gc-frac\", \"The fraction of wasted memory allowed before a garbage collection is triggered\", 0.20, DoubleRange(0, false, (__builtin_huge_val()) , false));\n"
<Solver_18>	::=	"Solver::Solver() :\n"
<Solver_19>	::=	"verbosity (0)\n"
<Solver_20>	::=	", var_decay (opt_var_decay)\n"
<Solver_21>	::=	", clause_decay (opt_clause_decay)\n"
<Solver_22>	::=	", random_var_freq (opt_random_var_freq)\n"
<Solver_23>	::=	", random_seed (opt_random_seed)\n"
<Solver_24>	::=	", luby_restart (opt_luby_restart)\n"
<Solver_25>	::=	", ccmin_mode (opt_ccmin_mode)\n"
<Solver_26>	::=	", phase_saving (opt_phase_saving)\n"
<Solver_27>	::=	", rnd_pol (false)\n"
<Solver_28>	::=	", rnd_init_act (opt_rnd_init_act)\n"
<Solver_29>	::=	", garbage_frac (opt_garbage_frac)\n"
<Solver_30>	::=	", restart_first (opt_restart_first)\n"
<Solver_31>	::=	", restart_inc (opt_restart_inc)\n"
<Solver_32>	::=	", learntsize_factor((double)1/(double)3), learntsize_inc(1.1)\n"
<Solver_33>	::=	", learntsize_adjust_start_confl (100)\n"
<Solver_34>	::=	", learntsize_adjust_inc (1.5)\n"
<Solver_35>	::=	", solves(0), starts(0), decisions(0), rnd_decisions(0), propagations(0), conflicts(0)\n"
<Solver_36>	::=	", dec_vars(0), clauses_literals(0), learnts_literals(0), max_literals(0), tot_literals(0)\n"
<Solver_37>	::=	", ok (true)\n"
<Solver_38>	::=	", cla_inc (1)\n"
<Solver_39>	::=	", var_inc (1)\n"
<Solver_40>	::=	", watches (WatcherDeleted(ca))\n"
<Solver_41>	::=	", qhead (0)\n"
<Solver_42>	::=	", simpDB_assigns (-1)\n"
<Solver_43>	::=	", simpDB_props (0)\n"
<Solver_44>	::=	", order_heap (VarOrderLt(activity))\n"
<Solver_45>	::=	", progress_estimate (0)\n"
<Solver_46>	::=	", remove_satisfied (true)\n"
<Solver_47>	::=	", conflict_budget (-1)\n"
<Solver_48>	::=	", propagation_budget (-1)\n"
<Solver_49>	::=	", asynch_interrupt (false)\n"
<Solver_50>	::=	"{\n"
<Solver_51>	::=	"}\n"
<Solver_52>	::=	"Solver::~Solver()\n"
<Solver_53>	::=	"{\n"
<Solver_54>	::=	"}\n"
<Solver_55>	::=	"Var Solver::newVar(bool sign, bool dvar)\n"
<Solver_56>	::=	"{\n"
<Solver_57>	::=	"int v = nVars();\n"
<Solver_58>	::=	"watches .init(mkLit(v, false));\n"
<Solver_59>	::=	"watches .init(mkLit(v, true ));\n"
<Solver_60>	::=	"assigns .push((lbool((uint8_t)2)));\n"
<Solver_61>	::=	"vardata .push(mkVarData(CRef_Undef, 0));\n"
<Solver_62>	::=	"activity .push(rnd_init_act ? drand(random_seed) * 0.00001 : 0);\n"
<Solver_63>	::=	"seen .push(0);\n"
<Solver_64>	::=	"polarity .push(sign);\n"
<Solver_65>	::=	"decision .push();\n"
<Solver_66>	::=	"trail .capacity(v+1);\n"
<Solver_67>	::=	"setDecisionVar(v, dvar);\n"
<Solver_68>	::=	"return v;\n"
<Solver_69>	::=	"}\n"
<Solver_70>	::=	"bool Solver::addClause_(vec<Lit>& ps)\n"
<Solver_71>	::=	"{\n"
<Solver_73>	::=	"(( decisionLevel() == 0) ? static_cast<void> (0) : __assert_fail ( \"decisionLevel() == 0\" , \"/home/justyna/Documents/minisatgirelease/sources/core/Solver.cc\", 73, __PRETTY_FUNCTION__)) ;\n"
<Solver_74>	::=	"if (!ok)\n"
<Solver_75>	::=	"{\n"
<Solver_76>	::=	"return false;\n"
<Solver_77>	::=	"}\n"
<Solver_78>	::=	"sort(ps);\n"
<Solver_79>	::=	"Lit p; int i, j;\n"
<Solver_80>	::=	"for (i = j = 0, p = lit_Undef; i < ps.size(); i++)\n"
<Solver_81>	::=	"{\n"
<Solver_82>	::=	"if (value(ps[i]) == (lbool((uint8_t)0)) || ps[i] == ~p)\n"
<Solver_83>	::=	"{\n"
<Solver_84>	::=	"return true;\n"
<Solver_85>	::=	"}\n"
<Solver_86>	::=	"else if (value(ps[i]) != (lbool((uint8_t)1)) && ps[i] != p)\n"
<Solver_87>	::=	"{\n"
<Solver_88>	::=	"ps[j++] = p = ps[i];\n"
<Solver_89>	::=	"}\n"
<Solver_90>	::=	"}\n"
<Solver_91>	::=	"ps.shrink(i - j);\n"
<Solver_92>	::=	"if (ps.size() == 0)\n"
<Solver_93>	::=	"{\n"
<Solver_94>	::=	"return ok = false;\n"
<Solver_95>	::=	"}\n"
<Solver_96>	::=	"else if (ps.size() == 1)\n"
<Solver_97>	::=	"{\n"
<Solver_98>	::=	"uncheckedEnqueue(ps[0]);\n"
<Solver_99>	::=	"return ok = (propagate() == CRef_Undef);\n"
<Solver_100>	::=	"}\n"
<Solver_101>	::=	"else\n"
<Solver_102>	::=	"{\n"
<Solver_103>	::=	"CRef cr = ca.alloc(ps, false);\n"
<Solver_104>	::=	"clauses.push(cr);\n"
<Solver_105>	::=	"attachClause(cr);\n"
<Solver_106>	::=	"}\n"
<Solver_107>	::=	"return true;\n"
<Solver_108>	::=	"}\n"
<Solver_109>	::=	"void Solver::attachClause(CRef cr)\n"
<Solver_110>	::=	"{\n"
<Solver_111>	::=	"const Clause& c = ca[cr];\n"
<Solver_113>	::=	"(( c.size() > 1) ? static_cast<void> (0) : __assert_fail ( \"c.size() > 1\" , \"/home/justyna/Documents/minisatgirelease/sources/core/Solver.cc\", 113, __PRETTY_FUNCTION__)) ;\n"
<Solver_114>	::=	"watches[~c[0]].push(Watcher(cr, c[1]));\n"
<Solver_115>	::=	"watches[~c[1]].push(Watcher(cr, c[0]));\n"
<Solver_116>	::=	"if (c.learnt()) learnts_literals += c.size();\n"
<Solver_117>	::=	"else clauses_literals += c.size();\n"
<Solver_118>	::=	"}\n"
<Solver_119>	::=	"void Solver::detachClause(CRef cr, bool strict)\n"
<Solver_120>	::=	"{\n"
<Solver_121>	::=	"const Clause& c = ca[cr];\n"
<Solver_123>	::=	"(( c.size() > 1) ? static_cast<void> (0) : __assert_fail ( \"c.size() > 1\" , \"/home/justyna/Documents/minisatgirelease/sources/core/Solver.cc\", 123, __PRETTY_FUNCTION__)) ;\n"
<Solver_124>	::=	"if (strict)\n"
<Solver_125>	::=	"{\n"
<Solver_126>	::=	"remove(watches[~c[0]], Watcher(cr, c[1]));\n"
<Solver_127>	::=	"remove(watches[~c[1]], Watcher(cr, c[0]));\n"
<Solver_128>	::=	"}\n"
<Solver_129>	::=	"else\n"
<Solver_130>	::=	"{\n"
<Solver_131>	::=	"watches.smudge(~c[0]);\n"
<Solver_132>	::=	"watches.smudge(~c[1]);\n"
<Solver_133>	::=	"}\n"
<Solver_134>	::=	"if (c.learnt())\n"
<Solver_135>	::=	"{\n"
<Solver_136>	::=	"learnts_literals -= c.size();\n"
<Solver_137>	::=	"}\n"
<Solver_138>	::=	"else\n"
<Solver_139>	::=	"{\n"
<Solver_140>	::=	"clauses_literals -= c.size();\n"
<Solver_141>	::=	"}\n"
<Solver_142>	::=	"}\n"
<Solver_143>	::=	"void Solver::removeClause(CRef cr)\n"
<Solver_144>	::=	"{\n"
<Solver_145>	::=	"Clause& c = ca[cr];\n"
<Solver_146>	::=	"detachClause(cr);\n"
<Solver_147>	::=	"if (locked(c))\n"
<Solver_148>	::=	"{\n"
<Solver_149>	::=	"vardata[var(c[0])].reason = CRef_Undef;\n"
<Solver_150>	::=	"}\n"
<Solver_151>	::=	"c.mark(1);\n"
<Solver_152>	::=	"ca.free(cr);\n"
<Solver_153>	::=	"}\n"
<Solver_154>	::=	"bool Solver::satisfied(const Clause& c) const\n"
<Solver_155>	::=	"{\n"
<Solver_156>	::=	"for (int i = 0; i < c.size(); i++)\n"
<Solver_157>	::=	"{\n"
<Solver_158>	::=	"if (value(c[i]) == (lbool((uint8_t)0)))\n"
<Solver_159>	::=	"{\n"
<Solver_160>	::=	"return true;\n"
<Solver_161>	::=	"}\n"
<Solver_162>	::=	"}\n"
<Solver_163>	::=	"return false;\n"
<Solver_164>	::=	"}\n"
<Solver_165>	::=	"void Solver::cancelUntil(int level)\n"
<Solver_166>	::=	"{\n"
<Solver_167>	::=	"if (decisionLevel() > level)\n"
<Solver_168>	::=	"{\n"
<Solver_169>	::=	"for (int c = trail.size()-1; c >= trail_lim[level]; c--)\n"
<Solver_170>	::=	"{\n"
<Solver_171>	::=	"Var x = var(trail[c]);\n"
<Solver_172>	::=	"assigns [x] = (lbool((uint8_t)2));\n"
<Solver_173>	::=	"if (phase_saving > 1 || (phase_saving == 1) && c > trail_lim.last())\n"
<Solver_174>	::=	"{\n"
<Solver_175>	::=	"polarity[x] = sign(trail[c]);\n"
<Solver_176>	::=	"}\n"
<Solver_177>	::=	"insertVarOrder(x);\n"
<Solver_178>	::=	"}\n"
<Solver_179>	::=	"qhead = trail_lim[level];\n"
<Solver_180>	::=	"trail.shrink(trail.size() - trail_lim[level]);\n"
<Solver_181>	::=	"trail_lim.shrink(trail_lim.size() - level);\n"
<Solver_182>	::=	"}\n"
<Solver_183>	::=	"}\n"
<Solver_184>	::=	"Lit Solver::pickBranchLit()\n"
<Solver_185>	::=	"{\n"
<Solver_186>	::=	"Var next = (-1);\n"
<Solver_187>	::=	"if (drand(random_seed) < random_var_freq && !order_heap.empty())\n"
<Solver_188>	::=	"{\n"
<Solver_189>	::=	"next = order_heap[irand(random_seed,order_heap.size())];\n"
<Solver_190>	::=	"if (value(next) == (lbool((uint8_t)2)) && decision[next])\n"
<Solver_191>	::=	"{\n"
<Solver_192>	::=	"rnd_decisions++;\n"
<Solver_193>	::=	"}\n"
<Solver_194>	::=	"}\n"
<Solver_195>	::=	"while (next == (-1) || value(next) != (lbool((uint8_t)2)) || !decision[next])\n"
<Solver_196>	::=	"{\n"
<Solver_197>	::=	"if (order_heap.empty())\n"
<Solver_198>	::=	"{\n"
<Solver_199>	::=	"next = (-1);\n"
<Solver_200>	::=	"break;\n"
<Solver_201>	::=	"}\n"
<Solver_202>	::=	"else\n"
<Solver_203>	::=	"{\n"
<Solver_204>	::=	"next = order_heap.removeMin();\n"
<Solver_205>	::=	"}\n"
<Solver_206>	::=	"}\n"
<Solver_207>	::=	"return next == (-1) ? lit_Undef : mkLit(next, rnd_pol ? drand(random_seed) < 0.5 : polarity[next]);\n"
<Solver_208>	::=	"}\n"
<Solver_209>	::=	"void Solver::analyze(CRef confl, vec<Lit>& out_learnt, int& out_btlevel)\n"
<Solver_210>	::=	"{\n"
<Solver_211>	::=	"int pathC = 0;\n"
<Solver_212>	::=	"Lit p = lit_Undef;\n"
<Solver_213>	::=	"out_learnt.push();\n"
<Solver_214>	::=	"int index = trail.size() - 1;\n"
<Solver_215>	::=	"do\n"
<Solver_216>	::=	"{\n"
<Solver_218>	::=	"(( confl != CRef_Undef) ? static_cast<void> (0) : __assert_fail ( \"confl != CRef_Undef\" , \"/home/justyna/Documents/minisatgirelease/sources/core/Solver.cc\", 218, __PRETTY_FUNCTION__)) ;\n"
<Solver_219>	::=	"Clause& c = ca[confl];\n"
<Solver_220>	::=	"if (c.learnt())\n"
<Solver_221>	::=	"{\n"
<Solver_222>	::=	"claBumpActivity(c);\n"
<Solver_223>	::=	"}\n"
<Solver_224>	::=	"for (int j = (p == lit_Undef) ? 0 : 1; j < c.size(); j++)\n"
<Solver_225>	::=	"{\n"
<Solver_226>	::=	"Lit q = c[j];\n"
<Solver_227>	::=	"if (!seen[var(q)] && level(var(q)) > 0)\n"
<Solver_228>	::=	"{\n"
<Solver_229>	::=	"varBumpActivity(var(q));\n"
<Solver_230>	::=	"seen[var(q)] = 1;\n"
<Solver_231>	::=	"if (level(var(q)) >= decisionLevel())\n"
<Solver_232>	::=	"{\n"
<Solver_233>	::=	"pathC++;\n"
<Solver_234>	::=	"}\n"
<Solver_235>	::=	"else\n"
<Solver_236>	::=	"{\n"
<Solver_237>	::=	"out_learnt.push(q);\n"
<Solver_238>	::=	"}\n"
<Solver_239>	::=	"}\n"
<Solver_240>	::=	"}\n"
<Solver_241>	::=	"while (!seen[var(trail[index--])]);\n"
<Solver_242>	::=	"p = trail[index+1];\n"
<Solver_243>	::=	"confl = reason(var(p));\n"
<Solver_244>	::=	"seen[var(p)] = 0;\n"
<Solver_245>	::=	"pathC--;\n"
<Solver_246>	::=	"}\n"
<Solver_247>	::=	"while (pathC > 0);\n"
<Solver_248>	::=	"out_learnt[0] = ~p;\n"
<Solver_249>	::=	"int i, j;\n"
<Solver_250>	::=	"out_learnt.copyTo(analyze_toclear);\n"
<Solver_251>	::=	"if (ccmin_mode == 2)\n"
<Solver_252>	::=	"{\n"
<Solver_253>	::=	"uint32_t abstract_level = 0;\n"
<Solver_254>	::=	"for (i = 1; i < out_learnt.size(); i++)\n"
<Solver_255>	::=	"{\n"
<Solver_256>	::=	"abstract_level |= abstractLevel(var(out_learnt[i]));\n"
<Solver_257>	::=	"}\n"
<Solver_258>	::=	"for (i = j = 1; i < out_learnt.size(); i++)\n"
<Solver_259>	::=	"{\n"
<Solver_260>	::=	"if (reason(var(out_learnt[i])) == CRef_Undef || !litRedundant(out_learnt[i], abstract_level))\n"
<Solver_261>	::=	"{\n"
<Solver_262>	::=	"out_learnt[j++] = out_learnt[i];\n"
<Solver_263>	::=	"}\n"
<Solver_264>	::=	"}\n"
<Solver_265>	::=	"}\n"
<Solver_266>	::=	"else if (ccmin_mode == 1)\n"
<Solver_267>	::=	"{\n"
<Solver_268>	::=	"for (i = j = 1; i < out_learnt.size(); i++)\n"
<Solver_269>	::=	"{\n"
<Solver_270>	::=	"Var x = var(out_learnt[i]);\n"
<Solver_271>	::=	"if (reason(x) == CRef_Undef)\n"
<Solver_272>	::=	"{\n"
<Solver_273>	::=	"out_learnt[j++] = out_learnt[i];\n"
<Solver_274>	::=	"}\n"
<Solver_275>	::=	"else\n"
<Solver_276>	::=	"{\n"
<Solver_277>	::=	"Clause& c = ca[reason(var(out_learnt[i]))];\n"
<Solver_278>	::=	"for (int k = 1; k < c.size(); k++)\n"
<Solver_279>	::=	"{\n"
<Solver_280>	::=	"if (!seen[var(c[k])] && level(var(c[k])) > 0)\n"
<Solver_281>	::=	"{\n"
<Solver_282>	::=	"out_learnt[j++] = out_learnt[i];\n"
<Solver_283>	::=	"break;\n"
<Solver_284>	::=	"}\n"
<Solver_285>	::=	"}\n"
<Solver_286>	::=	"}\n"
<Solver_287>	::=	"}\n"
<Solver_288>	::=	"}\n"
<Solver_289>	::=	"else\n"
<Solver_290>	::=	"{\n"
<Solver_291>	::=	"i = j = out_learnt.size();\n"
<Solver_292>	::=	"}\n"
<Solver_293>	::=	"max_literals += out_learnt.size();\n"
<Solver_294>	::=	"out_learnt.shrink(i - j);\n"
<Solver_295>	::=	"tot_literals += out_learnt.size();\n"
<Solver_296>	::=	"if (out_learnt.size() == 1)\n"
<Solver_297>	::=	"{\n"
<Solver_298>	::=	"out_btlevel = 0;\n"
<Solver_299>	::=	"}\n"
<Solver_300>	::=	"else\n"
<Solver_301>	::=	"{\n"
<Solver_302>	::=	"int max_i = 1;\n"
<Solver_303>	::=	"for (int i = 2; i < out_learnt.size(); i++)\n"
<Solver_304>	::=	"{\n"
<Solver_305>	::=	"if (level(var(out_learnt[i])) > level(var(out_learnt[max_i])))\n"
<Solver_306>	::=	"{\n"
<Solver_307>	::=	"max_i = i;\n"
<Solver_308>	::=	"}\n"
<Solver_309>	::=	"}\n"
<Solver_310>	::=	"Lit p = out_learnt[max_i];\n"
<Solver_311>	::=	"out_learnt[max_i] = out_learnt[1];\n"
<Solver_312>	::=	"out_learnt[1] = p;\n"
<Solver_313>	::=	"out_btlevel = level(var(p));\n"
<Solver_314>	::=	"}\n"
<Solver_315>	::=	"for (int j = 0; j < analyze_toclear.size(); j++)\n"
<Solver_316>	::=	"{\n"
<Solver_317>	::=	"seen[var(analyze_toclear[j])] = 0;\n"
<Solver_318>	::=	"}\n"
<Solver_319>	::=	"}\n"
<Solver_320>	::=	"bool Solver::litRedundant(Lit p, uint32_t abstract_levels)\n"
<Solver_321>	::=	"{\n"
<Solver_322>	::=	"analyze_stack.clear(); analyze_stack.push(p);\n"
<Solver_323>	::=	"int top = analyze_toclear.size();\n"
<Solver_324>	::=	"while (analyze_stack.size() > 0)\n"
<Solver_325>	::=	"{\n"
<Solver_327>	::=	"(( reason(var(analyze_stack.last())) != CRef_Undef) ? static_cast<void> (0) : __assert_fail ( \"reason(var(analyze_stack.last())) != CRef_Undef\" , \"/home/justyna/Documents/minisatgirelease/sources/core/Solver.cc\", 327, __PRETTY_FUNCTION__)) ;\n"
<Solver_328>	::=	"Clause& c = ca[reason(var(analyze_stack.last()))]; analyze_stack.pop();\n"
<Solver_329>	::=	"for (int i = 1; i < c.size(); i++)\n"
<Solver_330>	::=	"{\n"
<Solver_331>	::=	"Lit p = c[i];\n"
<Solver_332>	::=	"if (!seen[var(p)] && level(var(p)) > 0)\n"
<Solver_333>	::=	"{\n"
<Solver_334>	::=	"if (reason(var(p)) != CRef_Undef && (abstractLevel(var(p)) & abstract_levels) != 0)\n"
<Solver_335>	::=	"{\n"
<Solver_336>	::=	"seen[var(p)] = 1;\n"
<Solver_337>	::=	"analyze_stack.push(p);\n"
<Solver_338>	::=	"analyze_toclear.push(p);\n"
<Solver_339>	::=	"}\n"
<Solver_340>	::=	"else\n"
<Solver_341>	::=	"{\n"
<Solver_342>	::=	"for (int j = top; j < analyze_toclear.size(); j++)\n"
<Solver_343>	::=	"{\n"
<Solver_344>	::=	"seen[var(analyze_toclear[j])] = 0;\n"
<Solver_345>	::=	"}\n"
<Solver_346>	::=	"analyze_toclear.shrink(analyze_toclear.size() - top);\n"
<Solver_347>	::=	"return false;\n"
<Solver_348>	::=	"}\n"
<Solver_349>	::=	"}\n"
<Solver_350>	::=	"}\n"
<Solver_351>	::=	"}\n"
<Solver_352>	::=	"return true;\n"
<Solver_353>	::=	"}\n"
<Solver_354>	::=	"void Solver::analyzeFinal(Lit p, vec<Lit>& out_conflict)\n"
<Solver_355>	::=	"{\n"
<Solver_356>	::=	"out_conflict.clear();\n"
<Solver_357>	::=	"out_conflict.push(p);\n"
<Solver_358>	::=	"if (decisionLevel() == 0)\n"
<Solver_359>	::=	"{\n"
<Solver_360>	::=	"return;\n"
<Solver_361>	::=	"}\n"
<Solver_362>	::=	"seen[var(p)] = 1;\n"
<Solver_363>	::=	"for (int i = trail.size()-1; i >= trail_lim[0]; i--)\n"
<Solver_364>	::=	"{\n"
<Solver_365>	::=	"Var x = var(trail[i]);\n"
<Solver_366>	::=	"if (seen[x])\n"
<Solver_367>	::=	"{\n"
<Solver_368>	::=	"if (reason(x) == CRef_Undef)\n"
<Solver_369>	::=	"{\n"
<Solver_371>	::=	"(( level(x) > 0) ? static_cast<void> (0) : __assert_fail ( \"level(x) > 0\" , \"/home/justyna/Documents/minisatgirelease/sources/core/Solver.cc\", 371, __PRETTY_FUNCTION__)) ;\n"
<Solver_372>	::=	"out_conflict.push(~trail[i]);\n"
<Solver_373>	::=	"}\n"
<Solver_374>	::=	"else\n"
<Solver_375>	::=	"{\n"
<Solver_376>	::=	"Clause& c = ca[reason(x)];\n"
<Solver_377>	::=	"for (int j = 1; j < c.size(); j++)\n"
<Solver_378>	::=	"{\n"
<Solver_379>	::=	"if (level(var(c[j])) > 0)\n"
<Solver_380>	::=	"{\n"
<Solver_381>	::=	"seen[var(c[j])] = 1;\n"
<Solver_382>	::=	"}\n"
<Solver_383>	::=	"}\n"
<Solver_384>	::=	"}\n"
<Solver_385>	::=	"seen[x] = 0;\n"
<Solver_386>	::=	"}\n"
<Solver_387>	::=	"}\n"
<Solver_388>	::=	"seen[var(p)] = 0;\n"
<Solver_389>	::=	"}\n"
<Solver_390>	::=	"void Solver::uncheckedEnqueue(Lit p, CRef from)\n"
<Solver_391>	::=	"{\n"
<Solver_393>	::=	"(( value(p) == (lbool((uint8_t)2))) ? static_cast<void> (0) : __assert_fail ( \"value(p) == l_Undef\" , \"/home/justyna/Documents/minisatgirelease/sources/core/Solver.cc\", 393, __PRETTY_FUNCTION__)) ;\n"
<Solver_394>	::=	"assigns[var(p)] = lbool(!sign(p));\n"
<Solver_395>	::=	"vardata[var(p)] = mkVarData(from, decisionLevel());\n"
<Solver_396>	::=	"trail.push_(p);\n"
<Solver_397>	::=	"}\n"
<Solver_398>	::=	"CRef Solver::propagate()\n"
<Solver_399>	::=	"{\n"
<Solver_400>	::=	"CRef confl = CRef_Undef;\n"
<Solver_401>	::=	"int num_props = 0;\n"
<Solver_402>	::=	"watches.cleanAll();\n"
<Solver_403>	::=	"while (qhead < trail.size())\n"
<Solver_404>	::=	"{\n"
<Solver_405>	::=	"Lit p = trail[qhead++];\n"
<Solver_406>	::=	"vec<Watcher>& ws = watches[p];\n"
<Solver_407>	::=	"Watcher *i, *j, *end;\n"
<Solver_408>	::=	"num_props++;\n"
<Solver_409>	::=	"for (i = j = (Watcher*)ws, end = i + ws.size(); i != end;)\n"
<Solver_410>	::=	"{\n"
<Solver_411>	::=	"Lit blocker = i->blocker;\n"
<Solver_412>	::=	"if (value(blocker) == (lbool((uint8_t)0)))\n"
<Solver_413>	::=	"{\n"
<Solver_414>	::=	"*j++ = *i++; continue;\n"
<Solver_415>	::=	"}\n"
<Solver_416>	::=	"CRef cr = i->cref;\n"
<Solver_417>	::=	"Clause& c = ca[cr];\n"
<Solver_418>	::=	"Lit false_lit = ~p;\n"
<Solver_419>	::=	"if (c[0] == false_lit)\n"
<Solver_420>	::=	"{\n"
<Solver_421>	::=	"c[0] = c[1], c[1] = false_lit;\n"
<Solver_422>	::=	"}\n"
<Solver_424>	::=	"(( c[1] == false_lit) ? static_cast<void> (0) : __assert_fail ( \"c[1] == false_lit\" , \"/home/justyna/Documents/minisatgirelease/sources/core/Solver.cc\", 424, __PRETTY_FUNCTION__)) ;\n"
<Solver_425>	::=	"i++;\n"
<Solver_426>	::=	"Lit first = c[0];\n"
<Solver_427>	::=	"Watcher w = Watcher(cr, first);\n"
<Solver_428>	::=	"if (first != blocker && value(first) == (lbool((uint8_t)0)))\n"
<Solver_429>	::=	"{\n"
<Solver_430>	::=	"*j++ = w; continue;\n"
<Solver_431>	::=	"}\n"
<Solver_432>	::=	"for (int k = 2; k < c.size(); k++)\n"
<Solver_433>	::=	"if (value(c[k]) != (lbool((uint8_t)1)))\n"
<Solver_434>	::=	"{\n"
<Solver_435>	::=	"c[1] = c[k]; c[k] = false_lit;\n"
<Solver_436>	::=	"watches[~c[1]].push(w);\n"
<Solver_437>	::=	"goto NextClause;\n"
<Solver_438>	::=	"}\n"
<Solver_439>	::=	"*j++ = w;\n"
<Solver_440>	::=	"if (value(first) == (lbool((uint8_t)1)))\n"
<Solver_441>	::=	"{\n"
<Solver_442>	::=	"confl = cr;\n"
<Solver_443>	::=	"qhead = trail.size();\n"
<Solver_444>	::=	"while (i < end)\n"
<Solver_445>	::=	"*j++ = *i++;\n"
<Solver_446>	::=	"}\n"
<Solver_447>	::=	"else\n"
<Solver_448>	::=	"{\n"
<Solver_449>	::=	"uncheckedEnqueue(first, cr);\n"
<Solver_450>	::=	"}\n"
<Solver_451>	::=	"NextClause:;\n"
<Solver_452>	::=	"}\n"
<Solver_453>	::=	"ws.shrink(i - j);\n"
<Solver_454>	::=	"}\n"
<Solver_455>	::=	"propagations += num_props;\n"
<Solver_456>	::=	"simpDB_props -= num_props;\n"
<Solver_457>	::=	"return confl;\n"
<Solver_458>	::=	"}\n"
<Solver_459>	::=	"struct reduceDB_lt\n"
<Solver_460>	::=	"{\n"
<Solver_461>	::=	"ClauseAllocator& ca;\n"
<Solver_462>	::=	"reduceDB_lt(ClauseAllocator& ca_) : ca(ca_)\n"
<Solver_463>	::=	"{\n"
<Solver_464>	::=	"}\n"
<Solver_465>	::=	"bool operator () (CRef x, CRef y)\n"
<Solver_466>	::=	"{\n"
<Solver_467>	::=	"return ca[x].size() > 2 && (ca[y].size() == 2 || ca[x].activity() < ca[y].activity());\n"
<Solver_468>	::=	"}\n"
<Solver_469>	::=	"}\n"
<Solver_470>	::=	";\n"
<Solver_471>	::=	"void Solver::reduceDB()\n"
<Solver_472>	::=	"{\n"
<Solver_473>	::=	"int i, j;\n"
<Solver_474>	::=	"double extra_lim = cla_inc / learnts.size();\n"
<Solver_475>	::=	"sort(learnts, reduceDB_lt(ca));\n"
<Solver_476>	::=	"for (i = j = 0; i < learnts.size(); i++)\n"
<Solver_477>	::=	"{\n"
<Solver_478>	::=	"Clause& c = ca[learnts[i]];\n"
<Solver_479>	::=	"if (c.size() > 2 && !locked(c) && (i < learnts.size() / 2 || c.activity() < extra_lim))\n"
<Solver_480>	::=	"{\n"
<Solver_481>	::=	"removeClause(learnts[i]);\n"
<Solver_482>	::=	"}\n"
<Solver_483>	::=	"else\n"
<Solver_484>	::=	"{\n"
<Solver_485>	::=	"learnts[j++] = learnts[i];\n"
<Solver_486>	::=	"}\n"
<Solver_487>	::=	"}\n"
<Solver_488>	::=	"learnts.shrink(i - j);\n"
<Solver_489>	::=	"checkGarbage();\n"
<Solver_490>	::=	"}\n"
<Solver_491>	::=	"void Solver::removeSatisfied(vec<CRef>& cs)\n"
<Solver_492>	::=	"{\n"
<Solver_493>	::=	"int i, j;\n"
<Solver_494>	::=	"for (i = j = 0; i < cs.size(); i++)\n"
<Solver_495>	::=	"{\n"
<Solver_496>	::=	"Clause& c = ca[cs[i]];\n"
<Solver_497>	::=	"if (satisfied(c))\n"
<Solver_498>	::=	"{\n"
<Solver_499>	::=	"removeClause(cs[i]);\n"
<Solver_500>	::=	"}\n"
<Solver_501>	::=	"else\n"
<Solver_502>	::=	"{\n"
<Solver_503>	::=	"cs[j++] = cs[i];\n"
<Solver_504>	::=	"}\n"
<Solver_505>	::=	"}\n"
<Solver_506>	::=	"cs.shrink(i - j);\n"
<Solver_507>	::=	"}\n"
<Solver_508>	::=	"void Solver::rebuildOrderHeap()\n"
<Solver_509>	::=	"{\n"
<Solver_510>	::=	"vec<Var> vs;\n"
<Solver_511>	::=	"for (Var v = 0; v < nVars(); v++)\n"
<Solver_512>	::=	"{\n"
<Solver_513>	::=	"if (decision[v] && value(v) == (lbool((uint8_t)2)))\n"
<Solver_514>	::=	"{\n"
<Solver_515>	::=	"vs.push(v);\n"
<Solver_516>	::=	"}\n"
<Solver_517>	::=	"}\n"
<Solver_518>	::=	"order_heap.build(vs);\n"
<Solver_519>	::=	"}\n"
<Solver_520>	::=	"bool Solver::simplify()\n"
<Solver_521>	::=	"{\n"
<Solver_523>	::=	"(( decisionLevel() == 0) ? static_cast<void> (0) : __assert_fail ( \"decisionLevel() == 0\" , \"/home/justyna/Documents/minisatgirelease/sources/core/Solver.cc\", 523, __PRETTY_FUNCTION__)) ;\n"
<Solver_524>	::=	"if (!ok || propagate() != CRef_Undef)\n"
<Solver_525>	::=	"{\n"
<Solver_526>	::=	"return ok = false;\n"
<Solver_527>	::=	"}\n"
<Solver_528>	::=	"if (nAssigns() == simpDB_assigns || (simpDB_props > 0))\n"
<Solver_529>	::=	"{\n"
<Solver_530>	::=	"return true;\n"
<Solver_531>	::=	"}\n"
<Solver_532>	::=	"removeSatisfied(learnts);\n"
<Solver_533>	::=	"if (remove_satisfied)\n"
<Solver_534>	::=	"{\n"
<Solver_535>	::=	"removeSatisfied(clauses);\n"
<Solver_536>	::=	"}\n"
<Solver_537>	::=	"checkGarbage();\n"
<Solver_538>	::=	"rebuildOrderHeap();\n"
<Solver_539>	::=	"simpDB_assigns = nAssigns();\n"
<Solver_540>	::=	"simpDB_props = clauses_literals + learnts_literals;\n"
<Solver_541>	::=	"return true;\n"
<Solver_542>	::=	"}\n"
<Solver_543>	::=	"lbool Solver::search(int nof_conflicts)\n"
<Solver_544>	::=	"{\n"
<Solver_546>	::=	"(( ok) ? static_cast<void> (0) : __assert_fail ( \"ok\" , \"/home/justyna/Documents/minisatgirelease/sources/core/Solver.cc\", 546, __PRETTY_FUNCTION__)) ;\n"
<Solver_547>	::=	"int backtrack_level;\n"
<Solver_548>	::=	"int conflictC = 0;\n"
<Solver_549>	::=	"vec<Lit> learnt_clause;\n"
<Solver_550>	::=	"starts++;\n"
<Solver_551>	::=	"for (;;)\n"
<Solver_552>	::=	"{\n"
<Solver_553>	::=	"CRef confl = propagate();\n"
<Solver_554>	::=	"if (confl != CRef_Undef)\n"
<Solver_555>	::=	"{\n"
<Solver_556>	::=	"conflicts++; conflictC++;\n"
<Solver_557>	::=	"if (decisionLevel() == 0)\n"
<Solver_558>	::=	"{\n"
<Solver_559>	::=	"return (lbool((uint8_t)1));\n"
<Solver_560>	::=	"}\n"
<Solver_561>	::=	"learnt_clause.clear();\n"
<Solver_562>	::=	"analyze(confl, learnt_clause, backtrack_level);\n"
<Solver_563>	::=	"cancelUntil(backtrack_level);\n"
<Solver_564>	::=	"if (learnt_clause.size() == 1)\n"
<Solver_565>	::=	"{\n"
<Solver_566>	::=	"uncheckedEnqueue(learnt_clause[0]);\n"
<Solver_567>	::=	"}\n"
<Solver_568>	::=	"else\n"
<Solver_569>	::=	"{\n"
<Solver_570>	::=	"CRef cr = ca.alloc(learnt_clause, true);\n"
<Solver_571>	::=	"learnts.push(cr);\n"
<Solver_572>	::=	"attachClause(cr);\n"
<Solver_573>	::=	"claBumpActivity(ca[cr]);\n"
<Solver_574>	::=	"uncheckedEnqueue(learnt_clause[0], cr);\n"
<Solver_575>	::=	"}\n"
<Solver_576>	::=	"varDecayActivity();\n"
<Solver_577>	::=	"claDecayActivity();\n"
<Solver_578>	::=	"if (--learntsize_adjust_cnt == 0)\n"
<Solver_579>	::=	"{\n"
<Solver_580>	::=	"learntsize_adjust_confl *= learntsize_adjust_inc;\n"
<Solver_581>	::=	"learntsize_adjust_cnt = (int)learntsize_adjust_confl;\n"
<Solver_582>	::=	"max_learnts *= learntsize_inc;\n"
<Solver_583>	::=	"if (verbosity >= 1)\n"
<Solver_584>	::=	"{\n"
<Solver_585>	::=	"printf(\"| %9d | %7d %8d %8d | %8d %8d %6.0f | %6.3f %% |\n\",\n"
<Solver_586>	::=	"(int)conflicts,\n"
<Solver_587>	::=	"(int)dec_vars - (trail_lim.size() == 0 ? trail.size() : trail_lim[0]), nClauses(), (int)clauses_literals,\n"
<Solver_588>	::=	"(int)max_learnts, nLearnts(), (double)learnts_literals/nLearnts(), progressEstimate()*100);\n"
<Solver_589>	::=	"}\n"
<Solver_590>	::=	"}\n"
<Solver_591>	::=	"}\n"
<Solver_592>	::=	"else\n"
<Solver_593>	::=	"{\n"
<Solver_594>	::=	"if (nof_conflicts >= 0 && conflictC >= nof_conflicts || !withinBudget())\n"
<Solver_595>	::=	"{\n"
<Solver_596>	::=	"progress_estimate = progressEstimate();\n"
<Solver_597>	::=	"cancelUntil(0);\n"
<Solver_598>	::=	"return (lbool((uint8_t)2));\n"
<Solver_599>	::=	"}\n"
<Solver_600>	::=	"if (decisionLevel() == 0 && !simplify())\n"
<Solver_601>	::=	"{\n"
<Solver_602>	::=	"return (lbool((uint8_t)1));\n"
<Solver_603>	::=	"}\n"
<Solver_604>	::=	"if (learnts.size()-nAssigns() >= max_learnts)\n"
<Solver_605>	::=	"{\n"
<Solver_606>	::=	"reduceDB();\n"
<Solver_607>	::=	"}\n"
<Solver_608>	::=	"Lit next = lit_Undef;\n"
<Solver_609>	::=	"while (decisionLevel() < assumptions.size())\n"
<Solver_610>	::=	"{\n"
<Solver_611>	::=	"Lit p = assumptions[decisionLevel()];\n"
<Solver_612>	::=	"if (value(p) == (lbool((uint8_t)0)))\n"
<Solver_613>	::=	"{\n"
<Solver_614>	::=	"newDecisionLevel();\n"
<Solver_615>	::=	"}\n"
<Solver_616>	::=	"else if (value(p) == (lbool((uint8_t)1)))\n"
<Solver_617>	::=	"{\n"
<Solver_618>	::=	"analyzeFinal(~p, conflict);\n"
<Solver_619>	::=	"return (lbool((uint8_t)1));\n"
<Solver_620>	::=	"}\n"
<Solver_621>	::=	"else\n"
<Solver_622>	::=	"{\n"
<Solver_623>	::=	"next = p;\n"
<Solver_624>	::=	"break;\n"
<Solver_625>	::=	"}\n"
<Solver_626>	::=	"}\n"
<Solver_627>	::=	"if (next == lit_Undef)\n"
<Solver_628>	::=	"{\n"
<Solver_629>	::=	"decisions++;\n"
<Solver_630>	::=	"next = pickBranchLit();\n"
<Solver_631>	::=	"if (next == lit_Undef)\n"
<Solver_632>	::=	"{\n"
<Solver_633>	::=	"return (lbool((uint8_t)0));\n"
<Solver_634>	::=	"}\n"
<Solver_635>	::=	"}\n"
<Solver_636>	::=	"newDecisionLevel();\n"
<Solver_637>	::=	"uncheckedEnqueue(next);\n"
<Solver_638>	::=	"}\n"
<Solver_639>	::=	"}\n"
<Solver_640>	::=	"}\n"
<Solver_641>	::=	"double Solver::progressEstimate() const\n"
<Solver_642>	::=	"{\n"
<Solver_643>	::=	"double progress = 0;\n"
<Solver_644>	::=	"double F = 1.0 / nVars();\n"
<Solver_645>	::=	"for (int i = 0; i <= decisionLevel(); i++)\n"
<Solver_646>	::=	"{\n"
<Solver_647>	::=	"int beg = i == 0 ? 0 : trail_lim[i - 1];\n"
<Solver_648>	::=	"int end = i == decisionLevel() ? trail.size() : trail_lim[i];\n"
<Solver_649>	::=	"progress += pow(F, i) * (end - beg);\n"
<Solver_650>	::=	"}\n"
<Solver_651>	::=	"return progress / nVars();\n"
<Solver_652>	::=	"}\n"
<Solver_653>	::=	"static double luby(double y, int x)\n"
<Solver_654>	::=	"{\n"
<Solver_655>	::=	"int size, seq;\n"
<Solver_656>	::=	"for (size = 1, seq = 0; size < x+1; seq++, size = 2*size+1);\n"
<Solver_657>	::=	"while (size-1 != x)\n"
<Solver_658>	::=	"{\n"
<Solver_659>	::=	"size = (size-1)>>1;\n"
<Solver_660>	::=	"seq--;\n"
<Solver_661>	::=	"x = x % size;\n"
<Solver_662>	::=	"}\n"
<Solver_663>	::=	"return pow(y, seq);\n"
<Solver_664>	::=	"}\n"
<Solver_665>	::=	"lbool Solver::solve_()\n"
<Solver_666>	::=	"{\n"
<Solver_667>	::=	"model.clear();\n"
<Solver_668>	::=	"conflict.clear();\n"
<Solver_669>	::=	"if (!ok) return (lbool((uint8_t)1));\n"
<Solver_670>	::=	"solves++;\n"
<Solver_671>	::=	"max_learnts = nClauses() * learntsize_factor;\n"
<Solver_672>	::=	"learntsize_adjust_confl = learntsize_adjust_start_confl;\n"
<Solver_673>	::=	"learntsize_adjust_cnt = (int)learntsize_adjust_confl;\n"
<Solver_674>	::=	"lbool status = (lbool((uint8_t)2));\n"
<Solver_675>	::=	"if (verbosity >= 1)\n"
<Solver_676>	::=	"{\n"
<Solver_677>	::=	"printf(\"============================[ Search Statistics ]==============================\n\");\n"
<Solver_678>	::=	"printf(\"| Conflicts | ORIGINAL | LEARNT | Progress |\n\");\n"
<Solver_679>	::=	"printf(\"| | Vars Clauses Literals | Limit Clauses Lit/Cl | |\n\");\n"
<Solver_680>	::=	"printf(\"===============================================================================\n\");\n"
<Solver_681>	::=	"}\n"
<Solver_682>	::=	"int curr_restarts = 0;\n"
<Solver_683>	::=	"while (status == (lbool((uint8_t)2)))\n"
<Solver_684>	::=	"{\n"
<Solver_685>	::=	"double rest_base = luby_restart ? luby(restart_inc, curr_restarts) : pow(restart_inc, curr_restarts);\n"
<Solver_686>	::=	"status = search(rest_base * restart_first);\n"
<Solver_687>	::=	"if (!withinBudget()) break;\n"
<Solver_688>	::=	"curr_restarts++;\n"
<Solver_689>	::=	"}\n"
<Solver_690>	::=	"if (verbosity >= 1)\n"
<Solver_691>	::=	"{\n"
<Solver_692>	::=	"printf(\"===============================================================================\n\");\n"
<Solver_693>	::=	"}\n"
<Solver_694>	::=	"if (status == (lbool((uint8_t)0)))\n"
<Solver_695>	::=	"{\n"
<Solver_696>	::=	"model.growTo(nVars());\n"
<Solver_697>	::=	"for (int i = 0; i < nVars(); i++) model[i] = value(i);\n"
<Solver_698>	::=	"}\n"
<Solver_699>	::=	"else if (status == (lbool((uint8_t)1)) && conflict.size() == 0)\n"
<Solver_700>	::=	"{\n"
<Solver_701>	::=	"ok = false;\n"
<Solver_702>	::=	"}\n"
<Solver_703>	::=	"cancelUntil(0);\n"
<Solver_704>	::=	"return status;\n"
<Solver_705>	::=	"}\n"
<Solver_706>	::=	"static Var mapVar(Var x, vec<Var>& map, Var& max)\n"
<Solver_707>	::=	"{\n"
<Solver_708>	::=	"if (map.size() <= x || map[x] == -1)\n"
<Solver_709>	::=	"{\n"
<Solver_710>	::=	"map.growTo(x+1, -1);\n"
<Solver_711>	::=	"map[x] = max++;\n"
<Solver_712>	::=	"}\n"
<Solver_713>	::=	"return map[x];\n"
<Solver_714>	::=	"}\n"
<Solver_715>	::=	"void Solver::toDimacs(FILE* f, Clause& c, vec<Var>& map, Var& max)\n"
<Solver_716>	::=	"{\n"
<Solver_717>	::=	"if (satisfied(c))\n"
<Solver_718>	::=	"{\n"
<Solver_719>	::=	"return;\n"
<Solver_720>	::=	"}\n"
<Solver_721>	::=	"for (int i = 0; i < c.size(); i++)\n"
<Solver_722>	::=	"{\n"
<Solver_723>	::=	"if (value(c[i]) != (lbool((uint8_t)1)))\n"
<Solver_724>	::=	"{\n"
<Solver_725>	::=	"fprintf(f, \"%s%d \", sign(c[i]) ? \"-\" : \"\", mapVar(var(c[i]), map, max)+1);\n"
<Solver_726>	::=	"}\n"
<Solver_727>	::=	"}\n"
<Solver_728>	::=	"fprintf(f, \"0\n\");\n"
<Solver_729>	::=	"}\n"
<Solver_730>	::=	"void Solver::toDimacs(const char *file, const vec<Lit>& assumps)\n"
<Solver_731>	::=	"{\n"
<Solver_732>	::=	"FILE* f = fopen(file, \"wr\");\n"
<Solver_733>	::=	"if (f == __null)\n"
<Solver_734>	::=	"{\n"
<Solver_735>	::=	"fprintf( stderr , \"could not open file %s\n\", file), exit(1);\n"
<Solver_736>	::=	"}\n"
<Solver_737>	::=	"toDimacs(f, assumps);\n"
<Solver_738>	::=	"fclose(f);\n"
<Solver_739>	::=	"}\n"
<Solver_740>	::=	"void Solver::toDimacs(FILE* f, const vec<Lit>& assumps)\n"
<Solver_741>	::=	"{\n"
<Solver_742>	::=	"if (!ok)\n"
<Solver_743>	::=	"{\n"
<Solver_744>	::=	"fprintf(f, \"p cnf 1 2\n1 0\n-1 0\n\");\n"
<Solver_745>	::=	"return;\n"
<Solver_746>	::=	"}\n"
<Solver_747>	::=	"vec<Var> map; Var max = 0;\n"
<Solver_748>	::=	"int cnt = 0;\n"
<Solver_749>	::=	"for (int i = 0; i < clauses.size(); i++)\n"
<Solver_750>	::=	"{\n"
<Solver_751>	::=	"if (!satisfied(ca[clauses[i]]))\n"
<Solver_752>	::=	"{\n"
<Solver_753>	::=	"cnt++;\n"
<Solver_754>	::=	"}\n"
<Solver_755>	::=	"}\n"
<Solver_756>	::=	"for (int i = 0; i < clauses.size(); i++)\n"
<Solver_757>	::=	"{\n"
<Solver_758>	::=	"if (!satisfied(ca[clauses[i]]))\n"
<Solver_759>	::=	"{\n"
<Solver_760>	::=	"Clause& c = ca[clauses[i]];\n"
<Solver_761>	::=	"for (int j = 0; j < c.size(); j++)\n"
<Solver_762>	::=	"if (value(c[j]) != (lbool((uint8_t)1)))\n"
<Solver_763>	::=	"{\n"
<Solver_764>	::=	"mapVar(var(c[j]), map, max);\n"
<Solver_765>	::=	"}\n"
<Solver_766>	::=	"}\n"
<Solver_767>	::=	"}\n"
<Solver_768>	::=	"cnt += assumptions.size();\n"
<Solver_769>	::=	"fprintf(f, \"p cnf %d %d\n\", max, cnt);\n"
<Solver_770>	::=	"for (int i = 0; i < assumptions.size(); i++)\n"
<Solver_771>	::=	"{\n"
<Solver_773>	::=	"(( value(assumptions[i]) != (lbool((uint8_t)1))) ? static_cast<void> (0) : __assert_fail ( \"value(assumptions[i]) != l_False\" , \"/home/justyna/Documents/minisatgirelease/sources/core/Solver.cc\", 773, __PRETTY_FUNCTION__)) ;\n"
<Solver_774>	::=	"fprintf(f, \"%s%d 0\n\", sign(assumptions[i]) ? \"-\" : \"\", mapVar(var(assumptions[i]), map, max)+1);\n"
<Solver_775>	::=	"}\n"
<Solver_776>	::=	"for (int i = 0; i < clauses.size(); i++)\n"
<Solver_777>	::=	"{\n"
<Solver_778>	::=	"toDimacs(f, ca[clauses[i]], map, max);\n"
<Solver_779>	::=	"}\n"
<Solver_780>	::=	"if (verbosity > 0)\n"
<Solver_781>	::=	"{\n"
<Solver_782>	::=	"printf(\"Wrote %d clauses with %d variables.\n\", cnt, max);\n"
<Solver_783>	::=	"}\n"
<Solver_784>	::=	"}\n"
<Solver_785>	::=	"void Solver::relocAll(ClauseAllocator& to)\n"
<Solver_786>	::=	"{\n"
<Solver_787>	::=	"watches.cleanAll();\n"
<Solver_788>	::=	"for (int v = 0; v < nVars(); v++)\n"
<Solver_789>	::=	"{\n"
<Solver_790>	::=	"for (int s = 0; s < 2; s++)\n"
<Solver_791>	::=	"{\n"
<Solver_792>	::=	"Lit p = mkLit(v, s);\n"
<Solver_793>	::=	"vec<Watcher>& ws = watches[p];\n"
<Solver_794>	::=	"for (int j = 0; j < ws.size(); j++)\n"
<Solver_795>	::=	"{\n"
<Solver_796>	::=	"ca.reloc(ws[j].cref, to);\n"
<Solver_797>	::=	"}\n"
<Solver_798>	::=	"}\n"
<Solver_799>	::=	"}\n"
<Solver_800>	::=	"for (int i = 0; i < trail.size(); i++)\n"
<Solver_801>	::=	"{\n"
<Solver_802>	::=	"Var v = var(trail[i]);\n"
<Solver_803>	::=	"if (reason(v) != CRef_Undef && (ca[reason(v)].reloced() || locked(ca[reason(v)])))\n"
<Solver_804>	::=	"{\n"
<Solver_805>	::=	"ca.reloc(vardata[v].reason, to);\n"
<Solver_806>	::=	"}\n"
<Solver_807>	::=	"}\n"
<Solver_808>	::=	"for (int i = 0; i < learnts.size(); i++)\n"
<Solver_809>	::=	"{\n"
<Solver_810>	::=	"ca.reloc(learnts[i], to);\n"
<Solver_811>	::=	"}\n"
<Solver_812>	::=	"for (int i = 0; i < clauses.size(); i++)\n"
<Solver_813>	::=	"{\n"
<Solver_814>	::=	"ca.reloc(clauses[i], to);\n"
<Solver_815>	::=	"}\n"
<Solver_816>	::=	"}\n"
<Solver_817>	::=	"void Solver::garbageCollect()\n"
<Solver_818>	::=	"{\n"
<Solver_819>	::=	"ClauseAllocator to(ca.size() - ca.wasted());\n"
<Solver_820>	::=	"relocAll(to);\n"
<Solver_821>	::=	"if (verbosity >= 2)\n"
<Solver_822>	::=	"{\n"
<Solver_823>	::=	"printf(\"| Garbage collection: %12d bytes => %12d bytes |\n\",\n"
<Solver_824>	::=	"ca.size()*ClauseAllocator::Unit_Size, to.size()*ClauseAllocator::Unit_Size);\n"
<Solver_825>	::=	"}\n"
<Solver_826>	::=	"to.moveTo(ca);\n"
<Solver_827>	::=	"}\n"
<Solver>	::=	<Solver_3> <Solver_4> <Solver_5> <Solver_6> <Solver_7> <Solver_8> <Solver_9> <Solver_10> <Solver_11> <Solver_12> <Solver_13> <Solver_14> <Solver_15> <Solver_16> <Solver_17> <Solver_18> <Solver_19> <Solver_20> <Solver_21> <Solver_22> <Solver_23> <Solver_24> <Solver_25> <Solver_26> <Solver_27> <Solver_28> <Solver_29> <Solver_30> <Solver_31> <Solver_32> <Solver_33> <Solver_34> <Solver_35> <Solver_36> <Solver_37> <Solver_38> <Solver_39> <Solver_40> <Solver_41> <Solver_42> <Solver_43> <Solver_44> <Solver_45> <Solver_46> <Solver_47> <Solver_48> <Solver_49> <Solver_50> <Solver_51> <Solver_52> <Solver_53> <Solver_54> <Solver_55> <Solver_56> <Solver_57> <Solver_58> <Solver_59> <Solver_60> <Solver_61> <Solver_62> <Solver_63> <Solver_64> <Solver_65> <Solver_66> <Solver_67> <Solver_68> <Solver_69> <Solver_70> <Solver_71> <Solver_73> <Solver_74> <Solver_75> <Solver_76> <Solver_77> <Solver_78> <Solver_79> <Solver_80> <Solver_81> <Solver_82> <Solver_83> <Solver_84> <Solver_85> <Solver_86> <Solver_87> <Solver_88> <Solver_89> <Solver_90> <Solver_91> <Solver_92> <Solver_93> <Solver_94> <Solver_95> <Solver_96> <Solver_97> <Solver_98> <Solver_99> <Solver_100> <Solver_101> <Solver_102> <Solver_103> <Solver_104> <Solver_105> <Solver_106> <Solver_107> <Solver_108> <Solver_109> <Solver_110> <Solver_111> <Solver_113> <Solver_114> <Solver_115> <Solver_116> <Solver_117> <Solver_118> <Solver_119> <Solver_120> <Solver_121> <Solver_123> <Solver_124> <Solver_125> <Solver_126> <Solver_127> <Solver_128> <Solver_129> <Solver_130> <Solver_131> <Solver_132> <Solver_133> <Solver_134> <Solver_135> <Solver_136> <Solver_137> <Solver_138> <Solver_139> <Solver_140> <Solver_141> <Solver_142> <Solver_143> <Solver_144> <Solver_145> <Solver_146> <Solver_147> <Solver_148> <Solver_149> <Solver_150> <Solver_151> <Solver_152> <Solver_153> <Solver_154> <Solver_155> <Solver_156> <Solver_157> <Solver_158> <Solver_159> <Solver_160> <Solver_161> <Solver_162> <Solver_163> <Solver_164> <Solver_165> <Solver_166> <Solver_167> <Solver_168> <Solver_169> <Solver_170> <Solver_171> <Solver_172> <Solver_173> <Solver_174> <Solver_175> <Solver_176> <Solver_177> <Solver_178> <Solver_179> <Solver_180> <Solver_181> <Solver_182> <Solver_183> <Solver_184> <Solver_185> <Solver_186> <Solver_187> <Solver_188> <Solver_189> <Solver_190> <Solver_191> <Solver_192> <Solver_193> <Solver_194> <Solver_195> <Solver_196> <Solver_197> <Solver_198> <Solver_199> <Solver_200> <Solver_201> <Solver_202> <Solver_203> <Solver_204> <Solver_205> <Solver_206> <Solver_207> <Solver_208> <Solver_209> <Solver_210> <Solver_211> <Solver_212> <Solver_213> <Solver_214> <Solver_215> <Solver_216> <Solver_218> <Solver_219> <Solver_220> <Solver_221> <Solver_222> <Solver_223> <Solver_224> <Solver_225> <Solver_226> <Solver_227> <Solver_228> <Solver_229> <Solver_230> <Solver_231> <Solver_232> <Solver_233> <Solver_234> <Solver_235> <Solver_236> <Solver_237> <Solver_238> <Solver_239> <Solver_240> <Solver_241> <Solver_242> <Solver_243> <Solver_244> <Solver_245> <Solver_246> <Solver_247> <Solver_248> <Solver_249> <Solver_250> <Solver_251> <Solver_252> <Solver_253> <Solver_254> <Solver_255> <Solver_256> <Solver_257> <Solver_258> <Solver_259> <Solver_260> <Solver_261> <Solver_262> <Solver_263> <Solver_264> <Solver_265> <Solver_266> <Solver_267> <Solver_268> <Solver_269> <Solver_270> <Solver_271> <Solver_272> <Solver_273> <Solver_274> <Solver_275> <Solver_276> <Solver_277> <Solver_278> <Solver_279> <Solver_280> <Solver_281> <Solver_282> <Solver_283> <Solver_284> <Solver_285> <Solver_286> <Solver_287> <Solver_288> <Solver_289> <Solver_290> <Solver_291> <Solver_292> <Solver_293> <Solver_294> <Solver_295> <Solver_296> <Solver_297> <Solver_298> <Solver_299> <Solver_300> <Solver_301> <Solver_302> <Solver_303> <Solver_304> <Solver_305> <Solver_306> <Solver_307> <Solver_308> <Solver_309> <Solver_310> <Solver_311> <Solver_312> <Solver_313> <Solver_314> <Solver_315> <Solver_316> <Solver_317> <Solver_318> <Solver_319> <Solver_320> <Solver_321> <Solver_322> <Solver_323> <Solver_324> <Solver_325> <Solver_327> <Solver_328> <Solver_329> <Solver_330> <Solver_331> <Solver_332> <Solver_333> <Solver_334> <Solver_335> <Solver_336> <Solver_337> <Solver_338> <Solver_339> <Solver_340> <Solver_341> <Solver_342> <Solver_343> <Solver_344> <Solver_345> <Solver_346> <Solver_347> <Solver_348> <Solver_349> <Solver_350> <Solver_351> <Solver_352> <Solver_353> <Solver_354> <Solver_355> <Solver_356> <Solver_357> <Solver_358> <Solver_359> <Solver_360> <Solver_361> <Solver_362> <Solver_363> <Solver_364> <Solver_365> <Solver_366> <Solver_367> <Solver_368> <Solver_369> <Solver_371> <Solver_372> <Solver_373> <Solver_374> <Solver_375> <Solver_376> <Solver_377> <Solver_378> <Solver_379> <Solver_380> <Solver_381> <Solver_382> <Solver_383> <Solver_384> <Solver_385> <Solver_386> <Solver_387> <Solver_388> <Solver_389> <Solver_390> <Solver_391> <Solver_393> <Solver_394> <Solver_395> <Solver_396> <Solver_397> <Solver_398> <Solver_399> <Solver_400> <Solver_401> <Solver_402> <Solver_403> <Solver_404> <Solver_405> <Solver_406> <Solver_407> <Solver_408> <Solver_409> <Solver_410> <Solver_411> <Solver_412> <Solver_413> <Solver_414> <Solver_415> <Solver_416> <Solver_417> <Solver_418> <Solver_419> <Solver_420> <Solver_421> <Solver_422> <Solver_424> <Solver_425> <Solver_426> <Solver_427> <Solver_428> <Solver_429> <Solver_430> <Solver_431> <Solver_432> <Solver_433> <Solver_434> <Solver_435> <Solver_436> <Solver_437> <Solver_438> <Solver_439> <Solver_440> <Solver_441> <Solver_442> <Solver_443> <Solver_444> <Solver_445> <Solver_446> <Solver_447> <Solver_448> <Solver_449> <Solver_450> <Solver_451> <Solver_452> <Solver_453> <Solver_454> <Solver_455> <Solver_456> <Solver_457> <Solver_458> <Solver_459> <Solver_460> <Solver_461> <Solver_462> <Solver_463> <Solver_464> <Solver_465> <Solver_466> <Solver_467> <Solver_468> <Solver_469> <Solver_470> <Solver_471> <Solver_472> <Solver_473> <Solver_474> <Solver_475> <Solver_476> <Solver_477> <Solver_478> <Solver_479> <Solver_480> <Solver_481> <Solver_482> <Solver_483> <Solver_484> <Solver_485> <Solver_486> <Solver_487> <Solver_488> <Solver_489> <Solver_490> <Solver_491> <Solver_492> <Solver_493> <Solver_494> <Solver_495> <Solver_496> <Solver_497> <Solver_498> <Solver_499> <Solver_500> <Solver_501> <Solver_502> <Solver_503> <Solver_504> <Solver_505> <Solver_506> <Solver_507> <Solver_508> <Solver_509> <Solver_510> <Solver_511> <Solver_512> <Solver_513> <Solver_514> <Solver_515> <Solver_516> <Solver_517> <Solver_518> <Solver_519> <Solver_520> <Solver_521> <Solver_523> <Solver_524> <Solver_525> <Solver_526> <Solver_527> <Solver_528> <Solver_529> <Solver_530> <Solver_531> <Solver_532> <Solver_533> <Solver_534> <Solver_535> <Solver_536> <Solver_537> <Solver_538> <Solver_539> <Solver_540> <Solver_541> <Solver_542> <Solver_543> <Solver_544> <Solver_546> <Solver_547> <Solver_548> <Solver_549> <Solver_550> <Solver_551> <Solver_552> <Solver_553> <Solver_554> <Solver_555> <Solver_556> <Solver_557> <Solver_558> <Solver_559> <Solver_560> <Solver_561> <Solver_562> <Solver_563> <Solver_564> <Solver_565> <Solver_566> <Solver_567> <Solver_568> <Solver_569> <Solver_570> <Solver_571> <Solver_572> <Solver_573> <Solver_574> <Solver_575> <Solver_576> <Solver_577> <Solver_578> <Solver_579> <Solver_580> <Solver_581> <Solver_582> <Solver_583> <Solver_584> <Solver_585> <Solver_586> <Solver_587> <Solver_588> <Solver_589> <Solver_590> <Solver_591> <Solver_592> <Solver_593> <Solver_594> <Solver_595> <Solver_596> <Solver_597> <Solver_598> <Solver_599> <Solver_600> <Solver_601> <Solver_602> <Solver_603> <Solver_604> <Solver_605> <Solver_606> <Solver_607> <Solver_608> <Solver_609> <Solver_610> <Solver_611> <Solver_612> <Solver_613> <Solver_614> <Solver_615> <Solver_616> <Solver_617> <Solver_618> <Solver_619> <Solver_620> <Solver_621> <Solver_622> <Solver_623> <Solver_624> <Solver_625> <Solver_626> <Solver_627> <Solver_628> <Solver_629> <Solver_630> <Solver_631> <Solver_632> <Solver_633> <Solver_634> <Solver_635> <Solver_636> <Solver_637> <Solver_638> <Solver_639> <Solver_640> <Solver_641> <Solver_642> <Solver_643> <Solver_644> <Solver_645> <Solver_646> <Solver_647> <Solver_648> <Solver_649> <Solver_650> <Solver_651> <Solver_652> <Solver_653> <Solver_654> <Solver_655> <Solver_656> <Solver_657> <Solver_658> <Solver_659> <Solver_660> <Solver_661> <Solver_662> <Solver_663> <Solver_664> <Solver_665> <Solver_666> <Solver_667> <Solver_668> <Solver_669> <Solver_670> <Solver_671> <Solver_672> <Solver_673> <Solver_674> <Solver_675> <Solver_676> <Solver_677> <Solver_678> <Solver_679> <Solver_680> <Solver_681> <Solver_682> <Solver_683> <Solver_684> <Solver_685> <Solver_686> <Solver_687> <Solver_688> <Solver_689> <Solver_690> <Solver_691> <Solver_692> <Solver_693> <Solver_694> <Solver_695> <Solver_696> <Solver_697> <Solver_698> <Solver_699> <Solver_700> <Solver_701> <Solver_702> <Solver_703> <Solver_704> <Solver_705> <Solver_706> <Solver_707> <Solver_708> <Solver_709> <Solver_710> <Solver_711> <Solver_712> <Solver_713> <Solver_714> <Solver_715> <Solver_716> <Solver_717> <Solver_718> <Solver_719> <Solver_720> <Solver_721> <Solver_722> <Solver_723> <Solver_724> <Solver_725> <Solver_726> <Solver_727> <Solver_728> <Solver_729> <Solver_730> <Solver_731> <Solver_732> <Solver_733> <Solver_734> <Solver_735> <Solver_736> <Solver_737> <Solver_738> <Solver_739> <Solver_740> <Solver_741> <Solver_742> <Solver_743> <Solver_744> <Solver_745> <Solver_746> <Solver_747> <Solver_748> <Solver_749> <Solver_750> <Solver_751> <Solver_752> <Solver_753> <Solver_754> <Solver_755> <Solver_756> <Solver_757> <Solver_758> <Solver_759> <Solver_760> <Solver_761> <Solver_762> <Solver_763> <Solver_764> <Solver_765> <Solver_766> <Solver_767> <Solver_768> <Solver_769> <Solver_770> <Solver_771> <Solver_773> <Solver_774> <Solver_775> <Solver_776> <Solver_777> <Solver_778> <Solver_779> <Solver_780> <Solver_781> <Solver_782> <Solver_783> <Solver_784> <Solver_785> <Solver_786> <Solver_787> <Solver_788> <Solver_789> <Solver_790> <Solver_791> <Solver_792> <Solver_793> <Solver_794> <Solver_795> <Solver_796> <Solver_797> <Solver_798> <Solver_799> <Solver_800> <Solver_801> <Solver_802> <Solver_803> <Solver_804> <Solver_805> <Solver_806> <Solver_807> <Solver_808> <Solver_809> <Solver_810> <Solver_811> <Solver_812> <Solver_813> <Solver_814> <Solver_815> <Solver_816> <Solver_817> <Solver_818> <Solver_819> <Solver_820> <Solver_821> <Solver_822> <Solver_823> <Solver_824> <Solver_825> <Solver_826> <Solver_827> 
<start>	::= <Solver>
