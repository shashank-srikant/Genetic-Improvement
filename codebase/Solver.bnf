#create_syntax.awk Revision: 1.51  Thu Oct 24 17:55:10 BST 2013
#Solver_E.C Solver
#clean_cpp.awk Revision: 1.2  "../core/Solver.C" Thu Oct 24 17:54:32 BST 2013
<Solver_27>	::=	"int Solver::choosepolarity()\n"
<Solver_28>	::=	"{\n"
<Solver_29>	::=	"if (1)\n"
<Solver_30>	::=	"{\n"
<Solver_31>	::=	"return polarity_false;\n"
<Solver_32>	::=	"}\n"
<Solver_33>	::=	"return polarity_user;\n"
<Solver_34>	::=	"}\n"
<Solver_36>	::=	"char Solver::choosesign(char sign)\n"
<Solver_37>	::=	"{\n"
<Solver_38>	::=	"if (1)\n"
<Solver_39>	::=	"{\n"
<Solver_40>	::=	"return sign;\n"
<Solver_41>	::=	"}\n"
<Solver_42>	::=	"return false;\n"
<Solver_43>	::=	"}\n"
<Solver_45>	::=	"Solver::Solver() :\n"
<Solver_48>	::=	"var_decay(1 / 0.95), clause_decay(1 / 0.999), random_var_freq(0.02)\n"
<Solver_49>	::=	", restart_first(100), restart_inc(1.5), learntsize_factor((double)1/(double)3), learntsize_inc(1.1)\n"
<Solver_53>	::=	", expensive_ccmin (true)\n"
<Solver_54>	::=	", polarity_mode (choosepolarity())\n"
<Solver_56>	::=	", verbosity (0)\n"
<Solver_60>	::=	", starts(0), decisions(0), rnd_decisions(0), propagations(0), conflicts(0)\n"
<Solver_61>	::=	", clauses_literals(0), learnts_literals(0), max_literals(0), tot_literals(0)\n"
<Solver_63>	::=	", ok (true)\n"
<Solver_64>	::=	", cla_inc (1)\n"
<Solver_65>	::=	", var_inc (1)\n"
<Solver_66>	::=	", qhead (0)\n"
<Solver_67>	::=	", simpDB_assigns (-1)\n"
<Solver_68>	::=	", simpDB_props (0)\n"
<Solver_69>	::=	", order_heap (VarOrderLt(activity))\n"
<Solver_70>	::=	", random_seed (91648253)\n"
<Solver_71>	::=	", progress_estimate(0)\n"
<Solver_72>	::=	", remove_satisfied (true)\n"
<Solver_73>	::=	"{}\n"
<Solver_76>	::=	"Solver::~Solver()\n"
<Solver_77>	::=	"{\n"
<Solver_78>	::=	"for (int i = 0; i < learnts.size(); i++)\n"
<Solver_79>	::=	"{\n"
<Solver_80>	::=	"free(learnts[i]);\n"
<Solver_81>	::=	"}\n"
<Solver_82>	::=	"for (int i = 0; i < clauses.size(); i++)\n"
<Solver_83>	::=	"{\n"
<Solver_84>	::=	"free(clauses[i]);\n"
<Solver_85>	::=	"}\n"
<Solver_86>	::=	"}\n"
<Solver_98>	::=	"Var Solver::newVar(bool sign, bool dvar)\n"
<Solver_99>	::=	"{\n"
<Solver_100>	::=	"int v = nVars();\n"
<Solver_101>	::=	"watches .push();\n"
<Solver_102>	::=	"watches .push();\n"
<Solver_103>	::=	"reason .push(__null);\n"
<Solver_104>	::=	"assigns .push(toInt(l_Undef));\n"
<Solver_105>	::=	"level .push(-1);\n"
<Solver_106>	::=	"activity .push(0);\n"
<Solver_107>	::=	"seen .push(0);\n"
<Solver_109>	::=	"polarity .push(choosesign((char)sign));\n"
<Solver_111>	::=	"decision_var.push((char)dvar);\n"
<Solver_113>	::=	"insertVarOrder(v);\n"
<Solver_114>	::=	"return v;\n"
<Solver_115>	::=	"}\n"
<Solver_118>	::=	"bool Solver::addClause(vec<Lit>& ps)\n"
<Solver_119>	::=	"{\n"
<Solver_120>	::=	"((decisionLevel() == 0) ? static_cast<void> (0) : __assert_fail (\"decisionLevel() == 0\", \"../core/Solver.C\", 120, __PRETTY_FUNCTION__));\n"
<Solver_122>	::=	"if (!ok)\n"
<Solver_123>	::=	"{\n"
<Solver_124>	::=	"return false;\n"
<Solver_125>	::=	"}\n"
<Solver_126>	::=	"else\n"
<Solver_127>	::=	"{\n"
<Solver_129>	::=	"sort(ps);\n"
<Solver_130>	::=	"Lit p; int i, j;\n"
<Solver_131>	::=	"for (i = j = 0, p = lit_Undef; i < ps.size(); i++)\n"
<Solver_132>	::=	"{\n"
<Solver_133>	::=	"if (value(ps[i]) == l_True || ps[i] == ~p)\n"
<Solver_134>	::=	"{\n"
<Solver_135>	::=	"return true;\n"
<Solver_136>	::=	"}\n"
<Solver_137>	::=	"else if (value(ps[i]) != l_False && ps[i] != p)\n"
<Solver_138>	::=	"{\n"
<Solver_139>	::=	"ps[j++] = p = ps[i];\n"
<Solver_140>	::=	"}\n"
<Solver_141>	::=	"}\n"
<Solver_142>	::=	"ps.shrink(i - j);\n"
<Solver_143>	::=	"}\n"
<Solver_145>	::=	"if (ps.size() == 0)\n"
<Solver_146>	::=	"{\n"
<Solver_147>	::=	"return ok = false;\n"
<Solver_148>	::=	"}\n"
<Solver_149>	::=	"else if (ps.size() == 1)\n"
<Solver_150>	::=	"{\n"
<Solver_151>	::=	"((value(ps[0]) == l_Undef) ? static_cast<void> (0) : __assert_fail (\"value(ps[0]) == l_Undef\", \"../core/Solver.C\", 151, __PRETTY_FUNCTION__));\n"
<Solver_152>	::=	"uncheckedEnqueue(ps[0]);\n"
<Solver_153>	::=	"return ok = (propagate() == __null);\n"
<Solver_154>	::=	"}\n"
<Solver_155>	::=	"else\n"
<Solver_156>	::=	"{\n"
<Solver_157>	::=	"Clause* c = Clause::Clause_new(ps, false);\n"
<Solver_158>	::=	"clauses.push(c);\n"
<Solver_159>	::=	"attachClause(*c);\n"
<Solver_160>	::=	"}\n"
<Solver_162>	::=	"return true;\n"
<Solver_163>	::=	"}\n"
<Solver_166>	::=	"void Solver::attachClause(Clause& c)\n"
<Solver_167>	::=	"{\n"
<Solver_168>	::=	"((c.size() > 1) ? static_cast<void> (0) : __assert_fail (\"c.size() > 1\", \"../core/Solver.C\", 168, __PRETTY_FUNCTION__));\n"
<Solver_169>	::=	"watches[toInt(~c[0])].push(&c);\n"
<Solver_170>	::=	"watches[toInt(~c[1])].push(&c);\n"
<Solver_171>	::=	"if (c.learnt())\n"
<Solver_172>	::=	"{\n"
<Solver_173>	::=	"learnts_literals += c.size();\n"
<Solver_174>	::=	"}\n"
<Solver_175>	::=	"else\n"
<Solver_176>	::=	"{\n"
<Solver_177>	::=	"clauses_literals += c.size();\n"
<Solver_178>	::=	"}\n"
<Solver_179>	::=	"}\n"
<Solver_182>	::=	"void Solver::detachClause(Clause& c)\n"
<Solver_183>	::=	"{\n"
<Solver_184>	::=	"((c.size() > 1) ? static_cast<void> (0) : __assert_fail (\"c.size() > 1\", \"../core/Solver.C\", 184, __PRETTY_FUNCTION__));\n"
<Solver_185>	::=	"((find(watches[toInt(~c[0])], &c)) ? static_cast<void> (0) : __assert_fail (\"find(watches[toInt(~c[0])], &c)\", \"../core/Solver.C\", 185, __PRETTY_FUNCTION__));\n"
<Solver_186>	::=	"((find(watches[toInt(~c[1])], &c)) ? static_cast<void> (0) : __assert_fail (\"find(watches[toInt(~c[1])], &c)\", \"../core/Solver.C\", 186, __PRETTY_FUNCTION__));\n"
<Solver_187>	::=	"remove(watches[toInt(~c[0])], &c);\n"
<Solver_188>	::=	"remove(watches[toInt(~c[1])], &c);\n"
<Solver_189>	::=	"if (c.learnt())\n"
<Solver_190>	::=	"{\n"
<Solver_191>	::=	"learnts_literals -= c.size();\n"
<Solver_192>	::=	"}\n"
<Solver_193>	::=	"else\n"
<Solver_194>	::=	"{\n"
<Solver_195>	::=	"clauses_literals -= c.size();\n"
<Solver_196>	::=	"}\n"
<Solver_197>	::=	"}\n"
<Solver_200>	::=	"void Solver::removeClause(Clause& c)\n"
<Solver_201>	::=	"{\n"
<Solver_202>	::=	"detachClause(c);\n"
<Solver_203>	::=	"free(&c);\n"
<Solver_204>	::=	"}\n"
<Solver_207>	::=	"bool Solver::satisfied(const Clause& c) const\n"
<Solver_208>	::=	"{\n"
<Solver_209>	::=	"for (int i = 0; i < c.size(); i++)\n"
<Solver_210>	::=	"{\n"
<Solver_211>	::=	"if (value(c[i]) == l_True)\n"
<Solver_212>	::=	"{\n"
<Solver_213>	::=	"return true;\n"
<Solver_214>	::=	"}\n"
<Solver_215>	::=	"}\n"
<Solver_216>	::=	"return false;\n"
<Solver_217>	::=	"}\n"
<Solver_222>	::=	"void Solver::cancelUntil(int level)\n"
<Solver_223>	::=	"{\n"
<Solver_224>	::=	"if (decisionLevel() > level)\n"
<Solver_225>	::=	"{\n"
<Solver_226>	::=	"for (int c = trail.size()-1; c >= trail_lim[level]; c--)\n"
<Solver_227>	::=	"{\n"
<Solver_228>	::=	"Var x = var(trail[c]);\n"
<Solver_229>	::=	"assigns[x] = toInt(l_Undef);\n"
<Solver_230>	::=	"insertVarOrder(x);\n"
<Solver_231>	::=	"}\n"
<Solver_232>	::=	"qhead = trail_lim[level];\n"
<Solver_233>	::=	"trail.shrink(trail.size() - trail_lim[level]);\n"
<Solver_234>	::=	"trail_lim.shrink(trail_lim.size() - level);\n"
<Solver_235>	::=	"}\n"
<Solver_236>	::=	"}\n"
<Solver_243>	::=	"Lit Solver::pickBranchLit(int polarity_mode, double random_var_freq)\n"
<Solver_244>	::=	"{\n"
<Solver_245>	::=	"Var next = (-1);\n"
<Solver_248>	::=	"if (drand(random_seed) < random_var_freq && !order_heap.empty())\n"
<Solver_249>	::=	"{\n"
<Solver_250>	::=	"next = order_heap[irand(random_seed,order_heap.size())];\n"
<Solver_251>	::=	"if (toLbool(assigns[next]) == l_Undef && decision_var[next])\n"
<Solver_252>	::=	"{\n"
<Solver_253>	::=	"rnd_decisions++;\n"
<Solver_254>	::=	"}\n"
<Solver_255>	::=	"}\n"
<Solver_258>	::=	"while (next == (-1) || toLbool(assigns[next]) != l_Undef || !decision_var[next])\n"
<Solver_259>	::=	"{\n"
<Solver_260>	::=	"if (order_heap.empty())\n"
<Solver_261>	::=	"{\n"
<Solver_262>	::=	"next = (-1);\n"
<Solver_263>	::=	"break;\n"
<Solver_264>	::=	"}\n"
<Solver_265>	::=	"else\n"
<Solver_266>	::=	"{\n"
<Solver_267>	::=	"next = order_heap.removeMin();\n"
<Solver_268>	::=	"}\n"
<Solver_269>	::=	"}\n"
<Solver_271>	::=	"bool sign = false;\n"
<Solver_272>	::=	"switch (polarity_mode)\n"
<Solver_273>	::=	"{\n"
<Solver_274>	::=	"case polarity_true: sign = false; break;\n"
<Solver_275>	::=	"case polarity_false: sign = true; break;\n"
<Solver_276>	::=	"case polarity_user: sign = polarity[next]; break;\n"
<Solver_277>	::=	"case polarity_rnd: sign = irand(random_seed, 2); break;\n"
<Solver_278>	::=	"default: ((false) ? static_cast<void> (0) : __assert_fail (\"false\", \"../core/Solver.C\", 278, __PRETTY_FUNCTION__));\n"
<Solver_279>	::=	"}\n"
<Solver_281>	::=	"return next == (-1) ? lit_Undef : Lit(next, sign);\n"
<Solver_282>	::=	"}\n"
<Solver_302>	::=	"void Solver::analyze(Clause* confl, vec<Lit>& out_learnt, int& out_btlevel)\n"
<Solver_303>	::=	"{\n"
<Solver_304>	::=	"int pathC = 0;\n"
<Solver_305>	::=	"Lit p = lit_Undef;\n"
<Solver_309>	::=	"out_learnt.push();\n"
<Solver_310>	::=	"int index = trail.size() - 1;\n"
<Solver_311>	::=	"out_btlevel = 0;\n"
<Solver_313>	::=	"do\n"
<Solver_314>	::=	"{\n"
<Solver_315>	::=	"((confl != __null) ? static_cast<void> (0) : __assert_fail (\"confl != __null\", \"../core/Solver.C\", 315, __PRETTY_FUNCTION__));\n"
<Solver_316>	::=	"Clause& c = *confl;\n"
<Solver_318>	::=	"if (c.learnt())\n"
<Solver_319>	::=	"{\n"
<Solver_320>	::=	"claBumpActivity(c);\n"
<Solver_321>	::=	"}\n"
<Solver_323>	::=	"for (int j = (p == lit_Undef) ? 0 : 1; j < c.size(); j++)\n"
<Solver_324>	::=	"{\n"
<Solver_325>	::=	"Lit q = c[j];\n"
<Solver_327>	::=	"if (!seen[var(q)] && level[var(q)] > 0)\n"
<Solver_328>	::=	"{\n"
<Solver_329>	::=	"varBumpActivity(var(q));\n"
<Solver_330>	::=	"seen[var(q)] = 1;\n"
<Solver_331>	::=	"if (level[var(q)] >= decisionLevel())\n"
<Solver_332>	::=	"{\n"
<Solver_333>	::=	"pathC++;\n"
<Solver_334>	::=	"}\n"
<Solver_335>	::=	"else\n"
<Solver_336>	::=	"{\n"
<Solver_337>	::=	"out_learnt.push(q);\n"
<Solver_338>	::=	"if (level[var(q)] > out_btlevel)\n"
<Solver_339>	::=	"{\n"
<Solver_340>	::=	"out_btlevel = level[var(q)];\n"
<Solver_341>	::=	"}\n"
<Solver_342>	::=	"}\n"
<Solver_343>	::=	"}\n"
<Solver_344>	::=	"}\n"
<Solver_347>	::=	"while (!seen[var(trail[index--])]);\n"
<Solver_348>	::=	"p = trail[index+1];\n"
<Solver_349>	::=	"confl = reason[var(p)];\n"
<Solver_350>	::=	"seen[var(p)] = 0;\n"
<Solver_351>	::=	"pathC--;\n"
<Solver_353>	::=	"}\n"
<Solver_354>	::=	"while (pathC > 0);\n"
<Solver_355>	::=	"out_learnt[0] = ~p;\n"
<Solver_359>	::=	"int i, j;\n"
<Solver_360>	::=	"if (expensive_ccmin)\n"
<Solver_361>	::=	"{\n"
<Solver_362>	::=	"uint64_t abstract_level = 0;\n"
<Solver_363>	::=	"for (i = 1; i < out_learnt.size(); i++)\n"
<Solver_364>	::=	"{\n"
<Solver_365>	::=	"abstract_level |= abstractLevel(var(out_learnt[i]));\n"
<Solver_366>	::=	"}\n"
<Solver_368>	::=	"out_learnt.copyTo(analyze_toclear);\n"
<Solver_370>	::=	"if (1)\n"
<Solver_371>	::=	"{\n"
<Solver_372>	::=	"for (i = j = 1; i < out_learnt.size(); i++)\n"
<Solver_373>	::=	"{\n"
<Solver_374>	::=	"if (reason[var(out_learnt[i])] == __null || !litRedundant(out_learnt[i], abstract_level))\n"
<Solver_375>	::=	"{\n"
<Solver_376>	::=	"out_learnt[j++] = out_learnt[i];\n"
<Solver_377>	::=	"}\n"
<Solver_378>	::=	"}\n"
<Solver_379>	::=	"}\n"
<Solver_380>	::=	"else\n"
<Solver_381>	::=	"{\n"
<Solver_382>	::=	"i = out_learnt.size();\n"
<Solver_383>	::=	"int found_some = find_removable(out_learnt, i, abstract_level);\n"
<Solver_384>	::=	"if (found_some)\n"
<Solver_385>	::=	"{\n"
<Solver_386>	::=	"j = prune_removable(out_learnt);\n"
<Solver_387>	::=	"}\n"
<Solver_388>	::=	"else\n"
<Solver_389>	::=	"{\n"
<Solver_390>	::=	"j = i;\n"
<Solver_391>	::=	"}\n"
<Solver_392>	::=	"}\n"
<Solver_394>	::=	"}\n"
<Solver_395>	::=	"else\n"
<Solver_396>	::=	"{\n"
<Solver_397>	::=	"out_learnt.copyTo(analyze_toclear);\n"
<Solver_398>	::=	"for (i = j = 1; i < out_learnt.size(); i++)\n"
<Solver_399>	::=	"{\n"
<Solver_400>	::=	"if (0)\n"
<Solver_401>	::=	"{\n"
<Solver_402>	::=	"if (reason[var(out_learnt[i])] == __null)\n"
<Solver_403>	::=	"{\n"
<Solver_404>	::=	"out_learnt[j++] = out_learnt[i];\n"
<Solver_405>	::=	"continue;\n"
<Solver_406>	::=	"}\n"
<Solver_407>	::=	"}\n"
<Solver_408>	::=	"Clause& c = *reason[var(out_learnt[i])];\n"
<Solver_409>	::=	"for (int k = 1; k < c.size(); k++)\n"
<Solver_410>	::=	"{\n"
<Solver_411>	::=	"if (!seen[var(c[k])] && level[var(c[k])] > 0)\n"
<Solver_412>	::=	"{\n"
<Solver_413>	::=	"out_learnt[j++] = out_learnt[i];\n"
<Solver_414>	::=	"break;\n"
<Solver_415>	::=	"}\n"
<Solver_416>	::=	"}\n"
<Solver_417>	::=	"}\n"
<Solver_418>	::=	"}\n"
<Solver_419>	::=	"max_literals += out_learnt.size();\n"
<Solver_420>	::=	"if (1)\n"
<Solver_421>	::=	"{\n"
<Solver_422>	::=	"out_learnt.shrink(i - j);\n"
<Solver_423>	::=	"}\n"
<Solver_424>	::=	"else\n"
<Solver_425>	::=	"{\n"
<Solver_426>	::=	"out_learnt.shrink(out_learnt.size() - j);\n"
<Solver_427>	::=	"}\n"
<Solver_428>	::=	"tot_literals += out_learnt.size();\n"
<Solver_432>	::=	"if (out_learnt.size() == 1)\n"
<Solver_433>	::=	"{\n"
<Solver_434>	::=	"out_btlevel = 0;\n"
<Solver_435>	::=	"}\n"
<Solver_436>	::=	"else\n"
<Solver_437>	::=	"{\n"
<Solver_438>	::=	"int max_i = 1;\n"
<Solver_439>	::=	"for (int i = 2; i < out_learnt.size(); i++)\n"
<Solver_440>	::=	"{\n"
<Solver_441>	::=	"if (level[var(out_learnt[i])] > level[var(out_learnt[max_i])])\n"
<Solver_442>	::=	"{\n"
<Solver_443>	::=	"max_i = i;\n"
<Solver_444>	::=	"}\n"
<Solver_445>	::=	"}\n"
<Solver_446>	::=	"Lit p = out_learnt[max_i];\n"
<Solver_447>	::=	"out_learnt[max_i] = out_learnt[1];\n"
<Solver_448>	::=	"out_learnt[1] = p;\n"
<Solver_449>	::=	"out_btlevel = level[var(p)];\n"
<Solver_450>	::=	"}\n"
<Solver_453>	::=	"for (int j = 0; j < analyze_toclear.size(); j++)\n"
<Solver_454>	::=	"{\n"
<Solver_455>	::=	"seen[var(analyze_toclear[j])] = 0;\n"
<Solver_456>	::=	"}\n"
<Solver_457>	::=	"}\n"
<Solver_462>	::=	"bool Solver::litRedundant(Lit p, uint64_t abstract_levels)\n"
<Solver_463>	::=	"{\n"
<Solver_464>	::=	"analyze_stack.clear(); analyze_stack.push(p);\n"
<Solver_465>	::=	"int top = analyze_toclear.size();\n"
<Solver_466>	::=	"while (analyze_stack.size() > 0)\n"
<Solver_467>	::=	"{\n"
<Solver_468>	::=	"((reason[var(analyze_stack.last())] != __null) ? static_cast<void> (0) : __assert_fail (\"reason[var(analyze_stack.last())] != __null\", \"../core/Solver.C\", 468, __PRETTY_FUNCTION__));\n"
<Solver_469>	::=	"Clause& c = *reason[var(analyze_stack.last())]; analyze_stack.pop();\n"
<Solver_471>	::=	"for (int i = 1; i < c.size(); i++)\n"
<Solver_472>	::=	"{\n"
<Solver_473>	::=	"Lit p = c[i];\n"
<Solver_474>	::=	"if (!seen[var(p)] && level[var(p)] > 0)\n"
<Solver_475>	::=	"{\n"
<Solver_476>	::=	"if (reason[var(p)] != __null && (abstractLevel(var(p)) & abstract_levels) != 0)\n"
<Solver_477>	::=	"{\n"
<Solver_478>	::=	"seen[var(p)] = 1;\n"
<Solver_479>	::=	"analyze_stack.push(p);\n"
<Solver_480>	::=	"analyze_toclear.push(p);\n"
<Solver_481>	::=	"}\n"
<Solver_482>	::=	"else\n"
<Solver_483>	::=	"{\n"
<Solver_484>	::=	"for (int j = top; j < analyze_toclear.size(); j++)\n"
<Solver_485>	::=	"{\n"
<Solver_486>	::=	"seen[var(analyze_toclear[j])] = 0;\n"
<Solver_487>	::=	"}\n"
<Solver_488>	::=	"analyze_toclear.shrink(analyze_toclear.size() - top);\n"
<Solver_489>	::=	"return false;\n"
<Solver_490>	::=	"}\n"
<Solver_491>	::=	"}\n"
<Solver_492>	::=	"}\n"
<Solver_493>	::=	"}\n"
<Solver_495>	::=	"return true;\n"
<Solver_496>	::=	"}\n"
<Solver_508>	::=	"void Solver::analyzeFinal(Lit p, vec<Lit>& out_conflict)\n"
<Solver_509>	::=	"{\n"
<Solver_510>	::=	"out_conflict.clear();\n"
<Solver_511>	::=	"out_conflict.push(p);\n"
<Solver_513>	::=	"if (decisionLevel() == 0)\n"
<Solver_514>	::=	"{\n"
<Solver_515>	::=	"return;\n"
<Solver_516>	::=	"}\n"
<Solver_518>	::=	"seen[var(p)] = 1;\n"
<Solver_520>	::=	"for (int i = trail.size()-1; i >= trail_lim[0]; i--)\n"
<Solver_521>	::=	"{\n"
<Solver_522>	::=	"Var x = var(trail[i]);\n"
<Solver_523>	::=	"if (seen[x])\n"
<Solver_524>	::=	"{\n"
<Solver_525>	::=	"if (reason[x] == __null)\n"
<Solver_526>	::=	"{\n"
<Solver_527>	::=	"((level[x] > 0) ? static_cast<void> (0) : __assert_fail (\"level[x] > 0\", \"../core/Solver.C\", 527, __PRETTY_FUNCTION__));\n"
<Solver_528>	::=	"out_conflict.push(~trail[i]);\n"
<Solver_529>	::=	"}\n"
<Solver_530>	::=	"else\n"
<Solver_531>	::=	"{\n"
<Solver_532>	::=	"Clause& c = *reason[x];\n"
<Solver_533>	::=	"for (int j = 1; j < c.size(); j++)\n"
<Solver_534>	::=	"{\n"
<Solver_535>	::=	"if (level[var(c[j])] > 0)\n"
<Solver_536>	::=	"{\n"
<Solver_537>	::=	"seen[var(c[j])] = 1;\n"
<Solver_538>	::=	"}\n"
<Solver_539>	::=	"}\n"
<Solver_540>	::=	"}\n"
<Solver_541>	::=	"seen[x] = 0;\n"
<Solver_542>	::=	"}\n"
<Solver_543>	::=	"}\n"
<Solver_545>	::=	"seen[var(p)] = 0;\n"
<Solver_546>	::=	"}\n"
<Solver_549>	::=	"void Solver::uncheckedEnqueue(Lit p, Clause* from)\n"
<Solver_550>	::=	"{\n"
<Solver_551>	::=	"((value(p) == l_Undef) ? static_cast<void> (0) : __assert_fail (\"value(p) == l_Undef\", \"../core/Solver.C\", 551, __PRETTY_FUNCTION__));\n"
<Solver_552>	::=	"assigns [var(p)] = toInt(lbool(!sign(p)));\n"
<Solver_553>	::=	"level [var(p)] = decisionLevel();\n"
<Solver_554>	::=	"reason [var(p)] = from;\n"
<Solver_555>	::=	"if (0)\n"
<Solver_556>	::=	"{\n"
<Solver_557>	::=	"polarity[var(p)] = sign(p);\n"
<Solver_558>	::=	"}\n"
<Solver_559>	::=	"trail.push(p);\n"
<Solver_560>	::=	"}\n"
<Solver_574>	::=	"Clause* Solver::propagate()\n"
<Solver_575>	::=	"{\n"
<Solver_576>	::=	"Clause* confl = __null;\n"
<Solver_577>	::=	"int num_props = 0;\n"
<Solver_579>	::=	"while (qhead < trail.size())\n"
<Solver_580>	::=	"{\n"
<Solver_581>	::=	"Lit p = trail[qhead++];\n"
<Solver_582>	::=	"vec<Clause*>& ws = watches[toInt(p)];\n"
<Solver_583>	::=	"Clause **i, **j, **end;\n"
<Solver_584>	::=	"num_props++;\n"
<Solver_586>	::=	"for (i = j = (Clause**)ws, end = i + ws.size(); i != end;)\n"
<Solver_587>	::=	"{\n"
<Solver_588>	::=	"Clause& c = **i++;\n"
<Solver_591>	::=	"Lit false_lit = ~p;\n"
<Solver_592>	::=	"if (c[0] == false_lit)\n"
<Solver_593>	::=	"{\n"
<Solver_594>	::=	"c[0] = c[1], c[1] = false_lit;\n"
<Solver_595>	::=	"}\n"
<Solver_597>	::=	"((c[1] == false_lit) ? static_cast<void> (0) : __assert_fail (\"c[1] == false_lit\", \"../core/Solver.C\", 597, __PRETTY_FUNCTION__));\n"
<Solver_600>	::=	"Lit first = c[0];\n"
<Solver_601>	::=	"if (value(first) == l_True)\n"
<Solver_602>	::=	"{\n"
<Solver_603>	::=	"*j++ = &c;\n"
<Solver_604>	::=	"}\n"
<Solver_605>	::=	"else\n"
<Solver_606>	::=	"{\n"
<Solver_608>	::=	"for (int k = 2; k < c.size(); k++)\n"
<Solver_609>	::=	"{\n"
<Solver_610>	::=	"if (value(c[k]) != l_False)\n"
<Solver_611>	::=	"{\n"
<Solver_612>	::=	"c[1] = c[k]; c[k] = false_lit;\n"
<Solver_613>	::=	"watches[toInt(~c[1])].push(&c);\n"
<Solver_614>	::=	"goto FoundWatch;\n"
<Solver_615>	::=	"}\n"
<Solver_616>	::=	"}\n"
<Solver_619>	::=	"*j++ = &c;\n"
<Solver_620>	::=	"if (value(first) == l_False)\n"
<Solver_621>	::=	"{\n"
<Solver_622>	::=	"confl = &c;\n"
<Solver_623>	::=	"qhead = trail.size();\n"
<Solver_625>	::=	"while (i < end)\n"
<Solver_626>	::=	"{\n"
<Solver_627>	::=	"*j++ = *i++;\n"
<Solver_628>	::=	"}\n"
<Solver_629>	::=	"}\n"
<Solver_630>	::=	"else\n"
<Solver_631>	::=	"{\n"
<Solver_632>	::=	"uncheckedEnqueue(first, &c);\n"
<Solver_633>	::=	"}\n"
<Solver_634>	::=	"}\n"
<Solver_635>	::=	"FoundWatch:;\n"
<Solver_636>	::=	"}\n"
<Solver_637>	::=	"ws.shrink(i - j);\n"
<Solver_638>	::=	"}\n"
<Solver_639>	::=	"propagations += num_props;\n"
<Solver_640>	::=	"simpDB_props -= num_props;\n"
<Solver_642>	::=	"return confl;\n"
<Solver_643>	::=	"}\n"
<Solver_653>	::=	"struct reduceDB_lt { bool operator () (Clause* x, Clause* y) { return x->size() > 2 && (y->size() == 2 || x->activity() < y->activity()); } };\n"
<Solver_654>	::=	"void Solver::reduceDB()\n"
<Solver_655>	::=	"{\n"
<Solver_656>	::=	"int i, j;\n"
<Solver_657>	::=	"double extra_lim = cla_inc / learnts.size();\n"
<Solver_659>	::=	"sort(learnts, reduceDB_lt());\n"
<Solver_660>	::=	"for (i = j = 0; i < learnts.size() / 2; i++)\n"
<Solver_661>	::=	"{\n"
<Solver_662>	::=	"if (learnts[i]->size() > 2 && !locked(*learnts[i]))\n"
<Solver_663>	::=	"{\n"
<Solver_664>	::=	"removeClause(*learnts[i]);\n"
<Solver_665>	::=	"}\n"
<Solver_666>	::=	"else\n"
<Solver_667>	::=	"{\n"
<Solver_668>	::=	"learnts[j++] = learnts[i];\n"
<Solver_669>	::=	"}\n"
<Solver_670>	::=	"}\n"
<Solver_671>	::=	"for (; i < learnts.size(); i++)\n"
<Solver_672>	::=	"{\n"
<Solver_673>	::=	"if (learnts[i]->size() > 2 && !locked(*learnts[i]) && learnts[i]->activity() < extra_lim)\n"
<Solver_674>	::=	"{\n"
<Solver_675>	::=	"removeClause(*learnts[i]);\n"
<Solver_676>	::=	"}\n"
<Solver_677>	::=	"else\n"
<Solver_678>	::=	"{\n"
<Solver_679>	::=	"learnts[j++] = learnts[i];\n"
<Solver_680>	::=	"}\n"
<Solver_681>	::=	"}\n"
<Solver_682>	::=	"learnts.shrink(i - j);\n"
<Solver_683>	::=	"if (0)\n"
<Solver_684>	::=	"{\n"
<Solver_685>	::=	"nof_learnts *= learntsize_inc;\n"
<Solver_686>	::=	"}\n"
<Solver_687>	::=	"}\n"
<Solver_690>	::=	"void Solver::removeSatisfied(vec<Clause*>& cs)\n"
<Solver_691>	::=	"{\n"
<Solver_692>	::=	"int i,j;\n"
<Solver_693>	::=	"for (i = j = 0; i < cs.size(); i++)\n"
<Solver_694>	::=	"{\n"
<Solver_695>	::=	"if (satisfied(*cs[i]))\n"
<Solver_696>	::=	"{\n"
<Solver_697>	::=	"removeClause(*cs[i]);\n"
<Solver_698>	::=	"}\n"
<Solver_699>	::=	"else\n"
<Solver_700>	::=	"{\n"
<Solver_701>	::=	"cs[j++] = cs[i];\n"
<Solver_702>	::=	"}\n"
<Solver_703>	::=	"}\n"
<Solver_704>	::=	"cs.shrink(i - j);\n"
<Solver_705>	::=	"}\n"
<Solver_716>	::=	"bool Solver::simplify()\n"
<Solver_717>	::=	"{\n"
<Solver_718>	::=	"((decisionLevel() == 0) ? static_cast<void> (0) : __assert_fail (\"decisionLevel() == 0\", \"../core/Solver.C\", 718, __PRETTY_FUNCTION__));\n"
<Solver_720>	::=	"if (!ok || propagate() != __null)\n"
<Solver_721>	::=	"{\n"
<Solver_722>	::=	"return ok = false;\n"
<Solver_723>	::=	"}\n"
<Solver_725>	::=	"if (nAssigns() == simpDB_assigns || (simpDB_props > 0))\n"
<Solver_726>	::=	"{\n"
<Solver_727>	::=	"return true;\n"
<Solver_728>	::=	"}\n"
<Solver_731>	::=	"removeSatisfied(learnts);\n"
<Solver_732>	::=	"if (remove_satisfied)\n"
<Solver_733>	::=	"{\n"
<Solver_734>	::=	"removeSatisfied(clauses);\n"
<Solver_735>	::=	"}\n"
<Solver_738>	::=	"order_heap.filter(VarFilter(*this));\n"
<Solver_740>	::=	"simpDB_assigns = nAssigns();\n"
<Solver_741>	::=	"simpDB_props = clauses_literals + learnts_literals;\n"
<Solver_743>	::=	"return true;\n"
<Solver_744>	::=	"}\n"
<Solver_761>	::=	"lbool Solver::search(int nof_conflicts, int nof_learnts)\n"
<Solver_762>	::=	"{\n"
<Solver_763>	::=	"((ok) ? static_cast<void> (0) : __assert_fail (\"ok\", \"../core/Solver.C\", 763, __PRETTY_FUNCTION__));\n"
<Solver_764>	::=	"int backtrack_level;\n"
<Solver_765>	::=	"int conflictC = 0;\n"
<Solver_766>	::=	"vec<Lit> learnt_clause;\n"
<Solver_768>	::=	"starts++;\n"
<Solver_770>	::=	"bool first = true;\n"
<Solver_772>	::=	"for (;;)\n"
<Solver_773>	::=	"{\n"
<Solver_774>	::=	"Clause* confl = propagate();\n"
<Solver_775>	::=	"if (confl != __null)\n"
<Solver_776>	::=	"{\n"
<Solver_778>	::=	"conflicts++; conflictC++;\n"
<Solver_779>	::=	"if (decisionLevel() == 0) return l_False;\n"
<Solver_781>	::=	"first = false;\n"
<Solver_783>	::=	"learnt_clause.clear();\n"
<Solver_784>	::=	"analyze(confl, learnt_clause, backtrack_level);\n"
<Solver_785>	::=	"cancelUntil(backtrack_level);\n"
<Solver_786>	::=	"((value(learnt_clause[0]) == l_Undef) ? static_cast<void> (0) : __assert_fail (\"value(learnt_clause[0]) == l_Undef\", \"../core/Solver.C\", 786, __PRETTY_FUNCTION__));\n"
<Solver_788>	::=	"if (0)\n"
<Solver_789>	::=	"{\n"
<Solver_790>	::=	"backtrackLevels[conflicts % restartMore]= backtrack_level;\n"
<Solver_791>	::=	"}\n"
<Solver_793>	::=	"if (learnt_clause.size() == 1)\n"
<Solver_794>	::=	"{\n"
<Solver_795>	::=	"uncheckedEnqueue(learnt_clause[0]);\n"
<Solver_796>	::=	"}\n"
<Solver_797>	::=	"else\n"
<Solver_798>	::=	"{\n"
<Solver_799>	::=	"Clause* c = Clause::Clause_new(learnt_clause, true);\n"
<Solver_800>	::=	"learnts.push(c);\n"
<Solver_801>	::=	"attachClause(*c);\n"
<Solver_802>	::=	"claBumpActivity(*c);\n"
<Solver_803>	::=	"uncheckedEnqueue(learnt_clause[0], c);\n"
<Solver_804>	::=	"}\n"
<Solver_806>	::=	"varDecayActivity();\n"
<Solver_807>	::=	"claDecayActivity();\n"
<Solver_809>	::=	"}\n"
<Solver_810>	::=	"else\n"
<Solver_811>	::=	"{\n"
<Solver_814>	::=	"if (0)\n"
<Solver_815>	::=	"{\n"
<Solver_816>	::=	"if (conflictC >= restartMore)\n"
<Solver_817>	::=	"{\n"
<Solver_818>	::=	"int LM= backtrackLevels[0];\n"
<Solver_819>	::=	"int nofLM= 1;\n"
<Solver_821>	::=	"for(int i=1; i< restartMore; i++)\n"
<Solver_822>	::=	"{\n"
<Solver_823>	::=	"if(backtrackLevels[i]< LM)\n"
<Solver_824>	::=	"{\n"
<Solver_825>	::=	"LM= backtrackLevels[i];\n"
<Solver_826>	::=	"nofLM= 1;\n"
<Solver_827>	::=	"}\n"
<Solver_828>	::=	"else if(backtrackLevels[i]== LM)\n"
<Solver_829>	::=	"{\n"
<Solver_830>	::=	"nofLM++;\n"
<Solver_831>	::=	"}\n"
<Solver_832>	::=	"}\n"
<Solver_834>	::=	"if(LM > restartTolerance && nofLM>= restartLess)\n"
<Solver_835>	::=	"{\n"
<Solver_836>	::=	"progress_estimate= progressEstimate();\n"
<Solver_837>	::=	"cancelUntil(0);\n"
<Solver_838>	::=	"return l_Undef;\n"
<Solver_839>	::=	"}\n"
<Solver_840>	::=	"}\n"
<Solver_841>	::=	"}\n"
<Solver_843>	::=	"if (1)\n"
<Solver_844>	::=	"{\n"
<Solver_845>	::=	"if (nof_conflicts >= 0 && conflictC >= nof_conflicts)\n"
<Solver_846>	::=	"{\n"
<Solver_848>	::=	"progress_estimate = progressEstimate();\n"
<Solver_849>	::=	"cancelUntil(0);\n"
<Solver_850>	::=	"return l_Undef;\n"
<Solver_851>	::=	"}\n"
<Solver_852>	::=	"}\n"
<Solver_855>	::=	"if (decisionLevel() == 0 && !simplify())\n"
<Solver_856>	::=	"{\n"
<Solver_857>	::=	"return l_False;\n"
<Solver_858>	::=	"}\n"
<Solver_860>	::=	"if (nof_learnts >= 0 && learnts.size()-nAssigns() >= nof_learnts)\n"
<Solver_861>	::=	"{\n"
<Solver_863>	::=	"reduceDB();\n"
<Solver_864>	::=	"}\n"
<Solver_866>	::=	"Lit next = lit_Undef;\n"
<Solver_867>	::=	"while (decisionLevel() < assumptions.size())\n"
<Solver_868>	::=	"{\n"
<Solver_870>	::=	"Lit p = assumptions[decisionLevel()];\n"
<Solver_871>	::=	"if (value(p) == l_True)\n"
<Solver_872>	::=	"{\n"
<Solver_874>	::=	"newDecisionLevel();\n"
<Solver_875>	::=	"}\n"
<Solver_876>	::=	"else if (value(p) == l_False)\n"
<Solver_877>	::=	"{\n"
<Solver_878>	::=	"analyzeFinal(~p, conflict);\n"
<Solver_879>	::=	"return l_False;\n"
<Solver_880>	::=	"}\n"
<Solver_881>	::=	"else\n"
<Solver_882>	::=	"{\n"
<Solver_883>	::=	"next = p;\n"
<Solver_884>	::=	"break;\n"
<Solver_885>	::=	"}\n"
<Solver_886>	::=	"}\n"
<Solver_888>	::=	"if (next == lit_Undef)\n"
<Solver_889>	::=	"{\n"
<Solver_891>	::=	"decisions++;\n"
<Solver_892>	::=	"next = pickBranchLit(polarity_mode, random_var_freq);\n"
<Solver_894>	::=	"if (next == lit_Undef)\n"
<Solver_895>	::=	"{\n"
<Solver_897>	::=	"return l_True;\n"
<Solver_898>	::=	"}\n"
<Solver_899>	::=	"}\n"
<Solver_902>	::=	"((value(next) == l_Undef) ? static_cast<void> (0) : __assert_fail (\"value(next) == l_Undef\", \"../core/Solver.C\", 902, __PRETTY_FUNCTION__));\n"
<Solver_903>	::=	"newDecisionLevel();\n"
<Solver_904>	::=	"uncheckedEnqueue(next);\n"
<Solver_905>	::=	"}\n"
<Solver_906>	::=	"}\n"
<Solver_907>	::=	"}\n"
<Solver_910>	::=	"double Solver::progressEstimate() const\n"
<Solver_911>	::=	"{\n"
<Solver_912>	::=	"double progress = 0;\n"
<Solver_913>	::=	"double F = 1.0 / nVars();\n"
<Solver_915>	::=	"for (int i = 0; i <= decisionLevel(); i++)\n"
<Solver_916>	::=	"{\n"
<Solver_917>	::=	"int beg = i == 0 ? 0 : trail_lim[i - 1];\n"
<Solver_918>	::=	"int end = i == decisionLevel() ? trail.size() : trail_lim[i];\n"
<Solver_919>	::=	"progress += pow(F, i) * (end - beg);\n"
<Solver_920>	::=	"}\n"
<Solver_922>	::=	"return progress / nVars();\n"
<Solver_923>	::=	"}\n"
<Solver_926>	::=	"bool Solver::solve(const vec<Lit>& assumps)\n"
<Solver_927>	::=	"{\n"
<Solver_928>	::=	"model.clear();\n"
<Solver_929>	::=	"conflict.clear();\n"
<Solver_931>	::=	"if (!ok)\n"
<Solver_932>	::=	"{\n"
<Solver_933>	::=	"return false;\n"
<Solver_934>	::=	"}\n"
<Solver_936>	::=	"assumps.copyTo(assumptions);\n"
<Solver_939>	::=	"double nof_conflicts = restart_first;\n"
<Solver_940>	::=	"double nof_learnts = nClauses() * learntsize_factor;\n"
<Solver_941>	::=	"if (0)\n"
<Solver_942>	::=	"{\n"
<Solver_943>	::=	"double cvr= (double)nClauses() / (double)nVars();\n"
<Solver_944>	::=	"nof_learnts= 300000 / cvr;\n"
<Solver_945>	::=	"}\n"
<Solver_946>	::=	"restartLess= 5;\n"
<Solver_947>	::=	"restartMore= 42;\n"
<Solver_948>	::=	"restartTolerance= nVars() / 10000 +10;\n"
<Solver_949>	::=	"backtrackLevels= new int[restartMore];\n"
<Solver_951>	::=	"lbool status = l_Undef;\n"
<Solver_961>	::=	"while (status == l_Undef)\n"
<Solver_962>	::=	"{\n"
<Solver_965>	::=	"status = search((int)nof_conflicts, (int)nof_learnts);\n"
<Solver_966>	::=	"nof_conflicts *= restart_inc;\n"
<Solver_967>	::=	"nof_learnts *= learntsize_inc;\n"
<Solver_968>	::=	"}\n"
<Solver_974>	::=	"if (status == l_True)\n"
<Solver_975>	::=	"{\n"
<Solver_977>	::=	"model.growTo(nVars());\n"
<Solver_978>	::=	"for (int i = 0; i < nVars(); i++)\n"
<Solver_979>	::=	"{\n"
<Solver_980>	::=	"model[i] = value(i);\n"
<Solver_981>	::=	"}\n"
<Solver_983>	::=	"verifyModel();\n"
<Solver_985>	::=	"}\n"
<Solver_986>	::=	"else\n"
<Solver_987>	::=	"{\n"
<Solver_988>	::=	"((status == l_False) ? static_cast<void> (0) : __assert_fail (\"status == l_False\", \"../core/Solver.C\", 988, __PRETTY_FUNCTION__));\n"
<Solver_989>	::=	"if (conflict.size() == 0)\n"
<Solver_990>	::=	"{\n"
<Solver_991>	::=	"ok = false;\n"
<Solver_992>	::=	"}\n"
<Solver_993>	::=	"}\n"
<Solver_995>	::=	"cancelUntil(0);\n"
<Solver_996>	::=	"return status == l_True;\n"
<Solver_997>	::=	"}\n"
<Solver_1003>	::=	"void Solver::verifyModel()\n"
<Solver_1004>	::=	"{\n"
<Solver_1005>	::=	"bool failed = false;\n"
<Solver_1006>	::=	"for (int i = 0; i < clauses.size(); i++)\n"
<Solver_1007>	::=	"{\n"
<Solver_1008>	::=	"((clauses[i]->mark() == 0) ? static_cast<void> (0) : __assert_fail (\"clauses[i]->mark() == 0\", \"../core/Solver.C\", 1008, __PRETTY_FUNCTION__));\n"
<Solver_1009>	::=	"Clause& c = *clauses[i];\n"
<Solver_1010>	::=	"for (int j = 0; j < c.size(); j++)\n"
<Solver_1011>	::=	"{\n"
<Solver_1012>	::=	"if (modelValue(c[j]) == l_True)\n"
<Solver_1013>	::=	"{\n"
<Solver_1014>	::=	"goto next;\n"
<Solver_1015>	::=	"}\n"
<Solver_1016>	::=	"}\n"
<Solver_1021>	::=	"failed = true;\n"
<Solver_1022>	::=	"next:;\n"
<Solver_1023>	::=	"}\n"
<Solver_1025>	::=	"((!failed) ? static_cast<void> (0) : __assert_fail (\"!failed\", \"../core/Solver.C\", 1025, __PRETTY_FUNCTION__));\n"
<Solver_1028>	::=	"}\n"
<Solver_1031>	::=	"void Solver::checkLiteralCount()\n"
<Solver_1032>	::=	"{\n"
<Solver_1034>	::=	"int cnt = 0;\n"
<Solver_1035>	::=	"for (int i = 0; i < clauses.size(); i++)\n"
<Solver_1036>	::=	"{\n"
<Solver_1037>	::=	"if (clauses[i]->mark() == 0)\n"
<Solver_1038>	::=	"{\n"
<Solver_1039>	::=	"cnt += clauses[i]->size();\n"
<Solver_1040>	::=	"}\n"
<Solver_1041>	::=	"}\n"
<Solver_1043>	::=	"if ((int)clauses_literals != cnt)\n"
<Solver_1044>	::=	"{\n"
<Solver_1046>	::=	"(((int)clauses_literals == cnt) ? static_cast<void> (0) : __assert_fail (\"(int)clauses_literals == cnt\", \"../core/Solver.C\", 1046, __PRETTY_FUNCTION__));\n"
<Solver_1047>	::=	"}\n"
<Solver_1048>	::=	"}\n"
<Solver_1052>	::=	"int Solver::prune_removable(vec<Lit>& out_learnt)\n"
<Solver_1053>	::=	"{\n"
<Solver_1054>	::=	"int i, j, sz = out_learnt.size();\n"
<Solver_1055>	::=	"j = 1;\n"
<Solver_1056>	::=	"for (i = 1; i < sz; i++)\n"
<Solver_1057>	::=	"{\n"
<Solver_1058>	::=	"if ((seen[var(out_learnt[i])] & (1|2)) == (1|2))\n"
<Solver_1059>	::=	"{\n"
<Solver_1060>	::=	"(((seen[var(out_learnt[i])] & (4|8)) == 0) ? static_cast<void> (0) : __assert_fail (\"(seen[var(out_learnt[i])] & (4|8)) == 0\", \"../core/Solver.C\", 1060, __PRETTY_FUNCTION__));\n"
<Solver_1061>	::=	"out_learnt[j++] = out_learnt[i];\n"
<Solver_1062>	::=	"}\n"
<Solver_1063>	::=	"}\n"
<Solver_1064>	::=	"return j;\n"
<Solver_1065>	::=	"}\n"
<Solver_1067>	::=	"int Solver::find_removable(vec<Lit>& out_learnt, uint32_t sz0, uint32_t abstract_level)\n"
<Solver_1068>	::=	"{\n"
<Solver_1069>	::=	"int found_some;\n"
<Solver_1070>	::=	"found_some = 0;\n"
<Solver_1071>	::=	"int sz = out_learnt.size();\n"
<Solver_1072>	::=	"int i;\n"
<Solver_1079>	::=	"for (i = 1; i < sz; i++)\n"
<Solver_1080>	::=	"{\n"
<Solver_1081>	::=	"Lit curLit = out_learnt[i];\n"
<Solver_1082>	::=	"if (level[var(curLit)] <= 0)\n"
<Solver_1083>	::=	"{\n"
<Solver_1084>	::=	"continue;\n"
<Solver_1085>	::=	"}\n"
<Solver_1087>	::=	"if ((seen[var(curLit)] & (2|4|8)) == 0)\n"
<Solver_1088>	::=	"{\n"
<Solver_1089>	::=	"found_some |= dfs_removable(curLit, abstract_level);\n"
<Solver_1090>	::=	"}\n"
<Solver_1091>	::=	"}\n"
<Solver_1092>	::=	"return found_some;\n"
<Solver_1093>	::=	"}\n"
<Solver_1095>	::=	"int Solver::quick_keeper(Lit p, uint64_t abstract_level, int maykeep)\n"
<Solver_1096>	::=	"{\n"
<Solver_1099>	::=	"if (reason[var(p)] == __null)\n"
<Solver_1100>	::=	"{\n"
<Solver_1101>	::=	"return (maykeep ? 2 : 8);\n"
<Solver_1102>	::=	"}\n"
<Solver_1103>	::=	"else if ((abstractLevel(var(p)) & abstract_level) == 0)\n"
<Solver_1104>	::=	"{\n"
<Solver_1105>	::=	"((maykeep == 0) ? static_cast<void> (0) : __assert_fail (\"maykeep == 0\", \"../core/Solver.C\", 1105, __PRETTY_FUNCTION__));\n"
<Solver_1106>	::=	"return 8;\n"
<Solver_1107>	::=	"}\n"
<Solver_1108>	::=	"else\n"
<Solver_1109>	::=	"{\n"
<Solver_1110>	::=	"return 0;\n"
<Solver_1111>	::=	"}\n"
<Solver_1112>	::=	"}\n"
<Solver_1114>	::=	"int Solver::dfs_removable(Lit p, uint32_t abstract_level)\n"
<Solver_1115>	::=	"{\n"
<Solver_1116>	::=	"int pseen = seen[var(p)];\n"
<Solver_1117>	::=	"(((pseen & (2|4|8)) == 0) ? static_cast<void> (0) : __assert_fail (\"(pseen & (2|4|8)) == 0\", \"../core/Solver.C\", 1117, __PRETTY_FUNCTION__));\n"
<Solver_1118>	::=	"int maykeep = pseen & (1);\n"
<Solver_1119>	::=	"int pstatus;\n"
<Solver_1120>	::=	"pstatus = quick_keeper(p, abstract_level, maykeep);\n"
<Solver_1121>	::=	"if (pstatus)\n"
<Solver_1122>	::=	"{\n"
<Solver_1123>	::=	"seen[var(p)] |= (char) pstatus;\n"
<Solver_1124>	::=	"if (pseen == 0)\n"
<Solver_1125>	::=	"{\n"
<Solver_1126>	::=	"analyze_toclear.push(p);\n"
<Solver_1127>	::=	"}\n"
<Solver_1128>	::=	"return 0;\n"
<Solver_1129>	::=	"}\n"
<Solver_1131>	::=	"int found_some;\n"
<Solver_1132>	::=	"found_some = 0;\n"
<Solver_1133>	::=	"pstatus = 4;\n"
<Solver_1134>	::=	"Clause& rp = *reason[var(p)];\n"
<Solver_1135>	::=	"int sz = rp.size();\n"
<Solver_1136>	::=	"int i;\n"
<Solver_1138>	::=	"for (i = 1; i < sz; i++)\n"
<Solver_1139>	::=	"{\n"
<Solver_1140>	::=	"Lit q = rp[i];\n"
<Solver_1141>	::=	"if (level[var(q)] <= 0)\n"
<Solver_1142>	::=	"{\n"
<Solver_1143>	::=	"continue;\n"
<Solver_1144>	::=	"}\n"
<Solver_1146>	::=	"if ((seen[var(q)] & (2|4|8)) == 0)\n"
<Solver_1147>	::=	"{\n"
<Solver_1148>	::=	"found_some |= dfs_removable(q, abstract_level);\n"
<Solver_1149>	::=	"}\n"
<Solver_1150>	::=	"int qseen = seen[var(q)];\n"
<Solver_1151>	::=	"if (qseen & (8))\n"
<Solver_1152>	::=	"{\n"
<Solver_1153>	::=	"pstatus = (maykeep ? 2 : 8);\n"
<Solver_1154>	::=	"break;\n"
<Solver_1155>	::=	"}\n"
<Solver_1156>	::=	"(((qseen & (2|4))) ? static_cast<void> (0) : __assert_fail (\"(qseen & (2|4))\", \"../core/Solver.C\", 1156, __PRETTY_FUNCTION__));\n"
<Solver_1157>	::=	"}\n"
<Solver_1158>	::=	"seen[var(p)] |= (char) pstatus;\n"
<Solver_1159>	::=	"if (pseen == 0)\n"
<Solver_1160>	::=	"{\n"
<Solver_1161>	::=	"analyze_toclear.push(p);\n"
<Solver_1162>	::=	"}\n"
<Solver_1163>	::=	"found_some |= maykeep;\n"
<Solver_1164>	::=	"return found_some;\n"
<Solver_1165>	::=	"}\n"
<Solver_1167>	::=	"void Solver::mark_needed_removable(Lit p)\n"
<Solver_1168>	::=	"{\n"
<Solver_1169>	::=	"Clause& rp = *reason[var(p)];\n"
<Solver_1170>	::=	"for (int i = 1; i < rp.size(); i++)\n"
<Solver_1171>	::=	"{\n"
<Solver_1172>	::=	"Lit q = rp[i];\n"
<Solver_1173>	::=	"if (level[var(q)] <= 0)\n"
<Solver_1174>	::=	"{\n"
<Solver_1175>	::=	"continue;\n"
<Solver_1176>	::=	"}\n"
<Solver_1178>	::=	"int qseen = seen[var(q)];\n"
<Solver_1179>	::=	"if ((qseen & (1)) == 0 && reason[var(q) ] != __null)\n"
<Solver_1180>	::=	"{\n"
<Solver_1181>	::=	"seen[var(q)] |= 1;\n"
<Solver_1182>	::=	"if (qseen == 0)\n"
<Solver_1183>	::=	"{\n"
<Solver_1184>	::=	"analyze_toclear.push(q);\n"
<Solver_1185>	::=	"}\n"
<Solver_1186>	::=	"}\n"
<Solver_1187>	::=	"}\n"
<Solver_1188>	::=	"return;\n"
<Solver_1189>	::=	"}\n"
<Solver>	::=	<Solver_27> <Solver_28> <Solver_29> <Solver_30> <Solver_31> <Solver_32> <Solver_33> <Solver_34> <Solver_36> <Solver_37> <Solver_38> <Solver_39> <Solver_40> <Solver_41> <Solver_42> <Solver_43> <Solver_45> <Solver_48> <Solver_49> <Solver_53> <Solver_54> <Solver_56> <Solver_60> <Solver_61> <Solver_63> <Solver_64> <Solver_65> <Solver_66> <Solver_67> <Solver_68> <Solver_69> <Solver_70> <Solver_71> <Solver_72> <Solver_73> <Solver_76> <Solver_77> <Solver_78> <Solver_79> <Solver_80> <Solver_81> <Solver_82> <Solver_83> <Solver_84> <Solver_85> <Solver_86> <Solver_98> <Solver_99> <Solver_100> <Solver_101> <Solver_102> <Solver_103> <Solver_104> <Solver_105> <Solver_106> <Solver_107> <Solver_109> <Solver_111> <Solver_113> <Solver_114> <Solver_115> <Solver_118> <Solver_119> <Solver_120> <Solver_122> <Solver_123> <Solver_124> <Solver_125> <Solver_126> <Solver_127> <Solver_129> <Solver_130> <Solver_131> <Solver_132> <Solver_133> <Solver_134> <Solver_135> <Solver_136> <Solver_137> <Solver_138> <Solver_139> <Solver_140> <Solver_141> <Solver_142> <Solver_143> <Solver_145> <Solver_146> <Solver_147> <Solver_148> <Solver_149> <Solver_150> <Solver_151> <Solver_152> <Solver_153> <Solver_154> <Solver_155> <Solver_156> <Solver_157> <Solver_158> <Solver_159> <Solver_160> <Solver_162> <Solver_163> <Solver_166> <Solver_167> <Solver_168> <Solver_169> <Solver_170> <Solver_171> <Solver_172> <Solver_173> <Solver_174> <Solver_175> <Solver_176> <Solver_177> <Solver_178> <Solver_179> <Solver_182> <Solver_183> <Solver_184> <Solver_185> <Solver_186> <Solver_187> <Solver_188> <Solver_189> <Solver_190> <Solver_191> <Solver_192> <Solver_193> <Solver_194> <Solver_195> <Solver_196> <Solver_197> <Solver_200> <Solver_201> <Solver_202> <Solver_203> <Solver_204> <Solver_207> <Solver_208> <Solver_209> <Solver_210> <Solver_211> <Solver_212> <Solver_213> <Solver_214> <Solver_215> <Solver_216> <Solver_217> <Solver_222> <Solver_223> <Solver_224> <Solver_225> <Solver_226> <Solver_227> <Solver_228> <Solver_229> <Solver_230> <Solver_231> <Solver_232> <Solver_233> <Solver_234> <Solver_235> <Solver_236> <Solver_243> <Solver_244> <Solver_245> <Solver_248> <Solver_249> <Solver_250> <Solver_251> <Solver_252> <Solver_253> <Solver_254> <Solver_255> <Solver_258> <Solver_259> <Solver_260> <Solver_261> <Solver_262> <Solver_263> <Solver_264> <Solver_265> <Solver_266> <Solver_267> <Solver_268> <Solver_269> <Solver_271> <Solver_272> <Solver_273> <Solver_274> <Solver_275> <Solver_276> <Solver_277> <Solver_278> <Solver_279> <Solver_281> <Solver_282> <Solver_302> <Solver_303> <Solver_304> <Solver_305> <Solver_309> <Solver_310> <Solver_311> <Solver_313> <Solver_314> <Solver_315> <Solver_316> <Solver_318> <Solver_319> <Solver_320> <Solver_321> <Solver_323> <Solver_324> <Solver_325> <Solver_327> <Solver_328> <Solver_329> <Solver_330> <Solver_331> <Solver_332> <Solver_333> <Solver_334> <Solver_335> <Solver_336> <Solver_337> <Solver_338> <Solver_339> <Solver_340> <Solver_341> <Solver_342> <Solver_343> <Solver_344> <Solver_347> <Solver_348> <Solver_349> <Solver_350> <Solver_351> <Solver_353> <Solver_354> <Solver_355> <Solver_359> <Solver_360> <Solver_361> <Solver_362> <Solver_363> <Solver_364> <Solver_365> <Solver_366> <Solver_368> <Solver_370> <Solver_371> <Solver_372> <Solver_373> <Solver_374> <Solver_375> <Solver_376> <Solver_377> <Solver_378> <Solver_379> <Solver_380> <Solver_381> <Solver_382> <Solver_383> <Solver_384> <Solver_385> <Solver_386> <Solver_387> <Solver_388> <Solver_389> <Solver_390> <Solver_391> <Solver_392> <Solver_394> <Solver_395> <Solver_396> <Solver_397> <Solver_398> <Solver_399> <Solver_400> <Solver_401> <Solver_402> <Solver_403> <Solver_404> <Solver_405> <Solver_406> <Solver_407> <Solver_408> <Solver_409> <Solver_410> <Solver_411> <Solver_412> <Solver_413> <Solver_414> <Solver_415> <Solver_416> <Solver_417> <Solver_418> <Solver_419> <Solver_420> <Solver_421> <Solver_422> <Solver_423> <Solver_424> <Solver_425> <Solver_426> <Solver_427> <Solver_428> <Solver_432> <Solver_433> <Solver_434> <Solver_435> <Solver_436> <Solver_437> <Solver_438> <Solver_439> <Solver_440> <Solver_441> <Solver_442> <Solver_443> <Solver_444> <Solver_445> <Solver_446> <Solver_447> <Solver_448> <Solver_449> <Solver_450> <Solver_453> <Solver_454> <Solver_455> <Solver_456> <Solver_457> <Solver_462> <Solver_463> <Solver_464> <Solver_465> <Solver_466> <Solver_467> <Solver_468> <Solver_469> <Solver_471> <Solver_472> <Solver_473> <Solver_474> <Solver_475> <Solver_476> <Solver_477> <Solver_478> <Solver_479> <Solver_480> <Solver_481> <Solver_482> <Solver_483> <Solver_484> <Solver_485> <Solver_486> <Solver_487> <Solver_488> <Solver_489> <Solver_490> <Solver_491> <Solver_492> <Solver_493> <Solver_495> <Solver_496> <Solver_508> <Solver_509> <Solver_510> <Solver_511> <Solver_513> <Solver_514> <Solver_515> <Solver_516> <Solver_518> <Solver_520> <Solver_521> <Solver_522> <Solver_523> <Solver_524> <Solver_525> <Solver_526> <Solver_527> <Solver_528> <Solver_529> <Solver_530> <Solver_531> <Solver_532> <Solver_533> <Solver_534> <Solver_535> <Solver_536> <Solver_537> <Solver_538> <Solver_539> <Solver_540> <Solver_541> <Solver_542> <Solver_543> <Solver_545> <Solver_546> <Solver_549> <Solver_550> <Solver_551> <Solver_552> <Solver_553> <Solver_554> <Solver_555> <Solver_556> <Solver_557> <Solver_558> <Solver_559> <Solver_560> <Solver_574> <Solver_575> <Solver_576> <Solver_577> <Solver_579> <Solver_580> <Solver_581> <Solver_582> <Solver_583> <Solver_584> <Solver_586> <Solver_587> <Solver_588> <Solver_591> <Solver_592> <Solver_593> <Solver_594> <Solver_595> <Solver_597> <Solver_600> <Solver_601> <Solver_602> <Solver_603> <Solver_604> <Solver_605> <Solver_606> <Solver_608> <Solver_609> <Solver_610> <Solver_611> <Solver_612> <Solver_613> <Solver_614> <Solver_615> <Solver_616> <Solver_619> <Solver_620> <Solver_621> <Solver_622> <Solver_623> <Solver_625> <Solver_626> <Solver_627> <Solver_628> <Solver_629> <Solver_630> <Solver_631> <Solver_632> <Solver_633> <Solver_634> <Solver_635> <Solver_636> <Solver_637> <Solver_638> <Solver_639> <Solver_640> <Solver_642> <Solver_643> <Solver_653> <Solver_654> <Solver_655> <Solver_656> <Solver_657> <Solver_659> <Solver_660> <Solver_661> <Solver_662> <Solver_663> <Solver_664> <Solver_665> <Solver_666> <Solver_667> <Solver_668> <Solver_669> <Solver_670> <Solver_671> <Solver_672> <Solver_673> <Solver_674> <Solver_675> <Solver_676> <Solver_677> <Solver_678> <Solver_679> <Solver_680> <Solver_681> <Solver_682> <Solver_683> <Solver_684> <Solver_685> <Solver_686> <Solver_687> <Solver_690> <Solver_691> <Solver_692> <Solver_693> <Solver_694> <Solver_695> <Solver_696> <Solver_697> <Solver_698> <Solver_699> <Solver_700> <Solver_701> <Solver_702> <Solver_703> <Solver_704> <Solver_705> <Solver_716> <Solver_717> <Solver_718> <Solver_720> <Solver_721> <Solver_722> <Solver_723> <Solver_725> <Solver_726> <Solver_727> <Solver_728> <Solver_731> <Solver_732> <Solver_733> <Solver_734> <Solver_735> <Solver_738> <Solver_740> <Solver_741> <Solver_743> <Solver_744> <Solver_761> <Solver_762> <Solver_763> <Solver_764> <Solver_765> <Solver_766> <Solver_768> <Solver_770> <Solver_772> <Solver_773> <Solver_774> <Solver_775> <Solver_776> <Solver_778> <Solver_779> <Solver_781> <Solver_783> <Solver_784> <Solver_785> <Solver_786> <Solver_788> <Solver_789> <Solver_790> <Solver_791> <Solver_793> <Solver_794> <Solver_795> <Solver_796> <Solver_797> <Solver_798> <Solver_799> <Solver_800> <Solver_801> <Solver_802> <Solver_803> <Solver_804> <Solver_806> <Solver_807> <Solver_809> <Solver_810> <Solver_811> <Solver_814> <Solver_815> <Solver_816> <Solver_817> <Solver_818> <Solver_819> <Solver_821> <Solver_822> <Solver_823> <Solver_824> <Solver_825> <Solver_826> <Solver_827> <Solver_828> <Solver_829> <Solver_830> <Solver_831> <Solver_832> <Solver_834> <Solver_835> <Solver_836> <Solver_837> <Solver_838> <Solver_839> <Solver_840> <Solver_841> <Solver_843> <Solver_844> <Solver_845> <Solver_846> <Solver_848> <Solver_849> <Solver_850> <Solver_851> <Solver_852> <Solver_855> <Solver_856> <Solver_857> <Solver_858> <Solver_860> <Solver_861> <Solver_863> <Solver_864> <Solver_866> <Solver_867> <Solver_868> <Solver_870> <Solver_871> <Solver_872> <Solver_874> <Solver_875> <Solver_876> <Solver_877> <Solver_878> <Solver_879> <Solver_880> <Solver_881> <Solver_882> <Solver_883> <Solver_884> <Solver_885> <Solver_886> <Solver_888> <Solver_889> <Solver_891> <Solver_892> <Solver_894> <Solver_895> <Solver_897> <Solver_898> <Solver_899> <Solver_902> <Solver_903> <Solver_904> <Solver_905> <Solver_906> <Solver_907> <Solver_910> <Solver_911> <Solver_912> <Solver_913> <Solver_915> <Solver_916> <Solver_917> <Solver_918> <Solver_919> <Solver_920> <Solver_922> <Solver_923> <Solver_926> <Solver_927> <Solver_928> <Solver_929> <Solver_931> <Solver_932> <Solver_933> <Solver_934> <Solver_936> <Solver_939> <Solver_940> <Solver_941> <Solver_942> <Solver_943> <Solver_944> <Solver_945> <Solver_946> <Solver_947> <Solver_948> <Solver_949> <Solver_951> <Solver_961> <Solver_962> <Solver_965> <Solver_966> <Solver_967> <Solver_968> <Solver_974> <Solver_975> <Solver_977> <Solver_978> <Solver_979> <Solver_980> <Solver_981> <Solver_983> <Solver_985> <Solver_986> <Solver_987> <Solver_988> <Solver_989> <Solver_990> <Solver_991> <Solver_992> <Solver_993> <Solver_995> <Solver_996> <Solver_997> <Solver_1003> <Solver_1004> <Solver_1005> <Solver_1006> <Solver_1007> <Solver_1008> <Solver_1009> <Solver_1010> <Solver_1011> <Solver_1012> <Solver_1013> <Solver_1014> <Solver_1015> <Solver_1016> <Solver_1021> <Solver_1022> <Solver_1023> <Solver_1025> <Solver_1028> <Solver_1031> <Solver_1032> <Solver_1034> <Solver_1035> <Solver_1036> <Solver_1037> <Solver_1038> <Solver_1039> <Solver_1040> <Solver_1041> <Solver_1043> <Solver_1044> <Solver_1046> <Solver_1047> <Solver_1048> <Solver_1052> <Solver_1053> <Solver_1054> <Solver_1055> <Solver_1056> <Solver_1057> <Solver_1058> <Solver_1059> <Solver_1060> <Solver_1061> <Solver_1062> <Solver_1063> <Solver_1064> <Solver_1065> <Solver_1067> <Solver_1068> <Solver_1069> <Solver_1070> <Solver_1071> <Solver_1072> <Solver_1079> <Solver_1080> <Solver_1081> <Solver_1082> <Solver_1083> <Solver_1084> <Solver_1085> <Solver_1087> <Solver_1088> <Solver_1089> <Solver_1090> <Solver_1091> <Solver_1092> <Solver_1093> <Solver_1095> <Solver_1096> <Solver_1099> <Solver_1100> <Solver_1101> <Solver_1102> <Solver_1103> <Solver_1104> <Solver_1105> <Solver_1106> <Solver_1107> <Solver_1108> <Solver_1109> <Solver_1110> <Solver_1111> <Solver_1112> <Solver_1114> <Solver_1115> <Solver_1116> <Solver_1117> <Solver_1118> <Solver_1119> <Solver_1120> <Solver_1121> <Solver_1122> <Solver_1123> <Solver_1124> <Solver_1125> <Solver_1126> <Solver_1127> <Solver_1128> <Solver_1129> <Solver_1131> <Solver_1132> <Solver_1133> <Solver_1134> <Solver_1135> <Solver_1136> <Solver_1138> <Solver_1139> <Solver_1140> <Solver_1141> <Solver_1142> <Solver_1143> <Solver_1144> <Solver_1146> <Solver_1147> <Solver_1148> <Solver_1149> <Solver_1150> <Solver_1151> <Solver_1152> <Solver_1153> <Solver_1154> <Solver_1155> <Solver_1156> <Solver_1157> <Solver_1158> <Solver_1159> <Solver_1160> <Solver_1161> <Solver_1162> <Solver_1163> <Solver_1164> <Solver_1165> <Solver_1167> <Solver_1168> <Solver_1169> <Solver_1170> <Solver_1171> <Solver_1172> <Solver_1173> <Solver_1174> <Solver_1175> <Solver_1176> <Solver_1178> <Solver_1179> <Solver_1180> <Solver_1181> <Solver_1182> <Solver_1183> <Solver_1184> <Solver_1185> <Solver_1186> <Solver_1187> <Solver_1188> <Solver_1189> 
<start>	::= <Solver>
