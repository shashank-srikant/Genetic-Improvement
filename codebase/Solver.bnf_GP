#pre_syntax3.awk Revision: 1.31  /dev/null Thu Mar 08 15:57:17 GMT 2012
#sources/mtl/Alg.h sources/mtl/BasicHeap.h sources/mtl/BoxedVec.h sources/mtl/Heap.h sources/mtl/Map.h sources/mtl/Queue.h sources/mtl/Sort.h sources/mtl/Vec.h sources/core/Solver.h sources/core/SolverTypes.h sources/simp/SimpSolver.h Solver_E.C Solver.bnf 
#create_syntax.awk Revision: 1.51  Thu Oct 24 17:55:10 BST 2013
#clean_cpp.awk Revision: 1.2  "../core/Solver.C" Thu Oct 24 17:54:32 BST 2013
<Solver_27>	::=	"int Solver::choosepolarity()\n"
<Solver_28>	::=	"{\n"
<Solver_29>	::=	"{Log_count64++;/*29*/} if" <IF_Solver_29> " \n"
#"if
<IF_Solver_29>	::=	"(1)"
<Solver_30>	::=	"{\n"
<Solver_31>	::=	"{Log_count64++;/*31*/} return polarity_false;\n"
<Solver_32>	::=	"}\n"
<Solver_33>	::=	"{Log_count64++;/*33*/} return polarity_user;\n"
<Solver_34>	::=	"}\n"
<Solver_36>	::=	"char Solver::choosesign(char sign)\n"
<Solver_37>	::=	"{\n"
<Solver_38>	::=	"{Log_count64++;/*38*/} if" <IF_Solver_38> " \n"
#"if
<IF_Solver_38>	::=	"(1)"
<Solver_39>	::=	"{\n"
<Solver_40>	::=	"{Log_count64++;/*40*/} return sign;\n"
<Solver_41>	::=	"}\n"
<Solver_42>	::=	"{Log_count64++;/*42*/} return false;\n"
<Solver_43>	::=	"}\n"
<Solver_45>	::=	"Solver::Solver() :\n"
<Solver_48>	::=	"var_decay(1 / 0.95), clause_decay(1 / 0.999), random_var_freq(0.02)\n"
<Solver_49>	::=	", restart_first(100), restart_inc(1.5), learntsize_factor((double)1/(double)3), learntsize_inc(1.1)\n"
<Solver_53>	::=	", expensive_ccmin (true)\n"
<Solver_54>	::=	", polarity_mode (choosepolarity())\n"
<Solver_56>	::=	", verbosity (0)\n"
<Solver_60>	::=	", starts(0), decisions(0), rnd_decisions(0), propagations(0), conflicts(0)\n"
<Solver_61>	::=	", clauses_literals(0), learnts_literals(0), max_literals(0), tot_literals(0)\n"
<Solver_63>	::=	", ok (true)\n"
<Solver_64>	::=	", cla_inc (1)\n"
<Solver_65>	::=	", var_inc (1)\n"
<Solver_66>	::=	", qhead (0)\n"
<Solver_67>	::=	", simpDB_assigns (-1)\n"
<Solver_68>	::=	", simpDB_props (0)\n"
<Solver_69>	::=	", order_heap (VarOrderLt(activity))\n"
<Solver_70>	::=	", random_seed (91648253)\n"
<Solver_71>	::=	", progress_estimate(0)\n"
<Solver_72>	::=	", remove_satisfied (true)\n"
<Solver_73>	::=	"{}\n"
<Solver_76>	::=	"Solver::~Solver()\n"
<Solver_77>	::=	"{\n"
<Solver_78>	::=	"for(" <for1_Solver_78> ";" <for2_Solver_78> ";" <for3_Solver_78> ") \n"
<for1_Solver_78>	::=	"int i = 0"
<for2_Solver_78>	::=	"i < learnts.size()"
<for3_Solver_78>	::=	"i++"
<Solver_79>	::=	"{\n"
<Solver_80>	::=	"" <_Solver_80> "{Log_count64++;/*80*/}\n"
#other
<_Solver_80>	::=	"free(learnts[i]);"
<Solver_81>	::=	"}\n"
<Solver_82>	::=	"for(" <for1_Solver_82> ";" <for2_Solver_82> ";" <for3_Solver_82> ") \n"
<for1_Solver_82>	::=	"int i = 0"
<for2_Solver_82>	::=	"i < clauses.size()"
<for3_Solver_82>	::=	"i++"
<Solver_83>	::=	"{\n"
<Solver_84>	::=	"" <_Solver_84> "{Log_count64++;/*84*/}\n"
#other
<_Solver_84>	::=	"free(clauses[i]);"
<Solver_85>	::=	"}\n"
<Solver_86>	::=	"}\n"
<Solver_98>	::=	"Var Solver::newVar(bool sign, bool dvar)\n"
<Solver_99>	::=	"{\n"
<Solver_100>	::=	"int v = nVars();\n"
<Solver_101>	::=	"" <_Solver_101> "{Log_count64++;/*101*/}\n"
#other
<_Solver_101>	::=	"watches .push();"
<Solver_102>	::=	"" <_Solver_102> "{Log_count64++;/*102*/}\n"
#other
<_Solver_102>	::=	"watches .push();"
<Solver_103>	::=	"" <_Solver_103> "{Log_count64++;/*103*/}\n"
#other
<_Solver_103>	::=	"reason .push(__null);"
<Solver_104>	::=	"" <_Solver_104> "{Log_count64++;/*104*/}\n"
#other
<_Solver_104>	::=	"assigns .push(toInt(l_Undef));"
<Solver_105>	::=	"" <_Solver_105> "{Log_count64++;/*105*/}\n"
#other
<_Solver_105>	::=	"level .push(-1);"
<Solver_106>	::=	"" <_Solver_106> "{Log_count64++;/*106*/}\n"
#other
<_Solver_106>	::=	"activity .push(0);"
<Solver_107>	::=	"" <_Solver_107> "{Log_count64++;/*107*/}\n"
#other
<_Solver_107>	::=	"seen .push(0);"
<Solver_109>	::=	"" <_Solver_109> "{Log_count64++;/*109*/}\n"
#other
<_Solver_109>	::=	"polarity .push(choosesign((char)sign));"
<Solver_111>	::=	"" <_Solver_111> "{Log_count64++;/*111*/}\n"
#other
<_Solver_111>	::=	"decision_var.push((char)dvar);"
<Solver_113>	::=	"" <_Solver_113> "{Log_count64++;/*113*/}\n"
#other
<_Solver_113>	::=	"insertVarOrder(v);"
<Solver_114>	::=	"{Log_count64++;/*114*/} return v;\n"
<Solver_115>	::=	"}\n"
<Solver_118>	::=	"bool Solver::addClause(vec<Lit>& ps)\n"
<Solver_119>	::=	"{\n"
<Solver_120>	::=	"" <_Solver_120> "{Log_count64++;/*120*/}\n"
#other
<_Solver_120>	::=	"((decisionLevel() == 0) ? static_cast<void> (0) : __assert_fail (\"decisionLevel() == 0\", \"../core/Solver.C\", 120, __PRETTY_FUNCTION__));"
<Solver_122>	::=	"{Log_count64++;/*122*/} if" <IF_Solver_122> " \n"
#"if
<IF_Solver_122>	::=	"(!ok)"
<Solver_123>	::=	"{\n"
<Solver_124>	::=	"{Log_count64++;/*124*/} return false;\n"
<Solver_125>	::=	"}\n"
<Solver_126>	::=	"else\n"
<Solver_127>	::=	"{\n"
<Solver_129>	::=	"" <_Solver_129> "{Log_count64++;/*129*/}\n"
#other
<_Solver_129>	::=	"sort(ps);"
<Solver_130>	::=	"Lit p; int i, j;\n"
<Solver_131>	::=	"for(" <for1_Solver_131> ";" <for2_Solver_131> ";" <for3_Solver_131> ") \n"
<for1_Solver_131>	::=	"i = j = 0, p = lit_Undef"
<for2_Solver_131>	::=	"i < ps.size()"
<for3_Solver_131>	::=	"i++"
<Solver_132>	::=	"{\n"
<Solver_133>	::=	"{Log_count64++;/*133*/} if" <IF_Solver_133> " \n"
#"if
<IF_Solver_133>	::=	"(value(ps[i]) == l_True || ps[i] == ~p)"
<Solver_134>	::=	"{\n"
<Solver_135>	::=	"{Log_count64++;/*135*/} return true;\n"
<Solver_136>	::=	"}\n"
<Solver_137>	::=	"else if" <IF_Solver_137> " \n"
#if2
<IF_Solver_137>	::=	"(value(ps[i]) != l_False && ps[i] != p)"
<Solver_138>	::=	"{\n"
<Solver_139>	::=	"" <_Solver_139> "{Log_count64++;/*139*/}\n"
#other
<_Solver_139>	::=	"ps[j++] = p = ps[i];"
<Solver_140>	::=	"}\n"
<Solver_141>	::=	"}\n"
<Solver_142>	::=	"" <_Solver_142> "{Log_count64++;/*142*/}\n"
#other
<_Solver_142>	::=	"ps.shrink(i - j);"
<Solver_143>	::=	"}\n"
<Solver_145>	::=	"{Log_count64++;/*145*/} if" <IF_Solver_145> " \n"
#"if
<IF_Solver_145>	::=	"(ps.size() == 0)"
<Solver_146>	::=	"{\n"
<Solver_147>	::=	"{Log_count64++;/*147*/} return ok = false;\n"
<Solver_148>	::=	"}\n"
<Solver_149>	::=	"else if" <IF_Solver_149> " \n"
#if2
<IF_Solver_149>	::=	"(ps.size() == 1)"
<Solver_150>	::=	"{\n"
<Solver_151>	::=	"" <_Solver_151> "{Log_count64++;/*151*/}\n"
#other
<_Solver_151>	::=	"((value(ps[0]) == l_Undef) ? static_cast<void> (0) : __assert_fail (\"value(ps[0]) == l_Undef\", \"../core/Solver.C\", 151, __PRETTY_FUNCTION__));"
<Solver_152>	::=	"" <_Solver_152> "{Log_count64++;/*152*/}\n"
#other
<_Solver_152>	::=	"uncheckedEnqueue(ps[0]);"
<Solver_153>	::=	"{Log_count64++;/*153*/} return ok = (propagate() == __null);\n"
<Solver_154>	::=	"}\n"
<Solver_155>	::=	"else\n"
<Solver_156>	::=	"{\n"
<Solver_157>	::=	"Clause* c = Clause::Clause_new(ps, false);\n"
<Solver_158>	::=	"" <_Solver_158> "{Log_count64++;/*158*/}\n"
#other
<_Solver_158>	::=	"clauses.push(c);"
<Solver_159>	::=	"" <_Solver_159> "{Log_count64++;/*159*/}\n"
#other
<_Solver_159>	::=	"attachClause(*c);"
<Solver_160>	::=	"}\n"
<Solver_162>	::=	"{Log_count64++;/*162*/} return true;\n"
<Solver_163>	::=	"}\n"
<Solver_166>	::=	"void Solver::attachClause(Clause& c)\n"
<Solver_167>	::=	"{\n"
<Solver_168>	::=	"" <_Solver_168> "{Log_count64++;/*168*/}\n"
#other
<_Solver_168>	::=	"((c.size() > 1) ? static_cast<void> (0) : __assert_fail (\"c.size() > 1\", \"../core/Solver.C\", 168, __PRETTY_FUNCTION__));"
<Solver_169>	::=	"" <_Solver_169> "{Log_count64++;/*169*/}\n"
#other
<_Solver_169>	::=	"watches[toInt(~c[0])].push(&c);"
<Solver_170>	::=	"" <_Solver_170> "{Log_count64++;/*170*/}\n"
#other
<_Solver_170>	::=	"watches[toInt(~c[1])].push(&c);"
<Solver_171>	::=	"{Log_count64++;/*171*/} if" <IF_Solver_171> " \n"
#"if
<IF_Solver_171>	::=	"(c.learnt())"
<Solver_172>	::=	"{\n"
<Solver_173>	::=	"" <_Solver_173> "{Log_count64++;/*173*/}\n"
#other
<_Solver_173>	::=	"learnts_literals += c.size();"
<Solver_174>	::=	"}\n"
<Solver_175>	::=	"else\n"
<Solver_176>	::=	"{\n"
<Solver_177>	::=	"" <_Solver_177> "{Log_count64++;/*177*/}\n"
#other
<_Solver_177>	::=	"clauses_literals += c.size();"
<Solver_178>	::=	"}\n"
<Solver_179>	::=	"}\n"
<Solver_182>	::=	"void Solver::detachClause(Clause& c)\n"
<Solver_183>	::=	"{\n"
<Solver_184>	::=	"" <_Solver_184> "{Log_count64++;/*184*/}\n"
#other
<_Solver_184>	::=	"((c.size() > 1) ? static_cast<void> (0) : __assert_fail (\"c.size() > 1\", \"../core/Solver.C\", 184, __PRETTY_FUNCTION__));"
<Solver_185>	::=	"" <_Solver_185> "{Log_count64++;/*185*/}\n"
#other
<_Solver_185>	::=	"((find(watches[toInt(~c[0])], &c)) ? static_cast<void> (0) : __assert_fail (\"find(watches[toInt(~c[0])], &c)\", \"../core/Solver.C\", 185, __PRETTY_FUNCTION__));"
<Solver_186>	::=	"" <_Solver_186> "{Log_count64++;/*186*/}\n"
#other
<_Solver_186>	::=	"((find(watches[toInt(~c[1])], &c)) ? static_cast<void> (0) : __assert_fail (\"find(watches[toInt(~c[1])], &c)\", \"../core/Solver.C\", 186, __PRETTY_FUNCTION__));"
<Solver_187>	::=	"" <_Solver_187> "{Log_count64++;/*187*/}\n"
#other
<_Solver_187>	::=	"remove(watches[toInt(~c[0])], &c);"
<Solver_188>	::=	"" <_Solver_188> "{Log_count64++;/*188*/}\n"
#other
<_Solver_188>	::=	"remove(watches[toInt(~c[1])], &c);"
<Solver_189>	::=	"{Log_count64++;/*189*/} if" <IF_Solver_189> " \n"
#"if
<IF_Solver_189>	::=	"(c.learnt())"
<Solver_190>	::=	"{\n"
<Solver_191>	::=	"" <_Solver_191> "{Log_count64++;/*191*/}\n"
#other
<_Solver_191>	::=	"learnts_literals -= c.size();"
<Solver_192>	::=	"}\n"
<Solver_193>	::=	"else\n"
<Solver_194>	::=	"{\n"
<Solver_195>	::=	"" <_Solver_195> "{Log_count64++;/*195*/}\n"
#other
<_Solver_195>	::=	"clauses_literals -= c.size();"
<Solver_196>	::=	"}\n"
<Solver_197>	::=	"}\n"
<Solver_200>	::=	"void Solver::removeClause(Clause& c)\n"
<Solver_201>	::=	"{\n"
<Solver_202>	::=	"" <_Solver_202> "{Log_count64++;/*202*/}\n"
#other
<_Solver_202>	::=	"detachClause(c);"
<Solver_203>	::=	"" <_Solver_203> "{Log_count64++;/*203*/}\n"
#other
<_Solver_203>	::=	"free(&c);"
<Solver_204>	::=	"}\n"
<Solver_207>	::=	"bool Solver::satisfied(const Clause& c) const\n"
<Solver_208>	::=	"{\n"
<Solver_209>	::=	"for(" <for1_Solver_209> ";" <for2_Solver_209> ";" <for3_Solver_209> ") \n"
<for1_Solver_209>	::=	"int i = 0"
<for2_Solver_209>	::=	"i < c.size()"
<for3_Solver_209>	::=	"i++"
<Solver_210>	::=	"{\n"
<Solver_211>	::=	"{Log_count64++;/*211*/} if" <IF_Solver_211> " \n"
#"if
<IF_Solver_211>	::=	"(value(c[i]) == l_True)"
<Solver_212>	::=	"{\n"
<Solver_213>	::=	"{Log_count64++;/*213*/} return true;\n"
<Solver_214>	::=	"}\n"
<Solver_215>	::=	"}\n"
<Solver_216>	::=	"{Log_count64++;/*216*/} return false;\n"
<Solver_217>	::=	"}\n"
<Solver_222>	::=	"void Solver::cancelUntil(int level)\n"
<Solver_223>	::=	"{\n"
<Solver_224>	::=	"{Log_count64++;/*224*/} if" <IF_Solver_224> " \n"
#"if
<IF_Solver_224>	::=	"(decisionLevel() > level)"
<Solver_225>	::=	"{\n"
<Solver_226>	::=	"for(" <for1_Solver_226> ";" <for2_Solver_226> ";" <for3_Solver_226> ") \n"
<for1_Solver_226>	::=	"int c = trail.size()-1"
<for2_Solver_226>	::=	"c >= trail_lim[level]"
<for3_Solver_226>	::=	"c--"
<Solver_227>	::=	"{\n"
<Solver_228>	::=	"Var x = var(trail[c]);\n"
<Solver_229>	::=	"" <_Solver_229> "{Log_count64++;/*229*/}\n"
#other
<_Solver_229>	::=	"assigns[x] = toInt(l_Undef);"
<Solver_230>	::=	"" <_Solver_230> "{Log_count64++;/*230*/}\n"
#other
<_Solver_230>	::=	"insertVarOrder(x);"
<Solver_231>	::=	"}\n"
<Solver_232>	::=	"" <_Solver_232> "{Log_count64++;/*232*/}\n"
#other
<_Solver_232>	::=	"qhead = trail_lim[level];"
<Solver_233>	::=	"" <_Solver_233> "{Log_count64++;/*233*/}\n"
#other
<_Solver_233>	::=	"trail.shrink(trail.size() - trail_lim[level]);"
<Solver_234>	::=	"" <_Solver_234> "{Log_count64++;/*234*/}\n"
#other
<_Solver_234>	::=	"trail_lim.shrink(trail_lim.size() - level);"
<Solver_235>	::=	"}\n"
<Solver_236>	::=	"}\n"
<Solver_243>	::=	"Lit Solver::pickBranchLit(int polarity_mode, double random_var_freq)\n"
<Solver_244>	::=	"{\n"
<Solver_245>	::=	"Var next = (-1);\n"
<Solver_248>	::=	"{Log_count64++;/*248*/} if" <IF_Solver_248> " \n"
#"if
<IF_Solver_248>	::=	"(drand(random_seed) < random_var_freq && !order_heap.empty())"
<Solver_249>	::=	"{\n"
<Solver_250>	::=	"" <_Solver_250> "{Log_count64++;/*250*/}\n"
#other
<_Solver_250>	::=	"next = order_heap[irand(random_seed,order_heap.size())];"
<Solver_251>	::=	"{Log_count64++;/*251*/} if" <IF_Solver_251> " \n"
#"if
<IF_Solver_251>	::=	"(toLbool(assigns[next]) == l_Undef && decision_var[next])"
<Solver_252>	::=	"{\n"
<Solver_253>	::=	"" <_Solver_253> "{Log_count64++;/*253*/}\n"
#other
<_Solver_253>	::=	"rnd_decisions++;"
<Solver_254>	::=	"}\n"
<Solver_255>	::=	"}\n"
<Solver_258>	::=	"while" <WHILE_Solver_258> " \n"
#WHILE
<WHILE_Solver_258>	::=	"(next == (-1) || toLbool(assigns[next]) != l_Undef || !decision_var[next])"
<Solver_259>	::=	"{\n"
<Solver_260>	::=	"{Log_count64++;/*260*/} if" <IF_Solver_260> " \n"
#"if
<IF_Solver_260>	::=	"(order_heap.empty())"
<Solver_261>	::=	"{\n"
<Solver_262>	::=	"" <_Solver_262> "{Log_count64++;/*262*/}\n"
#other
<_Solver_262>	::=	"next = (-1);"
<Solver_263>	::=	"{Log_count64++;/*263*/} break;\n"
<Solver_264>	::=	"}\n"
<Solver_265>	::=	"else\n"
<Solver_266>	::=	"{\n"
<Solver_267>	::=	"" <_Solver_267> "{Log_count64++;/*267*/}\n"
#other
<_Solver_267>	::=	"next = order_heap.removeMin();"
<Solver_268>	::=	"}\n"
<Solver_269>	::=	"}\n"
<Solver_271>	::=	"bool sign = false;\n"
<Solver_272>	::=	"switch (polarity_mode)\n"
<Solver_273>	::=	"{\n"
<Solver_274>	::=	"case polarity_true: {Log_count64++;/*274*/}" <_Solver_274> "break;\n"
#case_break
<_Solver_274>	::=	"sign = false;"
<Solver_275>	::=	"case polarity_false: {Log_count64++;/*275*/}" <_Solver_275> "break;\n"
#case_break
<_Solver_275>	::=	"sign = true;"
<Solver_276>	::=	"case polarity_user: {Log_count64++;/*276*/}" <_Solver_276> "break;\n"
#case_break
<_Solver_276>	::=	"sign = polarity[next];"
<Solver_277>	::=	"case polarity_rnd: {Log_count64++;/*277*/}" <_Solver_277> "break;\n"
#case_break
<_Solver_277>	::=	"sign = irand(random_seed, 2);"
<Solver_278>	::=	"" <_Solver_278> "{Log_count64++;/*278*/}\n"
#other
<_Solver_278>	::=	"default: ((false) ? static_cast<void> (0) : __assert_fail (\"false\", \"../core/Solver.C\", 278, __PRETTY_FUNCTION__));"
<Solver_279>	::=	"}\n"
<Solver_281>	::=	"{Log_count64++;/*281*/} return next == (-1) ? lit_Undef : Lit(next, sign);\n"
<Solver_282>	::=	"}\n"
<Solver_302>	::=	"void Solver::analyze(Clause* confl, vec<Lit>& out_learnt, int& out_btlevel)\n"
<Solver_303>	::=	"{\n"
<Solver_304>	::=	"int pathC = 0;\n"
<Solver_305>	::=	"Lit p = lit_Undef;\n"
<Solver_309>	::=	"" <_Solver_309> "{Log_count64++;/*309*/}\n"
#other
<_Solver_309>	::=	"out_learnt.push();"
<Solver_310>	::=	"int index = trail.size() - 1;\n"
<Solver_311>	::=	"" <_Solver_311> "{Log_count64++;/*311*/}\n"
#other
<_Solver_311>	::=	"out_btlevel = 0;"
<Solver_313>	::=	"do\n"
<Solver_314>	::=	"{\n"
<Solver_315>	::=	"" <_Solver_315> "{Log_count64++;/*315*/}\n"
#other
<_Solver_315>	::=	"((confl != __null) ? static_cast<void> (0) : __assert_fail (\"confl != __null\", \"../core/Solver.C\", 315, __PRETTY_FUNCTION__));"
<Solver_316>	::=	"Clause& c = *confl;\n"
<Solver_318>	::=	"{Log_count64++;/*318*/} if" <IF_Solver_318> " \n"
#"if
<IF_Solver_318>	::=	"(c.learnt())"
<Solver_319>	::=	"{\n"
<Solver_320>	::=	"" <_Solver_320> "{Log_count64++;/*320*/}\n"
#other
<_Solver_320>	::=	"claBumpActivity(c);"
<Solver_321>	::=	"}\n"
<Solver_323>	::=	"for(" <for1_Solver_323> ";" <for2_Solver_323> ";" <for3_Solver_323> ") \n"
<for1_Solver_323>	::=	"int j = (p == lit_Undef) ? 0 : 1"
<for2_Solver_323>	::=	"j < c.size()"
<for3_Solver_323>	::=	"j++"
<Solver_324>	::=	"{\n"
<Solver_325>	::=	"Lit q = c[j];\n"
<Solver_327>	::=	"{Log_count64++;/*327*/} if" <IF_Solver_327> " \n"
#"if
<IF_Solver_327>	::=	"(!seen[var(q)] && level[var(q)] > 0)"
<Solver_328>	::=	"{\n"
<Solver_329>	::=	"" <_Solver_329> "{Log_count64++;/*329*/}\n"
#other
<_Solver_329>	::=	"varBumpActivity(var(q));"
<Solver_330>	::=	"" <_Solver_330> "{Log_count64++;/*330*/}\n"
#other
<_Solver_330>	::=	"seen[var(q)] = 1;"
<Solver_331>	::=	"{Log_count64++;/*331*/} if" <IF_Solver_331> " \n"
#"if
<IF_Solver_331>	::=	"(level[var(q)] >= decisionLevel())"
<Solver_332>	::=	"{\n"
<Solver_333>	::=	"" <_Solver_333> "{Log_count64++;/*333*/}\n"
#other
<_Solver_333>	::=	"pathC++;"
<Solver_334>	::=	"}\n"
<Solver_335>	::=	"else\n"
<Solver_336>	::=	"{\n"
<Solver_337>	::=	"" <_Solver_337> "{Log_count64++;/*337*/}\n"
#other
<_Solver_337>	::=	"out_learnt.push(q);"
<Solver_338>	::=	"{Log_count64++;/*338*/} if" <IF_Solver_338> " \n"
#"if
<IF_Solver_338>	::=	"(level[var(q)] > out_btlevel)"
<Solver_339>	::=	"{\n"
<Solver_340>	::=	"" <_Solver_340> "{Log_count64++;/*340*/}\n"
#other
<_Solver_340>	::=	"out_btlevel = level[var(q)];"
<Solver_341>	::=	"}\n"
<Solver_342>	::=	"}\n"
<Solver_343>	::=	"}\n"
<Solver_344>	::=	"}\n"
<Solver_347>	::=	"while" <WHILE_Solver_347> " ;\n"
#WHILE
<WHILE_Solver_347>	::=	"(!seen[var(trail[index--])])"
<Solver_348>	::=	"" <_Solver_348> "{Log_count64++;/*348*/}\n"
#other
<_Solver_348>	::=	"p = trail[index+1];"
<Solver_349>	::=	"" <_Solver_349> "{Log_count64++;/*349*/}\n"
#other
<_Solver_349>	::=	"confl = reason[var(p)];"
<Solver_350>	::=	"" <_Solver_350> "{Log_count64++;/*350*/}\n"
#other
<_Solver_350>	::=	"seen[var(p)] = 0;"
<Solver_351>	::=	"" <_Solver_351> "{Log_count64++;/*351*/}\n"
#other
<_Solver_351>	::=	"pathC--;"
<Solver_353>	::=	"}\n"
<Solver_354>	::=	"while" <WHILE_Solver_354> " ;\n"
#WHILE
<WHILE_Solver_354>	::=	"(pathC > 0)"
<Solver_355>	::=	"" <_Solver_355> "{Log_count64++;/*355*/}\n"
#other
<_Solver_355>	::=	"out_learnt[0] = ~p;"
<Solver_359>	::=	"int i, j;\n"
<Solver_360>	::=	"{Log_count64++;/*360*/} if" <IF_Solver_360> " \n"
#"if
<IF_Solver_360>	::=	"(expensive_ccmin)"
<Solver_361>	::=	"{\n"
<Solver_362>	::=	"uint64_t abstract_level = 0;\n"
<Solver_363>	::=	"for(" <for1_Solver_363> ";" <for2_Solver_363> ";" <for3_Solver_363> ") \n"
<for1_Solver_363>	::=	"i = 1"
<for2_Solver_363>	::=	"i < out_learnt.size()"
<for3_Solver_363>	::=	"i++"
<Solver_364>	::=	"{\n"
<Solver_365>	::=	"" <_Solver_365> "{Log_count64++;/*365*/}\n"
#other
<_Solver_365>	::=	"abstract_level |= abstractLevel(var(out_learnt[i]));"
<Solver_366>	::=	"}\n"
<Solver_368>	::=	"" <_Solver_368> "{Log_count64++;/*368*/}\n"
#other
<_Solver_368>	::=	"out_learnt.copyTo(analyze_toclear);"
<Solver_370>	::=	"{Log_count64++;/*370*/} if" <IF_Solver_370> " \n"
#"if
<IF_Solver_370>	::=	"(1)"
<Solver_371>	::=	"{\n"
<Solver_372>	::=	"for(" <for1_Solver_372> ";" <for2_Solver_372> ";" <for3_Solver_372> ") \n"
<for1_Solver_372>	::=	"i = j = 1"
<for2_Solver_372>	::=	"i < out_learnt.size()"
<for3_Solver_372>	::=	"i++"
<Solver_373>	::=	"{\n"
<Solver_374>	::=	"{Log_count64++;/*374*/} if" <IF_Solver_374> " \n"
#"if
<IF_Solver_374>	::=	"(reason[var(out_learnt[i])] == __null || !litRedundant(out_learnt[i], abstract_level))"
<Solver_375>	::=	"{\n"
<Solver_376>	::=	"" <_Solver_376> "{Log_count64++;/*376*/}\n"
#other
<_Solver_376>	::=	"out_learnt[j++] = out_learnt[i];"
<Solver_377>	::=	"}\n"
<Solver_378>	::=	"}\n"
<Solver_379>	::=	"}\n"
<Solver_380>	::=	"else\n"
<Solver_381>	::=	"{\n"
<Solver_382>	::=	"" <_Solver_382> "{Log_count64++;/*382*/}\n"
#other
<_Solver_382>	::=	"i = out_learnt.size();"
<Solver_383>	::=	"int found_some = find_removable(out_learnt, i, abstract_level);\n"
<Solver_384>	::=	"{Log_count64++;/*384*/} if" <IF_Solver_384> " \n"
#"if
<IF_Solver_384>	::=	"(found_some)"
<Solver_385>	::=	"{\n"
<Solver_386>	::=	"" <_Solver_386> "{Log_count64++;/*386*/}\n"
#other
<_Solver_386>	::=	"j = prune_removable(out_learnt);"
<Solver_387>	::=	"}\n"
<Solver_388>	::=	"else\n"
<Solver_389>	::=	"{\n"
<Solver_390>	::=	"" <_Solver_390> "{Log_count64++;/*390*/}\n"
#other
<_Solver_390>	::=	"j = i;"
<Solver_391>	::=	"}\n"
<Solver_392>	::=	"}\n"
<Solver_394>	::=	"}\n"
<Solver_395>	::=	"else\n"
<Solver_396>	::=	"{\n"
<Solver_397>	::=	"" <_Solver_397> "{Log_count64++;/*397*/}\n"
#other
<_Solver_397>	::=	"out_learnt.copyTo(analyze_toclear);"
<Solver_398>	::=	"for(" <for1_Solver_398> ";" <for2_Solver_398> ";" <for3_Solver_398> ") \n"
<for1_Solver_398>	::=	"i = j = 1"
<for2_Solver_398>	::=	"i < out_learnt.size()"
<for3_Solver_398>	::=	"i++"
<Solver_399>	::=	"{\n"
<Solver_400>	::=	"{Log_count64++;/*400*/} if" <IF_Solver_400> " \n"
#"if
<IF_Solver_400>	::=	"(0)"
<Solver_401>	::=	"{\n"
<Solver_402>	::=	"{Log_count64++;/*402*/} if" <IF_Solver_402> " \n"
#"if
<IF_Solver_402>	::=	"(reason[var(out_learnt[i])] == __null)"
<Solver_403>	::=	"{\n"
<Solver_404>	::=	"" <_Solver_404> "{Log_count64++;/*404*/}\n"
#other
<_Solver_404>	::=	"out_learnt[j++] = out_learnt[i];"
<Solver_405>	::=	"{Log_count64++;/*405*/} continue;\n"
<Solver_406>	::=	"}\n"
<Solver_407>	::=	"}\n"
<Solver_408>	::=	"Clause& c = *reason[var(out_learnt[i])];\n"
<Solver_409>	::=	"for(" <for1_Solver_409> ";" <for2_Solver_409> ";" <for3_Solver_409> ") \n"
<for1_Solver_409>	::=	"int k = 1"
<for2_Solver_409>	::=	"k < c.size()"
<for3_Solver_409>	::=	"k++"
<Solver_410>	::=	"{\n"
<Solver_411>	::=	"{Log_count64++;/*411*/} if" <IF_Solver_411> " \n"
#"if
<IF_Solver_411>	::=	"(!seen[var(c[k])] && level[var(c[k])] > 0)"
<Solver_412>	::=	"{\n"
<Solver_413>	::=	"" <_Solver_413> "{Log_count64++;/*413*/}\n"
#other
<_Solver_413>	::=	"out_learnt[j++] = out_learnt[i];"
<Solver_414>	::=	"{Log_count64++;/*414*/} break;\n"
<Solver_415>	::=	"}\n"
<Solver_416>	::=	"}\n"
<Solver_417>	::=	"}\n"
<Solver_418>	::=	"}\n"
<Solver_419>	::=	"" <_Solver_419> "{Log_count64++;/*419*/}\n"
#other
<_Solver_419>	::=	"max_literals += out_learnt.size();"
<Solver_420>	::=	"{Log_count64++;/*420*/} if" <IF_Solver_420> " \n"
#"if
<IF_Solver_420>	::=	"(1)"
<Solver_421>	::=	"{\n"
<Solver_422>	::=	"" <_Solver_422> "{Log_count64++;/*422*/}\n"
#other
<_Solver_422>	::=	"out_learnt.shrink(i - j);"
<Solver_423>	::=	"}\n"
<Solver_424>	::=	"else\n"
<Solver_425>	::=	"{\n"
<Solver_426>	::=	"" <_Solver_426> "{Log_count64++;/*426*/}\n"
#other
<_Solver_426>	::=	"out_learnt.shrink(out_learnt.size() - j);"
<Solver_427>	::=	"}\n"
<Solver_428>	::=	"" <_Solver_428> "{Log_count64++;/*428*/}\n"
#other
<_Solver_428>	::=	"tot_literals += out_learnt.size();"
<Solver_432>	::=	"{Log_count64++;/*432*/} if" <IF_Solver_432> " \n"
#"if
<IF_Solver_432>	::=	"(out_learnt.size() == 1)"
<Solver_433>	::=	"{\n"
<Solver_434>	::=	"" <_Solver_434> "{Log_count64++;/*434*/}\n"
#other
<_Solver_434>	::=	"out_btlevel = 0;"
<Solver_435>	::=	"}\n"
<Solver_436>	::=	"else\n"
<Solver_437>	::=	"{\n"
<Solver_438>	::=	"int max_i = 1;\n"
<Solver_439>	::=	"for(" <for1_Solver_439> ";" <for2_Solver_439> ";" <for3_Solver_439> ") \n"
<for1_Solver_439>	::=	"int i = 2"
<for2_Solver_439>	::=	"i < out_learnt.size()"
<for3_Solver_439>	::=	"i++"
<Solver_440>	::=	"{\n"
<Solver_441>	::=	"{Log_count64++;/*441*/} if" <IF_Solver_441> " \n"
#"if
<IF_Solver_441>	::=	"(level[var(out_learnt[i])] > level[var(out_learnt[max_i])])"
<Solver_442>	::=	"{\n"
<Solver_443>	::=	"" <_Solver_443> "{Log_count64++;/*443*/}\n"
#other
<_Solver_443>	::=	"max_i = i;"
<Solver_444>	::=	"}\n"
<Solver_445>	::=	"}\n"
<Solver_446>	::=	"Lit p = out_learnt[max_i];\n"
<Solver_447>	::=	"" <_Solver_447> "{Log_count64++;/*447*/}\n"
#other
<_Solver_447>	::=	"out_learnt[max_i] = out_learnt[1];"
<Solver_448>	::=	"" <_Solver_448> "{Log_count64++;/*448*/}\n"
#other
<_Solver_448>	::=	"out_learnt[1] = p;"
<Solver_449>	::=	"" <_Solver_449> "{Log_count64++;/*449*/}\n"
#other
<_Solver_449>	::=	"out_btlevel = level[var(p)];"
<Solver_450>	::=	"}\n"
<Solver_453>	::=	"for(" <for1_Solver_453> ";" <for2_Solver_453> ";" <for3_Solver_453> ") \n"
<for1_Solver_453>	::=	"int j = 0"
<for2_Solver_453>	::=	"j < analyze_toclear.size()"
<for3_Solver_453>	::=	"j++"
<Solver_454>	::=	"{\n"
<Solver_455>	::=	"" <_Solver_455> "{Log_count64++;/*455*/}\n"
#other
<_Solver_455>	::=	"seen[var(analyze_toclear[j])] = 0;"
<Solver_456>	::=	"}\n"
<Solver_457>	::=	"}\n"
<Solver_462>	::=	"bool Solver::litRedundant(Lit p, uint64_t abstract_levels)\n"
<Solver_463>	::=	"{\n"
<Solver_464>	::=	"" <_Solver_464> "{Log_count64++;/*464*/}\n"
#other
<_Solver_464>	::=	"analyze_stack.clear(); analyze_stack.push(p);"
<Solver_465>	::=	"int top = analyze_toclear.size();\n"
<Solver_466>	::=	"while" <WHILE_Solver_466> " \n"
#WHILE
<WHILE_Solver_466>	::=	"(analyze_stack.size() > 0)"
<Solver_467>	::=	"{\n"
<Solver_468>	::=	"" <_Solver_468> "{Log_count64++;/*468*/}\n"
#other
<_Solver_468>	::=	"((reason[var(analyze_stack.last())] != __null) ? static_cast<void> (0) : __assert_fail (\"reason[var(analyze_stack.last())] != __null\", \"../core/Solver.C\", 468, __PRETTY_FUNCTION__));"
<Solver_469>	::=	"Clause& c = *reason[var(analyze_stack.last())]; analyze_stack.pop();\n"
<Solver_471>	::=	"for(" <for1_Solver_471> ";" <for2_Solver_471> ";" <for3_Solver_471> ") \n"
<for1_Solver_471>	::=	"int i = 1"
<for2_Solver_471>	::=	"i < c.size()"
<for3_Solver_471>	::=	"i++"
<Solver_472>	::=	"{\n"
<Solver_473>	::=	"Lit p = c[i];\n"
<Solver_474>	::=	"{Log_count64++;/*474*/} if" <IF_Solver_474> " \n"
#"if
<IF_Solver_474>	::=	"(!seen[var(p)] && level[var(p)] > 0)"
<Solver_475>	::=	"{\n"
<Solver_476>	::=	"{Log_count64++;/*476*/} if" <IF_Solver_476> " \n"
#"if
<IF_Solver_476>	::=	"(reason[var(p)] != __null && (abstractLevel(var(p)) & abstract_levels) != 0)"
<Solver_477>	::=	"{\n"
<Solver_478>	::=	"" <_Solver_478> "{Log_count64++;/*478*/}\n"
#other
<_Solver_478>	::=	"seen[var(p)] = 1;"
<Solver_479>	::=	"" <_Solver_479> "{Log_count64++;/*479*/}\n"
#other
<_Solver_479>	::=	"analyze_stack.push(p);"
<Solver_480>	::=	"" <_Solver_480> "{Log_count64++;/*480*/}\n"
#other
<_Solver_480>	::=	"analyze_toclear.push(p);"
<Solver_481>	::=	"}\n"
<Solver_482>	::=	"else\n"
<Solver_483>	::=	"{\n"
<Solver_484>	::=	"for(" <for1_Solver_484> ";" <for2_Solver_484> ";" <for3_Solver_484> ") \n"
<for1_Solver_484>	::=	"int j = top"
<for2_Solver_484>	::=	"j < analyze_toclear.size()"
<for3_Solver_484>	::=	"j++"
<Solver_485>	::=	"{\n"
<Solver_486>	::=	"" <_Solver_486> "{Log_count64++;/*486*/}\n"
#other
<_Solver_486>	::=	"seen[var(analyze_toclear[j])] = 0;"
<Solver_487>	::=	"}\n"
<Solver_488>	::=	"" <_Solver_488> "{Log_count64++;/*488*/}\n"
#other
<_Solver_488>	::=	"analyze_toclear.shrink(analyze_toclear.size() - top);"
<Solver_489>	::=	"{Log_count64++;/*489*/} return false;\n"
<Solver_490>	::=	"}\n"
<Solver_491>	::=	"}\n"
<Solver_492>	::=	"}\n"
<Solver_493>	::=	"}\n"
<Solver_495>	::=	"{Log_count64++;/*495*/} return true;\n"
<Solver_496>	::=	"}\n"
<Solver_508>	::=	"void Solver::analyzeFinal(Lit p, vec<Lit>& out_conflict)\n"
<Solver_509>	::=	"{\n"
<Solver_510>	::=	"" <_Solver_510> "{Log_count64++;/*510*/}\n"
#other
<_Solver_510>	::=	"out_conflict.clear();"
<Solver_511>	::=	"" <_Solver_511> "{Log_count64++;/*511*/}\n"
#other
<_Solver_511>	::=	"out_conflict.push(p);"
<Solver_513>	::=	"{Log_count64++;/*513*/} if" <IF_Solver_513> " \n"
#"if
<IF_Solver_513>	::=	"(decisionLevel() == 0)"
<Solver_514>	::=	"{\n"
<Solver_515>	::=	"{Log_count64++;/*515*/} return;\n"
<Solver_516>	::=	"}\n"
<Solver_518>	::=	"" <_Solver_518> "{Log_count64++;/*518*/}\n"
#other
<_Solver_518>	::=	"seen[var(p)] = 1;"
<Solver_520>	::=	"for(" <for1_Solver_520> ";" <for2_Solver_520> ";" <for3_Solver_520> ") \n"
<for1_Solver_520>	::=	"int i = trail.size()-1"
<for2_Solver_520>	::=	"i >= trail_lim[0]"
<for3_Solver_520>	::=	"i--"
<Solver_521>	::=	"{\n"
<Solver_522>	::=	"Var x = var(trail[i]);\n"
<Solver_523>	::=	"{Log_count64++;/*523*/} if" <IF_Solver_523> " \n"
#"if
<IF_Solver_523>	::=	"(seen[x])"
<Solver_524>	::=	"{\n"
<Solver_525>	::=	"{Log_count64++;/*525*/} if" <IF_Solver_525> " \n"
#"if
<IF_Solver_525>	::=	"(reason[x] == __null)"
<Solver_526>	::=	"{\n"
<Solver_527>	::=	"" <_Solver_527> "{Log_count64++;/*527*/}\n"
#other
<_Solver_527>	::=	"((level[x] > 0) ? static_cast<void> (0) : __assert_fail (\"level[x] > 0\", \"../core/Solver.C\", 527, __PRETTY_FUNCTION__));"
<Solver_528>	::=	"" <_Solver_528> "{Log_count64++;/*528*/}\n"
#other
<_Solver_528>	::=	"out_conflict.push(~trail[i]);"
<Solver_529>	::=	"}\n"
<Solver_530>	::=	"else\n"
<Solver_531>	::=	"{\n"
<Solver_532>	::=	"Clause& c = *reason[x];\n"
<Solver_533>	::=	"for(" <for1_Solver_533> ";" <for2_Solver_533> ";" <for3_Solver_533> ") \n"
<for1_Solver_533>	::=	"int j = 1"
<for2_Solver_533>	::=	"j < c.size()"
<for3_Solver_533>	::=	"j++"
<Solver_534>	::=	"{\n"
<Solver_535>	::=	"{Log_count64++;/*535*/} if" <IF_Solver_535> " \n"
#"if
<IF_Solver_535>	::=	"(level[var(c[j])] > 0)"
<Solver_536>	::=	"{\n"
<Solver_537>	::=	"" <_Solver_537> "{Log_count64++;/*537*/}\n"
#other
<_Solver_537>	::=	"seen[var(c[j])] = 1;"
<Solver_538>	::=	"}\n"
<Solver_539>	::=	"}\n"
<Solver_540>	::=	"}\n"
<Solver_541>	::=	"" <_Solver_541> "{Log_count64++;/*541*/}\n"
#other
<_Solver_541>	::=	"seen[x] = 0;"
<Solver_542>	::=	"}\n"
<Solver_543>	::=	"}\n"
<Solver_545>	::=	"" <_Solver_545> "{Log_count64++;/*545*/}\n"
#other
<_Solver_545>	::=	"seen[var(p)] = 0;"
<Solver_546>	::=	"}\n"
<Solver_549>	::=	"void Solver::uncheckedEnqueue(Lit p, Clause* from)\n"
<Solver_550>	::=	"{\n"
<Solver_551>	::=	"" <_Solver_551> "{Log_count64++;/*551*/}\n"
#other
<_Solver_551>	::=	"((value(p) == l_Undef) ? static_cast<void> (0) : __assert_fail (\"value(p) == l_Undef\", \"../core/Solver.C\", 551, __PRETTY_FUNCTION__));"
<Solver_552>	::=	"" <_Solver_552> "{Log_count64++;/*552*/}\n"
#other
<_Solver_552>	::=	"assigns [var(p)] = toInt(lbool(!sign(p)));"
<Solver_553>	::=	"" <_Solver_553> "{Log_count64++;/*553*/}\n"
#other
<_Solver_553>	::=	"level [var(p)] = decisionLevel();"
<Solver_554>	::=	"" <_Solver_554> "{Log_count64++;/*554*/}\n"
#other
<_Solver_554>	::=	"reason [var(p)] = from;"
<Solver_555>	::=	"{Log_count64++;/*555*/} if" <IF_Solver_555> " \n"
#"if
<IF_Solver_555>	::=	"(0)"
<Solver_556>	::=	"{\n"
<Solver_557>	::=	"" <_Solver_557> "{Log_count64++;/*557*/}\n"
#other
<_Solver_557>	::=	"polarity[var(p)] = sign(p);"
<Solver_558>	::=	"}\n"
<Solver_559>	::=	"" <_Solver_559> "{Log_count64++;/*559*/}\n"
#other
<_Solver_559>	::=	"trail.push(p);"
<Solver_560>	::=	"}\n"
<Solver_574>	::=	"Clause* Solver::propagate()\n"
<Solver_575>	::=	"{\n"
<Solver_576>	::=	"Clause* confl = __null;\n"
<Solver_577>	::=	"int num_props = 0;\n"
<Solver_579>	::=	"while" <WHILE_Solver_579> " \n"
#WHILE
<WHILE_Solver_579>	::=	"(qhead < trail.size())"
<Solver_580>	::=	"{\n"
<Solver_581>	::=	"Lit p = trail[qhead++];\n"
<Solver_582>	::=	"vec<Clause*>& ws = watches[toInt(p)];\n"
<Solver_583>	::=	"Clause **i, **j, **end;\n"
<Solver_584>	::=	"" <_Solver_584> "{Log_count64++;/*584*/}\n"
#other
<_Solver_584>	::=	"num_props++;"
<Solver_586>	::=	"for(" <for1_Solver_586> ";" <for2_Solver_586> ";" <for3_Solver_586> ") \n"
<for1_Solver_586>	::=	"i = j = (Clause**)ws, end = i + ws.size()"
<for2_Solver_586>	::=	"i != end"
<for3_Solver_586>	::=	""
<Solver_587>	::=	"{\n"
<Solver_588>	::=	"Clause& c = **i++;\n"
<Solver_591>	::=	"Lit false_lit = ~p;\n"
<Solver_592>	::=	"{Log_count64++;/*592*/} if" <IF_Solver_592> " \n"
#"if
<IF_Solver_592>	::=	"(c[0] == false_lit)"
<Solver_593>	::=	"{\n"
<Solver_594>	::=	"" <_Solver_594> "{Log_count64++;/*594*/}\n"
#other
<_Solver_594>	::=	"c[0] = c[1], c[1] = false_lit;"
<Solver_595>	::=	"}\n"
<Solver_597>	::=	"" <_Solver_597> "{Log_count64++;/*597*/}\n"
#other
<_Solver_597>	::=	"((c[1] == false_lit) ? static_cast<void> (0) : __assert_fail (\"c[1] == false_lit\", \"../core/Solver.C\", 597, __PRETTY_FUNCTION__));"
<Solver_600>	::=	"Lit first = c[0];\n"
<Solver_601>	::=	"{Log_count64++;/*601*/} if" <IF_Solver_601> " \n"
#"if
<IF_Solver_601>	::=	"(value(first) == l_True)"
<Solver_602>	::=	"{\n"
<Solver_603>	::=	"" <_Solver_603> "{Log_count64++;/*603*/}\n"
#other
<_Solver_603>	::=	"*j++ = &c;"
<Solver_604>	::=	"}\n"
<Solver_605>	::=	"else\n"
<Solver_606>	::=	"{\n"
<Solver_608>	::=	"for(" <for1_Solver_608> ";" <for2_Solver_608> ";" <for3_Solver_608> ") \n"
<for1_Solver_608>	::=	"int k = 2"
<for2_Solver_608>	::=	"k < c.size()"
<for3_Solver_608>	::=	"k++"
<Solver_609>	::=	"{\n"
<Solver_610>	::=	"{Log_count64++;/*610*/} if" <IF_Solver_610> " \n"
#"if
<IF_Solver_610>	::=	"(value(c[k]) != l_False)"
<Solver_611>	::=	"{\n"
<Solver_612>	::=	"" <_Solver_612> "{Log_count64++;/*612*/}\n"
#other
<_Solver_612>	::=	"c[1] = c[k]; c[k] = false_lit;"
<Solver_613>	::=	"" <_Solver_613> "{Log_count64++;/*613*/}\n"
#other
<_Solver_613>	::=	"watches[toInt(~c[1])].push(&c);"
<Solver_614>	::=	"" <_Solver_614> "{Log_count64++;/*614*/}\n"
#other
<_Solver_614>	::=	"goto FoundWatch;"
<Solver_615>	::=	"}\n"
<Solver_616>	::=	"}\n"
<Solver_619>	::=	"" <_Solver_619> "{Log_count64++;/*619*/}\n"
#other
<_Solver_619>	::=	"*j++ = &c;"
<Solver_620>	::=	"{Log_count64++;/*620*/} if" <IF_Solver_620> " \n"
#"if
<IF_Solver_620>	::=	"(value(first) == l_False)"
<Solver_621>	::=	"{\n"
<Solver_622>	::=	"" <_Solver_622> "{Log_count64++;/*622*/}\n"
#other
<_Solver_622>	::=	"confl = &c;"
<Solver_623>	::=	"" <_Solver_623> "{Log_count64++;/*623*/}\n"
#other
<_Solver_623>	::=	"qhead = trail.size();"
<Solver_625>	::=	"while" <WHILE_Solver_625> " \n"
#WHILE
<WHILE_Solver_625>	::=	"(i < end)"
<Solver_626>	::=	"{\n"
<Solver_627>	::=	"" <_Solver_627> "{Log_count64++;/*627*/}\n"
#other
<_Solver_627>	::=	"*j++ = *i++;"
<Solver_628>	::=	"}\n"
<Solver_629>	::=	"}\n"
<Solver_630>	::=	"else\n"
<Solver_631>	::=	"{\n"
<Solver_632>	::=	"" <_Solver_632> "{Log_count64++;/*632*/}\n"
#other
<_Solver_632>	::=	"uncheckedEnqueue(first, &c);"
<Solver_633>	::=	"}\n"
<Solver_634>	::=	"}\n"
<Solver_635>	::=	"" <_Solver_635> "{Log_count64++;/*635*/}\n"
#other
<_Solver_635>	::=	"FoundWatch:;"
<Solver_636>	::=	"}\n"
<Solver_637>	::=	"" <_Solver_637> "{Log_count64++;/*637*/}\n"
#other
<_Solver_637>	::=	"ws.shrink(i - j);"
<Solver_638>	::=	"}\n"
<Solver_639>	::=	"" <_Solver_639> "{Log_count64++;/*639*/}\n"
#other
<_Solver_639>	::=	"propagations += num_props;"
<Solver_640>	::=	"" <_Solver_640> "{Log_count64++;/*640*/}\n"
#other
<_Solver_640>	::=	"simpDB_props -= num_props;"
<Solver_642>	::=	"{Log_count64++;/*642*/} return confl;\n"
<Solver_643>	::=	"}\n"
<Solver_653>	::=	"struct reduceDB_lt { bool operator () (Clause* x, Clause* y) { return x->size() > 2 && (y->size() == 2 || x->activity() < y->activity()); } };\n"
<Solver_654>	::=	"void Solver::reduceDB()\n"
<Solver_655>	::=	"{\n"
<Solver_656>	::=	"int i, j;\n"
<Solver_657>	::=	"double extra_lim = cla_inc / learnts.size();\n"
<Solver_659>	::=	"" <_Solver_659> "{Log_count64++;/*659*/}\n"
#other
<_Solver_659>	::=	"sort(learnts, reduceDB_lt());"
<Solver_660>	::=	"for(" <for1_Solver_660> ";" <for2_Solver_660> ";" <for3_Solver_660> ") \n"
<for1_Solver_660>	::=	"i = j = 0"
<for2_Solver_660>	::=	"i < learnts.size() / 2"
<for3_Solver_660>	::=	"i++"
<Solver_661>	::=	"{\n"
<Solver_662>	::=	"{Log_count64++;/*662*/} if" <IF_Solver_662> " \n"
#"if
<IF_Solver_662>	::=	"(learnts[i]->size() > 2 && !locked(*learnts[i]))"
<Solver_663>	::=	"{\n"
<Solver_664>	::=	"" <_Solver_664> "{Log_count64++;/*664*/}\n"
#other
<_Solver_664>	::=	"removeClause(*learnts[i]);"
<Solver_665>	::=	"}\n"
<Solver_666>	::=	"else\n"
<Solver_667>	::=	"{\n"
<Solver_668>	::=	"" <_Solver_668> "{Log_count64++;/*668*/}\n"
#other
<_Solver_668>	::=	"learnts[j++] = learnts[i];"
<Solver_669>	::=	"}\n"
<Solver_670>	::=	"}\n"
<Solver_671>	::=	"for(" <for1_Solver_671> ";" <for2_Solver_671> ";" <for3_Solver_671> ") \n"
<for1_Solver_671>	::=	""
<for2_Solver_671>	::=	"i < learnts.size()"
<for3_Solver_671>	::=	"i++"
<Solver_672>	::=	"{\n"
<Solver_673>	::=	"{Log_count64++;/*673*/} if" <IF_Solver_673> " \n"
#"if
<IF_Solver_673>	::=	"(learnts[i]->size() > 2 && !locked(*learnts[i]) && learnts[i]->activity() < extra_lim)"
<Solver_674>	::=	"{\n"
<Solver_675>	::=	"" <_Solver_675> "{Log_count64++;/*675*/}\n"
#other
<_Solver_675>	::=	"removeClause(*learnts[i]);"
<Solver_676>	::=	"}\n"
<Solver_677>	::=	"else\n"
<Solver_678>	::=	"{\n"
<Solver_679>	::=	"" <_Solver_679> "{Log_count64++;/*679*/}\n"
#other
<_Solver_679>	::=	"learnts[j++] = learnts[i];"
<Solver_680>	::=	"}\n"
<Solver_681>	::=	"}\n"
<Solver_682>	::=	"" <_Solver_682> "{Log_count64++;/*682*/}\n"
#other
<_Solver_682>	::=	"learnts.shrink(i - j);"
<Solver_683>	::=	"{Log_count64++;/*683*/} if" <IF_Solver_683> " \n"
#"if
<IF_Solver_683>	::=	"(0)"
<Solver_684>	::=	"{\n"
<Solver_685>	::=	"" <_Solver_685> "{Log_count64++;/*685*/}\n"
#other
<_Solver_685>	::=	"nof_learnts *= learntsize_inc;"
<Solver_686>	::=	"}\n"
<Solver_687>	::=	"}\n"
<Solver_690>	::=	"void Solver::removeSatisfied(vec<Clause*>& cs)\n"
<Solver_691>	::=	"{\n"
<Solver_692>	::=	"int i,j;\n"
<Solver_693>	::=	"for(" <for1_Solver_693> ";" <for2_Solver_693> ";" <for3_Solver_693> ") \n"
<for1_Solver_693>	::=	"i = j = 0"
<for2_Solver_693>	::=	"i < cs.size()"
<for3_Solver_693>	::=	"i++"
<Solver_694>	::=	"{\n"
<Solver_695>	::=	"{Log_count64++;/*695*/} if" <IF_Solver_695> " \n"
#"if
<IF_Solver_695>	::=	"(satisfied(*cs[i]))"
<Solver_696>	::=	"{\n"
<Solver_697>	::=	"" <_Solver_697> "{Log_count64++;/*697*/}\n"
#other
<_Solver_697>	::=	"removeClause(*cs[i]);"
<Solver_698>	::=	"}\n"
<Solver_699>	::=	"else\n"
<Solver_700>	::=	"{\n"
<Solver_701>	::=	"" <_Solver_701> "{Log_count64++;/*701*/}\n"
#other
<_Solver_701>	::=	"cs[j++] = cs[i];"
<Solver_702>	::=	"}\n"
<Solver_703>	::=	"}\n"
<Solver_704>	::=	"" <_Solver_704> "{Log_count64++;/*704*/}\n"
#other
<_Solver_704>	::=	"cs.shrink(i - j);"
<Solver_705>	::=	"}\n"
<Solver_716>	::=	"bool Solver::simplify()\n"
<Solver_717>	::=	"{\n"
<Solver_718>	::=	"" <_Solver_718> "{Log_count64++;/*718*/}\n"
#other
<_Solver_718>	::=	"((decisionLevel() == 0) ? static_cast<void> (0) : __assert_fail (\"decisionLevel() == 0\", \"../core/Solver.C\", 718, __PRETTY_FUNCTION__));"
<Solver_720>	::=	"{Log_count64++;/*720*/} if" <IF_Solver_720> " \n"
#"if
<IF_Solver_720>	::=	"(!ok || propagate() != __null)"
<Solver_721>	::=	"{\n"
<Solver_722>	::=	"{Log_count64++;/*722*/} return ok = false;\n"
<Solver_723>	::=	"}\n"
<Solver_725>	::=	"{Log_count64++;/*725*/} if" <IF_Solver_725> " \n"
#"if
<IF_Solver_725>	::=	"(nAssigns() == simpDB_assigns || (simpDB_props > 0))"
<Solver_726>	::=	"{\n"
<Solver_727>	::=	"{Log_count64++;/*727*/} return true;\n"
<Solver_728>	::=	"}\n"
<Solver_731>	::=	"" <_Solver_731> "{Log_count64++;/*731*/}\n"
#other
<_Solver_731>	::=	"removeSatisfied(learnts);"
<Solver_732>	::=	"{Log_count64++;/*732*/} if" <IF_Solver_732> " \n"
#"if
<IF_Solver_732>	::=	"(remove_satisfied)"
<Solver_733>	::=	"{\n"
<Solver_734>	::=	"" <_Solver_734> "{Log_count64++;/*734*/}\n"
#other
<_Solver_734>	::=	"removeSatisfied(clauses);"
<Solver_735>	::=	"}\n"
<Solver_738>	::=	"" <_Solver_738> "{Log_count64++;/*738*/}\n"
#other
<_Solver_738>	::=	"order_heap.filter(VarFilter(*this));"
<Solver_740>	::=	"" <_Solver_740> "{Log_count64++;/*740*/}\n"
#other
<_Solver_740>	::=	"simpDB_assigns = nAssigns();"
<Solver_741>	::=	"" <_Solver_741> "{Log_count64++;/*741*/}\n"
#other
<_Solver_741>	::=	"simpDB_props = clauses_literals + learnts_literals;"
<Solver_743>	::=	"{Log_count64++;/*743*/} return true;\n"
<Solver_744>	::=	"}\n"
<Solver_761>	::=	"lbool Solver::search(int nof_conflicts, int nof_learnts)\n"
<Solver_762>	::=	"{\n"
<Solver_763>	::=	"" <_Solver_763> "{Log_count64++;/*763*/}\n"
#other
<_Solver_763>	::=	"((ok) ? static_cast<void> (0) : __assert_fail (\"ok\", \"../core/Solver.C\", 763, __PRETTY_FUNCTION__));"
<Solver_764>	::=	"int backtrack_level;\n"
<Solver_765>	::=	"int conflictC = 0;\n"
<Solver_766>	::=	"vec<Lit> learnt_clause;\n"
<Solver_768>	::=	"" <_Solver_768> "{Log_count64++;/*768*/}\n"
#other
<_Solver_768>	::=	"starts++;"
<Solver_770>	::=	"bool first = true;\n"
<Solver_772>	::=	"for(" <for1_Solver_772> ";" <for2_Solver_772> ";" <for3_Solver_772> ") \n"
<for1_Solver_772>	::=	""
<for2_Solver_772>	::=	""
<for3_Solver_772>	::=	""
<Solver_773>	::=	"{\n"
<Solver_774>	::=	"Clause* confl = propagate();\n"
<Solver_775>	::=	"{Log_count64++;/*775*/} if" <IF_Solver_775> " \n"
#"if
<IF_Solver_775>	::=	"(confl != __null)"
<Solver_776>	::=	"{\n"
<Solver_778>	::=	"" <_Solver_778> "{Log_count64++;/*778*/}\n"
#other
<_Solver_778>	::=	"conflicts++; conflictC++;"
<Solver_779>	::=	"{Log_count64++;/*779*/} if" <IF_Solver_779> "  return l_False;\n"
#"if
<IF_Solver_779>	::=	"(decisionLevel() == 0)"
<Solver_781>	::=	"" <_Solver_781> "{Log_count64++;/*781*/}\n"
#other
<_Solver_781>	::=	"first = false;"
<Solver_783>	::=	"" <_Solver_783> "{Log_count64++;/*783*/}\n"
#other
<_Solver_783>	::=	"learnt_clause.clear();"
<Solver_784>	::=	"" <_Solver_784> "{Log_count64++;/*784*/}\n"
#other
<_Solver_784>	::=	"analyze(confl, learnt_clause, backtrack_level);"
<Solver_785>	::=	"" <_Solver_785> "{Log_count64++;/*785*/}\n"
#other
<_Solver_785>	::=	"cancelUntil(backtrack_level);"
<Solver_786>	::=	"" <_Solver_786> "{Log_count64++;/*786*/}\n"
#other
<_Solver_786>	::=	"((value(learnt_clause[0]) == l_Undef) ? static_cast<void> (0) : __assert_fail (\"value(learnt_clause[0]) == l_Undef\", \"../core/Solver.C\", 786, __PRETTY_FUNCTION__));"
<Solver_788>	::=	"{Log_count64++;/*788*/} if" <IF_Solver_788> " \n"
#"if
<IF_Solver_788>	::=	"(0)"
<Solver_789>	::=	"{\n"
<Solver_790>	::=	"" <_Solver_790> "{Log_count64++;/*790*/}\n"
#other
<_Solver_790>	::=	"backtrackLevels[conflicts % restartMore]= backtrack_level;"
<Solver_791>	::=	"}\n"
<Solver_793>	::=	"{Log_count64++;/*793*/} if" <IF_Solver_793> " \n"
#"if
<IF_Solver_793>	::=	"(learnt_clause.size() == 1)"
<Solver_794>	::=	"{\n"
<Solver_795>	::=	"" <_Solver_795> "{Log_count64++;/*795*/}\n"
#other
<_Solver_795>	::=	"uncheckedEnqueue(learnt_clause[0]);"
<Solver_796>	::=	"}\n"
<Solver_797>	::=	"else\n"
<Solver_798>	::=	"{\n"
<Solver_799>	::=	"Clause* c = Clause::Clause_new(learnt_clause, true);\n"
<Solver_800>	::=	"" <_Solver_800> "{Log_count64++;/*800*/}\n"
#other
<_Solver_800>	::=	"learnts.push(c);"
<Solver_801>	::=	"" <_Solver_801> "{Log_count64++;/*801*/}\n"
#other
<_Solver_801>	::=	"attachClause(*c);"
<Solver_802>	::=	"" <_Solver_802> "{Log_count64++;/*802*/}\n"
#other
<_Solver_802>	::=	"claBumpActivity(*c);"
<Solver_803>	::=	"" <_Solver_803> "{Log_count64++;/*803*/}\n"
#other
<_Solver_803>	::=	"uncheckedEnqueue(learnt_clause[0], c);"
<Solver_804>	::=	"}\n"
<Solver_806>	::=	"" <_Solver_806> "{Log_count64++;/*806*/}\n"
#other
<_Solver_806>	::=	"varDecayActivity();"
<Solver_807>	::=	"" <_Solver_807> "{Log_count64++;/*807*/}\n"
#other
<_Solver_807>	::=	"claDecayActivity();"
<Solver_809>	::=	"}\n"
<Solver_810>	::=	"else\n"
<Solver_811>	::=	"{\n"
<Solver_814>	::=	"{Log_count64++;/*814*/} if" <IF_Solver_814> " \n"
#"if
<IF_Solver_814>	::=	"(0)"
<Solver_815>	::=	"{\n"
<Solver_816>	::=	"{Log_count64++;/*816*/} if" <IF_Solver_816> " \n"
#"if
<IF_Solver_816>	::=	"(conflictC >= restartMore)"
<Solver_817>	::=	"{\n"
<Solver_818>	::=	"int LM= backtrackLevels[0];\n"
<Solver_819>	::=	"int nofLM= 1;\n"
<Solver_821>	::=	"for(" <for1_Solver_821> ";" <for2_Solver_821> ";" <for3_Solver_821> ") \n"
<for1_Solver_821>	::=	"int i=1"
<for2_Solver_821>	::=	"i< restartMore"
<for3_Solver_821>	::=	"i++"
<Solver_822>	::=	"{\n"
<Solver_823>	::=	"{Log_count64++;/*823*/} if" <IF_Solver_823> " \n"
#"if
<IF_Solver_823>	::=	"(backtrackLevels[i]< LM)"
<Solver_824>	::=	"{\n"
<Solver_825>	::=	"" <_Solver_825> "{Log_count64++;/*825*/}\n"
#other
<_Solver_825>	::=	"LM= backtrackLevels[i];"
<Solver_826>	::=	"" <_Solver_826> "{Log_count64++;/*826*/}\n"
#other
<_Solver_826>	::=	"nofLM= 1;"
<Solver_827>	::=	"}\n"
<Solver_828>	::=	"else if" <IF_Solver_828> " \n"
#if2
<IF_Solver_828>	::=	"(backtrackLevels[i]== LM)"
<Solver_829>	::=	"{\n"
<Solver_830>	::=	"" <_Solver_830> "{Log_count64++;/*830*/}\n"
#other
<_Solver_830>	::=	"nofLM++;"
<Solver_831>	::=	"}\n"
<Solver_832>	::=	"}\n"
<Solver_834>	::=	"{Log_count64++;/*834*/} if" <IF_Solver_834> " \n"
#"if
<IF_Solver_834>	::=	"(LM > restartTolerance && nofLM>= restartLess)"
<Solver_835>	::=	"{\n"
<Solver_836>	::=	"" <_Solver_836> "{Log_count64++;/*836*/}\n"
#other
<_Solver_836>	::=	"progress_estimate= progressEstimate();"
<Solver_837>	::=	"" <_Solver_837> "{Log_count64++;/*837*/}\n"
#other
<_Solver_837>	::=	"cancelUntil(0);"
<Solver_838>	::=	"{Log_count64++;/*838*/} return l_Undef;\n"
<Solver_839>	::=	"}\n"
<Solver_840>	::=	"}\n"
<Solver_841>	::=	"}\n"
<Solver_843>	::=	"{Log_count64++;/*843*/} if" <IF_Solver_843> " \n"
#"if
<IF_Solver_843>	::=	"(1)"
<Solver_844>	::=	"{\n"
<Solver_845>	::=	"{Log_count64++;/*845*/} if" <IF_Solver_845> " \n"
#"if
<IF_Solver_845>	::=	"(nof_conflicts >= 0 && conflictC >= nof_conflicts)"
<Solver_846>	::=	"{\n"
<Solver_848>	::=	"" <_Solver_848> "{Log_count64++;/*848*/}\n"
#other
<_Solver_848>	::=	"progress_estimate = progressEstimate();"
<Solver_849>	::=	"" <_Solver_849> "{Log_count64++;/*849*/}\n"
#other
<_Solver_849>	::=	"cancelUntil(0);"
<Solver_850>	::=	"{Log_count64++;/*850*/} return l_Undef;\n"
<Solver_851>	::=	"}\n"
<Solver_852>	::=	"}\n"
<Solver_855>	::=	"{Log_count64++;/*855*/} if" <IF_Solver_855> " \n"
#"if
<IF_Solver_855>	::=	"(decisionLevel() == 0 && !simplify())"
<Solver_856>	::=	"{\n"
<Solver_857>	::=	"{Log_count64++;/*857*/} return l_False;\n"
<Solver_858>	::=	"}\n"
<Solver_860>	::=	"{Log_count64++;/*860*/} if" <IF_Solver_860> " \n"
#"if
<IF_Solver_860>	::=	"(nof_learnts >= 0 && learnts.size()-nAssigns() >= nof_learnts)"
<Solver_861>	::=	"{\n"
<Solver_863>	::=	"" <_Solver_863> "{Log_count64++;/*863*/}\n"
#other
<_Solver_863>	::=	"reduceDB();"
<Solver_864>	::=	"}\n"
<Solver_866>	::=	"Lit next = lit_Undef;\n"
<Solver_867>	::=	"while" <WHILE_Solver_867> " \n"
#WHILE
<WHILE_Solver_867>	::=	"(decisionLevel() < assumptions.size())"
<Solver_868>	::=	"{\n"
<Solver_870>	::=	"Lit p = assumptions[decisionLevel()];\n"
<Solver_871>	::=	"{Log_count64++;/*871*/} if" <IF_Solver_871> " \n"
#"if
<IF_Solver_871>	::=	"(value(p) == l_True)"
<Solver_872>	::=	"{\n"
<Solver_874>	::=	"" <_Solver_874> "{Log_count64++;/*874*/}\n"
#other
<_Solver_874>	::=	"newDecisionLevel();"
<Solver_875>	::=	"}\n"
<Solver_876>	::=	"else if" <IF_Solver_876> " \n"
#if2
<IF_Solver_876>	::=	"(value(p) == l_False)"
<Solver_877>	::=	"{\n"
<Solver_878>	::=	"" <_Solver_878> "{Log_count64++;/*878*/}\n"
#other
<_Solver_878>	::=	"analyzeFinal(~p, conflict);"
<Solver_879>	::=	"{Log_count64++;/*879*/} return l_False;\n"
<Solver_880>	::=	"}\n"
<Solver_881>	::=	"else\n"
<Solver_882>	::=	"{\n"
<Solver_883>	::=	"" <_Solver_883> "{Log_count64++;/*883*/}\n"
#other
<_Solver_883>	::=	"next = p;"
<Solver_884>	::=	"{Log_count64++;/*884*/} break;\n"
<Solver_885>	::=	"}\n"
<Solver_886>	::=	"}\n"
<Solver_888>	::=	"{Log_count64++;/*888*/} if" <IF_Solver_888> " \n"
#"if
<IF_Solver_888>	::=	"(next == lit_Undef)"
<Solver_889>	::=	"{\n"
<Solver_891>	::=	"" <_Solver_891> "{Log_count64++;/*891*/}\n"
#other
<_Solver_891>	::=	"decisions++;"
<Solver_892>	::=	"" <_Solver_892> "{Log_count64++;/*892*/}\n"
#other
<_Solver_892>	::=	"next = pickBranchLit(polarity_mode, random_var_freq);"
<Solver_894>	::=	"{Log_count64++;/*894*/} if" <IF_Solver_894> " \n"
#"if
<IF_Solver_894>	::=	"(next == lit_Undef)"
<Solver_895>	::=	"{\n"
<Solver_897>	::=	"{Log_count64++;/*897*/} return l_True;\n"
<Solver_898>	::=	"}\n"
<Solver_899>	::=	"}\n"
<Solver_902>	::=	"" <_Solver_902> "{Log_count64++;/*902*/}\n"
#other
<_Solver_902>	::=	"((value(next) == l_Undef) ? static_cast<void> (0) : __assert_fail (\"value(next) == l_Undef\", \"../core/Solver.C\", 902, __PRETTY_FUNCTION__));"
<Solver_903>	::=	"" <_Solver_903> "{Log_count64++;/*903*/}\n"
#other
<_Solver_903>	::=	"newDecisionLevel();"
<Solver_904>	::=	"" <_Solver_904> "{Log_count64++;/*904*/}\n"
#other
<_Solver_904>	::=	"uncheckedEnqueue(next);"
<Solver_905>	::=	"}\n"
<Solver_906>	::=	"}\n"
<Solver_907>	::=	"}\n"
<Solver_910>	::=	"double Solver::progressEstimate() const\n"
<Solver_911>	::=	"{\n"
<Solver_912>	::=	"double progress = 0;\n"
<Solver_913>	::=	"double F = 1.0 / nVars();\n"
<Solver_915>	::=	"for(" <for1_Solver_915> ";" <for2_Solver_915> ";" <for3_Solver_915> ") \n"
<for1_Solver_915>	::=	"int i = 0"
<for2_Solver_915>	::=	"i <= decisionLevel()"
<for3_Solver_915>	::=	"i++"
<Solver_916>	::=	"{\n"
<Solver_917>	::=	"int beg = i == 0 ? 0 : trail_lim[i - 1];\n"
<Solver_918>	::=	"int end = i == decisionLevel() ? trail.size() : trail_lim[i];\n"
<Solver_919>	::=	"" <_Solver_919> "{Log_count64++;/*919*/}\n"
#other
<_Solver_919>	::=	"progress += pow(F, i) * (end - beg);"
<Solver_920>	::=	"}\n"
<Solver_922>	::=	"{Log_count64++;/*922*/} return progress / nVars();\n"
<Solver_923>	::=	"}\n"
<Solver_926>	::=	"bool Solver::solve(const vec<Lit>& assumps)\n"
<Solver_927>	::=	"{\n"
<Solver_928>	::=	"" <_Solver_928> "{Log_count64++;/*928*/}\n"
#other
<_Solver_928>	::=	"model.clear();"
<Solver_929>	::=	"" <_Solver_929> "{Log_count64++;/*929*/}\n"
#other
<_Solver_929>	::=	"conflict.clear();"
<Solver_931>	::=	"{Log_count64++;/*931*/} if" <IF_Solver_931> " \n"
#"if
<IF_Solver_931>	::=	"(!ok)"
<Solver_932>	::=	"{\n"
<Solver_933>	::=	"{Log_count64++;/*933*/} return false;\n"
<Solver_934>	::=	"}\n"
<Solver_936>	::=	"" <_Solver_936> "{Log_count64++;/*936*/}\n"
#other
<_Solver_936>	::=	"assumps.copyTo(assumptions);"
<Solver_939>	::=	"double nof_conflicts = restart_first;\n"
<Solver_940>	::=	"double nof_learnts = nClauses() * learntsize_factor;\n"
<Solver_941>	::=	"{Log_count64++;/*941*/} if" <IF_Solver_941> " \n"
#"if
<IF_Solver_941>	::=	"(0)"
<Solver_942>	::=	"{\n"
<Solver_943>	::=	"double cvr= (double)nClauses() / (double)nVars();\n"
<Solver_944>	::=	"" <_Solver_944> "{Log_count64++;/*944*/}\n"
#other
<_Solver_944>	::=	"nof_learnts= 300000 / cvr;"
<Solver_945>	::=	"}\n"
<Solver_946>	::=	"" <_Solver_946> "{Log_count64++;/*946*/}\n"
#other
<_Solver_946>	::=	"restartLess= 5;"
<Solver_947>	::=	"" <_Solver_947> "{Log_count64++;/*947*/}\n"
#other
<_Solver_947>	::=	"restartMore= 42;"
<Solver_948>	::=	"" <_Solver_948> "{Log_count64++;/*948*/}\n"
#other
<_Solver_948>	::=	"restartTolerance= nVars() / 10000 +10;"
<Solver_949>	::=	"" <_Solver_949> "{Log_count64++;/*949*/}\n"
#other
<_Solver_949>	::=	"backtrackLevels= new int[restartMore];"
<Solver_951>	::=	"lbool status = l_Undef;\n"
<Solver_961>	::=	"while" <WHILE_Solver_961> " \n"
#WHILE
<WHILE_Solver_961>	::=	"(status == l_Undef)"
<Solver_962>	::=	"{\n"
<Solver_965>	::=	"" <_Solver_965> "{Log_count64++;/*965*/}\n"
#other
<_Solver_965>	::=	"status = search((int)nof_conflicts, (int)nof_learnts);"
<Solver_966>	::=	"" <_Solver_966> "{Log_count64++;/*966*/}\n"
#other
<_Solver_966>	::=	"nof_conflicts *= restart_inc;"
<Solver_967>	::=	"" <_Solver_967> "{Log_count64++;/*967*/}\n"
#other
<_Solver_967>	::=	"nof_learnts *= learntsize_inc;"
<Solver_968>	::=	"}\n"
<Solver_974>	::=	"{Log_count64++;/*974*/} if" <IF_Solver_974> " \n"
#"if
<IF_Solver_974>	::=	"(status == l_True)"
<Solver_975>	::=	"{\n"
<Solver_977>	::=	"" <_Solver_977> "{Log_count64++;/*977*/}\n"
#other
<_Solver_977>	::=	"model.growTo(nVars());"
<Solver_978>	::=	"for(" <for1_Solver_978> ";" <for2_Solver_978> ";" <for3_Solver_978> ") \n"
<for1_Solver_978>	::=	"int i = 0"
<for2_Solver_978>	::=	"i < nVars()"
<for3_Solver_978>	::=	"i++"
<Solver_979>	::=	"{\n"
<Solver_980>	::=	"" <_Solver_980> "{Log_count64++;/*980*/}\n"
#other
<_Solver_980>	::=	"model[i] = value(i);"
<Solver_981>	::=	"}\n"
<Solver_983>	::=	"" <_Solver_983> "{Log_count64++;/*983*/}\n"
#other
<_Solver_983>	::=	"verifyModel();"
<Solver_985>	::=	"}\n"
<Solver_986>	::=	"else\n"
<Solver_987>	::=	"{\n"
<Solver_988>	::=	"" <_Solver_988> "{Log_count64++;/*988*/}\n"
#other
<_Solver_988>	::=	"((status == l_False) ? static_cast<void> (0) : __assert_fail (\"status == l_False\", \"../core/Solver.C\", 988, __PRETTY_FUNCTION__));"
<Solver_989>	::=	"{Log_count64++;/*989*/} if" <IF_Solver_989> " \n"
#"if
<IF_Solver_989>	::=	"(conflict.size() == 0)"
<Solver_990>	::=	"{\n"
<Solver_991>	::=	"" <_Solver_991> "{Log_count64++;/*991*/}\n"
#other
<_Solver_991>	::=	"ok = false;"
<Solver_992>	::=	"}\n"
<Solver_993>	::=	"}\n"
<Solver_995>	::=	"" <_Solver_995> "{Log_count64++;/*995*/}\n"
#other
<_Solver_995>	::=	"cancelUntil(0);"
<Solver_996>	::=	"{Log_count64++;/*996*/} return status == l_True;\n"
<Solver_997>	::=	"}\n"
<Solver_1003>	::=	"void Solver::verifyModel()\n"
<Solver_1004>	::=	"{\n"
<Solver_1005>	::=	"bool failed = false;\n"
<Solver_1006>	::=	"for(" <for1_Solver_1006> ";" <for2_Solver_1006> ";" <for3_Solver_1006> ") \n"
<for1_Solver_1006>	::=	"int i = 0"
<for2_Solver_1006>	::=	"i < clauses.size()"
<for3_Solver_1006>	::=	"i++"
<Solver_1007>	::=	"{\n"
<Solver_1008>	::=	"" <_Solver_1008> "{Log_count64++;/*1008*/}\n"
#other
<_Solver_1008>	::=	"((clauses[i]->mark() == 0) ? static_cast<void> (0) : __assert_fail (\"clauses[i]->mark() == 0\", \"../core/Solver.C\", 1008, __PRETTY_FUNCTION__));"
<Solver_1009>	::=	"Clause& c = *clauses[i];\n"
<Solver_1010>	::=	"for(" <for1_Solver_1010> ";" <for2_Solver_1010> ";" <for3_Solver_1010> ") \n"
<for1_Solver_1010>	::=	"int j = 0"
<for2_Solver_1010>	::=	"j < c.size()"
<for3_Solver_1010>	::=	"j++"
<Solver_1011>	::=	"{\n"
<Solver_1012>	::=	"{Log_count64++;/*1012*/} if" <IF_Solver_1012> " \n"
#"if
<IF_Solver_1012>	::=	"(modelValue(c[j]) == l_True)"
<Solver_1013>	::=	"{\n"
<Solver_1014>	::=	"" <_Solver_1014> "{Log_count64++;/*1014*/}\n"
#other
<_Solver_1014>	::=	"goto next;"
<Solver_1015>	::=	"}\n"
<Solver_1016>	::=	"}\n"
<Solver_1021>	::=	"" <_Solver_1021> "{Log_count64++;/*1021*/}\n"
#other
<_Solver_1021>	::=	"failed = true;"
<Solver_1022>	::=	"" <_Solver_1022> "{Log_count64++;/*1022*/}\n"
#other
<_Solver_1022>	::=	"next:;"
<Solver_1023>	::=	"}\n"
<Solver_1025>	::=	"" <_Solver_1025> "{Log_count64++;/*1025*/}\n"
#other
<_Solver_1025>	::=	"((!failed) ? static_cast<void> (0) : __assert_fail (\"!failed\", \"../core/Solver.C\", 1025, __PRETTY_FUNCTION__));"
<Solver_1028>	::=	"}\n"
<Solver_1031>	::=	"void Solver::checkLiteralCount()\n"
<Solver_1032>	::=	"{\n"
<Solver_1034>	::=	"int cnt = 0;\n"
<Solver_1035>	::=	"for(" <for1_Solver_1035> ";" <for2_Solver_1035> ";" <for3_Solver_1035> ") \n"
<for1_Solver_1035>	::=	"int i = 0"
<for2_Solver_1035>	::=	"i < clauses.size()"
<for3_Solver_1035>	::=	"i++"
<Solver_1036>	::=	"{\n"
<Solver_1037>	::=	"{Log_count64++;/*1037*/} if" <IF_Solver_1037> " \n"
#"if
<IF_Solver_1037>	::=	"(clauses[i]->mark() == 0)"
<Solver_1038>	::=	"{\n"
<Solver_1039>	::=	"" <_Solver_1039> "{Log_count64++;/*1039*/}\n"
#other
<_Solver_1039>	::=	"cnt += clauses[i]->size();"
<Solver_1040>	::=	"}\n"
<Solver_1041>	::=	"}\n"
<Solver_1043>	::=	"{Log_count64++;/*1043*/} if" <IF_Solver_1043> " \n"
#"if
<IF_Solver_1043>	::=	"((int)clauses_literals != cnt)"
<Solver_1044>	::=	"{\n"
<Solver_1046>	::=	"" <_Solver_1046> "{Log_count64++;/*1046*/}\n"
#other
<_Solver_1046>	::=	"(((int)clauses_literals == cnt) ? static_cast<void> (0) : __assert_fail (\"(int)clauses_literals == cnt\", \"../core/Solver.C\", 1046, __PRETTY_FUNCTION__));"
<Solver_1047>	::=	"}\n"
<Solver_1048>	::=	"}\n"
<Solver_1052>	::=	"int Solver::prune_removable(vec<Lit>& out_learnt)\n"
<Solver_1053>	::=	"{\n"
<Solver_1054>	::=	"int i, j, sz = out_learnt.size();\n"
<Solver_1055>	::=	"" <_Solver_1055> "{Log_count64++;/*1055*/}\n"
#other
<_Solver_1055>	::=	"j = 1;"
<Solver_1056>	::=	"for(" <for1_Solver_1056> ";" <for2_Solver_1056> ";" <for3_Solver_1056> ") \n"
<for1_Solver_1056>	::=	"i = 1"
<for2_Solver_1056>	::=	"i < sz"
<for3_Solver_1056>	::=	"i++"
<Solver_1057>	::=	"{\n"
<Solver_1058>	::=	"{Log_count64++;/*1058*/} if" <IF_Solver_1058> " \n"
#"if
<IF_Solver_1058>	::=	"((seen[var(out_learnt[i])] & (1|2)) == (1|2))"
<Solver_1059>	::=	"{\n"
<Solver_1060>	::=	"" <_Solver_1060> "{Log_count64++;/*1060*/}\n"
#other
<_Solver_1060>	::=	"(((seen[var(out_learnt[i])] & (4|8)) == 0) ? static_cast<void> (0) : __assert_fail (\"(seen[var(out_learnt[i])] & (4|8)) == 0\", \"../core/Solver.C\", 1060, __PRETTY_FUNCTION__));"
<Solver_1061>	::=	"" <_Solver_1061> "{Log_count64++;/*1061*/}\n"
#other
<_Solver_1061>	::=	"out_learnt[j++] = out_learnt[i];"
<Solver_1062>	::=	"}\n"
<Solver_1063>	::=	"}\n"
<Solver_1064>	::=	"{Log_count64++;/*1064*/} return j;\n"
<Solver_1065>	::=	"}\n"
<Solver_1067>	::=	"int Solver::find_removable(vec<Lit>& out_learnt, uint32_t sz0, uint32_t abstract_level)\n"
<Solver_1068>	::=	"{\n"
<Solver_1069>	::=	"int found_some;\n"
<Solver_1070>	::=	"" <_Solver_1070> "{Log_count64++;/*1070*/}\n"
#other
<_Solver_1070>	::=	"found_some = 0;"
<Solver_1071>	::=	"int sz = out_learnt.size();\n"
<Solver_1072>	::=	"int i;\n"
<Solver_1079>	::=	"for(" <for1_Solver_1079> ";" <for2_Solver_1079> ";" <for3_Solver_1079> ") \n"
<for1_Solver_1079>	::=	"i = 1"
<for2_Solver_1079>	::=	"i < sz"
<for3_Solver_1079>	::=	"i++"
<Solver_1080>	::=	"{\n"
<Solver_1081>	::=	"Lit curLit = out_learnt[i];\n"
<Solver_1082>	::=	"{Log_count64++;/*1082*/} if" <IF_Solver_1082> " \n"
#"if
<IF_Solver_1082>	::=	"(level[var(curLit)] <= 0)"
<Solver_1083>	::=	"{\n"
<Solver_1084>	::=	"{Log_count64++;/*1084*/} continue;\n"
<Solver_1085>	::=	"}\n"
<Solver_1087>	::=	"{Log_count64++;/*1087*/} if" <IF_Solver_1087> " \n"
#"if
<IF_Solver_1087>	::=	"((seen[var(curLit)] & (2|4|8)) == 0)"
<Solver_1088>	::=	"{\n"
<Solver_1089>	::=	"" <_Solver_1089> "{Log_count64++;/*1089*/}\n"
#other
<_Solver_1089>	::=	"found_some |= dfs_removable(curLit, abstract_level);"
<Solver_1090>	::=	"}\n"
<Solver_1091>	::=	"}\n"
<Solver_1092>	::=	"{Log_count64++;/*1092*/} return found_some;\n"
<Solver_1093>	::=	"}\n"
<Solver_1095>	::=	"int Solver::quick_keeper(Lit p, uint64_t abstract_level, int maykeep)\n"
<Solver_1096>	::=	"{\n"
<Solver_1099>	::=	"{Log_count64++;/*1099*/} if" <IF_Solver_1099> " \n"
#"if
<IF_Solver_1099>	::=	"(reason[var(p)] == __null)"
<Solver_1100>	::=	"{\n"
<Solver_1101>	::=	"{Log_count64++;/*1101*/} return (maykeep ? 2 : 8);\n"
<Solver_1102>	::=	"}\n"
<Solver_1103>	::=	"else if" <IF_Solver_1103> " \n"
#if2
<IF_Solver_1103>	::=	"((abstractLevel(var(p)) & abstract_level) == 0)"
<Solver_1104>	::=	"{\n"
<Solver_1105>	::=	"" <_Solver_1105> "{Log_count64++;/*1105*/}\n"
#other
<_Solver_1105>	::=	"((maykeep == 0) ? static_cast<void> (0) : __assert_fail (\"maykeep == 0\", \"../core/Solver.C\", 1105, __PRETTY_FUNCTION__));"
<Solver_1106>	::=	"{Log_count64++;/*1106*/} return 8;\n"
<Solver_1107>	::=	"}\n"
<Solver_1108>	::=	"else\n"
<Solver_1109>	::=	"{\n"
<Solver_1110>	::=	"{Log_count64++;/*1110*/} return 0;\n"
<Solver_1111>	::=	"}\n"
<Solver_1112>	::=	"}\n"
<Solver_1114>	::=	"int Solver::dfs_removable(Lit p, uint32_t abstract_level)\n"
<Solver_1115>	::=	"{\n"
<Solver_1116>	::=	"int pseen = seen[var(p)];\n"
<Solver_1117>	::=	"" <_Solver_1117> "{Log_count64++;/*1117*/}\n"
#other
<_Solver_1117>	::=	"(((pseen & (2|4|8)) == 0) ? static_cast<void> (0) : __assert_fail (\"(pseen & (2|4|8)) == 0\", \"../core/Solver.C\", 1117, __PRETTY_FUNCTION__));"
<Solver_1118>	::=	"int maykeep = pseen & (1);\n"
<Solver_1119>	::=	"int pstatus;\n"
<Solver_1120>	::=	"" <_Solver_1120> "{Log_count64++;/*1120*/}\n"
#other
<_Solver_1120>	::=	"pstatus = quick_keeper(p, abstract_level, maykeep);"
<Solver_1121>	::=	"{Log_count64++;/*1121*/} if" <IF_Solver_1121> " \n"
#"if
<IF_Solver_1121>	::=	"(pstatus)"
<Solver_1122>	::=	"{\n"
<Solver_1123>	::=	"" <_Solver_1123> "{Log_count64++;/*1123*/}\n"
#other
<_Solver_1123>	::=	"seen[var(p)] |= (char) pstatus;"
<Solver_1124>	::=	"{Log_count64++;/*1124*/} if" <IF_Solver_1124> " \n"
#"if
<IF_Solver_1124>	::=	"(pseen == 0)"
<Solver_1125>	::=	"{\n"
<Solver_1126>	::=	"" <_Solver_1126> "{Log_count64++;/*1126*/}\n"
#other
<_Solver_1126>	::=	"analyze_toclear.push(p);"
<Solver_1127>	::=	"}\n"
<Solver_1128>	::=	"{Log_count64++;/*1128*/} return 0;\n"
<Solver_1129>	::=	"}\n"
<Solver_1131>	::=	"int found_some;\n"
<Solver_1132>	::=	"" <_Solver_1132> "{Log_count64++;/*1132*/}\n"
#other
<_Solver_1132>	::=	"found_some = 0;"
<Solver_1133>	::=	"" <_Solver_1133> "{Log_count64++;/*1133*/}\n"
#other
<_Solver_1133>	::=	"pstatus = 4;"
<Solver_1134>	::=	"Clause& rp = *reason[var(p)];\n"
<Solver_1135>	::=	"int sz = rp.size();\n"
<Solver_1136>	::=	"int i;\n"
<Solver_1138>	::=	"for(" <for1_Solver_1138> ";" <for2_Solver_1138> ";" <for3_Solver_1138> ") \n"
<for1_Solver_1138>	::=	"i = 1"
<for2_Solver_1138>	::=	"i < sz"
<for3_Solver_1138>	::=	"i++"
<Solver_1139>	::=	"{\n"
<Solver_1140>	::=	"Lit q = rp[i];\n"
<Solver_1141>	::=	"{Log_count64++;/*1141*/} if" <IF_Solver_1141> " \n"
#"if
<IF_Solver_1141>	::=	"(level[var(q)] <= 0)"
<Solver_1142>	::=	"{\n"
<Solver_1143>	::=	"{Log_count64++;/*1143*/} continue;\n"
<Solver_1144>	::=	"}\n"
<Solver_1146>	::=	"{Log_count64++;/*1146*/} if" <IF_Solver_1146> " \n"
#"if
<IF_Solver_1146>	::=	"((seen[var(q)] & (2|4|8)) == 0)"
<Solver_1147>	::=	"{\n"
<Solver_1148>	::=	"" <_Solver_1148> "{Log_count64++;/*1148*/}\n"
#other
<_Solver_1148>	::=	"found_some |= dfs_removable(q, abstract_level);"
<Solver_1149>	::=	"}\n"
<Solver_1150>	::=	"int qseen = seen[var(q)];\n"
<Solver_1151>	::=	"{Log_count64++;/*1151*/} if" <IF_Solver_1151> " \n"
#"if
<IF_Solver_1151>	::=	"(qseen & (8))"
<Solver_1152>	::=	"{\n"
<Solver_1153>	::=	"" <_Solver_1153> "{Log_count64++;/*1153*/}\n"
#other
<_Solver_1153>	::=	"pstatus = (maykeep ? 2 : 8);"
<Solver_1154>	::=	"{Log_count64++;/*1154*/} break;\n"
<Solver_1155>	::=	"}\n"
<Solver_1156>	::=	"" <_Solver_1156> "{Log_count64++;/*1156*/}\n"
#other
<_Solver_1156>	::=	"(((qseen & (2|4))) ? static_cast<void> (0) : __assert_fail (\"(qseen & (2|4))\", \"../core/Solver.C\", 1156, __PRETTY_FUNCTION__));"
<Solver_1157>	::=	"}\n"
<Solver_1158>	::=	"" <_Solver_1158> "{Log_count64++;/*1158*/}\n"
#other
<_Solver_1158>	::=	"seen[var(p)] |= (char) pstatus;"
<Solver_1159>	::=	"{Log_count64++;/*1159*/} if" <IF_Solver_1159> " \n"
#"if
<IF_Solver_1159>	::=	"(pseen == 0)"
<Solver_1160>	::=	"{\n"
<Solver_1161>	::=	"" <_Solver_1161> "{Log_count64++;/*1161*/}\n"
#other
<_Solver_1161>	::=	"analyze_toclear.push(p);"
<Solver_1162>	::=	"}\n"
<Solver_1163>	::=	"" <_Solver_1163> "{Log_count64++;/*1163*/}\n"
#other
<_Solver_1163>	::=	"found_some |= maykeep;"
<Solver_1164>	::=	"{Log_count64++;/*1164*/} return found_some;\n"
<Solver_1165>	::=	"}\n"
<Solver_1167>	::=	"void Solver::mark_needed_removable(Lit p)\n"
<Solver_1168>	::=	"{\n"
<Solver_1169>	::=	"Clause& rp = *reason[var(p)];\n"
<Solver_1170>	::=	"for(" <for1_Solver_1170> ";" <for2_Solver_1170> ";" <for3_Solver_1170> ") \n"
<for1_Solver_1170>	::=	"int i = 1"
<for2_Solver_1170>	::=	"i < rp.size()"
<for3_Solver_1170>	::=	"i++"
<Solver_1171>	::=	"{\n"
<Solver_1172>	::=	"Lit q = rp[i];\n"
<Solver_1173>	::=	"{Log_count64++;/*1173*/} if" <IF_Solver_1173> " \n"
#"if
<IF_Solver_1173>	::=	"(level[var(q)] <= 0)"
<Solver_1174>	::=	"{\n"
<Solver_1175>	::=	"{Log_count64++;/*1175*/} continue;\n"
<Solver_1176>	::=	"}\n"
<Solver_1178>	::=	"int qseen = seen[var(q)];\n"
<Solver_1179>	::=	"{Log_count64++;/*1179*/} if" <IF_Solver_1179> " \n"
#"if
<IF_Solver_1179>	::=	"((qseen & (1)) == 0 && reason[var(q) ] != __null)"
<Solver_1180>	::=	"{\n"
<Solver_1181>	::=	"" <_Solver_1181> "{Log_count64++;/*1181*/}\n"
#other
<_Solver_1181>	::=	"seen[var(q)] |= 1;"
<Solver_1182>	::=	"{Log_count64++;/*1182*/} if" <IF_Solver_1182> " \n"
#"if
<IF_Solver_1182>	::=	"(qseen == 0)"
<Solver_1183>	::=	"{\n"
<Solver_1184>	::=	"" <_Solver_1184> "{Log_count64++;/*1184*/}\n"
#other
<_Solver_1184>	::=	"analyze_toclear.push(q);"
<Solver_1185>	::=	"}\n"
<Solver_1186>	::=	"}\n"
<Solver_1187>	::=	"}\n"
<Solver_1188>	::=	"{Log_count64++;/*1188*/} return;\n"
<Solver_1189>	::=	"}\n"
<Solver>	::=	<Solver_27> <Solver_28> <Solver_29> <Solver_30> <Solver_31> <Solver_32> <Solver_33> <Solver_34> <Solver_36> <Solver_37> <Solver_38> <Solver_39> <Solver_40> <Solver_41> <Solver_42> <Solver_43> <Solver_45> <Solver_48> <Solver_49> <Solver_53> <Solver_54> <Solver_56> <Solver_60> <Solver_61> <Solver_63> <Solver_64> <Solver_65> <Solver_66> <Solver_67> <Solver_68> <Solver_69> <Solver_70> <Solver_71> <Solver_72> <Solver_73> <Solver_76> <Solver_77> <Solver_78> <Solver_79> <Solver_80> <Solver_81> <Solver_82> <Solver_83> <Solver_84> <Solver_85> <Solver_86> <Solver_98> <Solver_99> <Solver_100> <Solver_101> <Solver_102> <Solver_103> <Solver_104> <Solver_105> <Solver_106> <Solver_107> <Solver_109> <Solver_111> <Solver_113> <Solver_114> <Solver_115> <Solver_118> <Solver_119> <Solver_120> <Solver_122> <Solver_123> <Solver_124> <Solver_125> <Solver_126> <Solver_127> <Solver_129> <Solver_130> <Solver_131> <Solver_132> <Solver_133> <Solver_134> <Solver_135> <Solver_136> <Solver_137> <Solver_138> <Solver_139> <Solver_140> <Solver_141> <Solver_142> <Solver_143> <Solver_145> <Solver_146> <Solver_147> <Solver_148> <Solver_149> <Solver_150> <Solver_151> <Solver_152> <Solver_153> <Solver_154> <Solver_155> <Solver_156> <Solver_157> <Solver_158> <Solver_159> <Solver_160> <Solver_162> <Solver_163> <Solver_166> <Solver_167> <Solver_168> <Solver_169> <Solver_170> <Solver_171> <Solver_172> <Solver_173> <Solver_174> <Solver_175> <Solver_176> <Solver_177> <Solver_178> <Solver_179> <Solver_182> <Solver_183> <Solver_184> <Solver_185> <Solver_186> <Solver_187> <Solver_188> <Solver_189> <Solver_190> <Solver_191> <Solver_192> <Solver_193> <Solver_194> <Solver_195> <Solver_196> <Solver_197> <Solver_200> <Solver_201> <Solver_202> <Solver_203> <Solver_204> <Solver_207> <Solver_208> <Solver_209> <Solver_210> <Solver_211> <Solver_212> <Solver_213> <Solver_214> <Solver_215> <Solver_216> <Solver_217> <Solver_222> <Solver_223> <Solver_224> <Solver_225> <Solver_226> <Solver_227> <Solver_228> <Solver_229> <Solver_230> <Solver_231> <Solver_232> <Solver_233> <Solver_234> <Solver_235> <Solver_236> <Solver_243> <Solver_244> <Solver_245> <Solver_248> <Solver_249> <Solver_250> <Solver_251> <Solver_252> <Solver_253> <Solver_254> <Solver_255> <Solver_258> <Solver_259> <Solver_260> <Solver_261> <Solver_262> <Solver_263> <Solver_264> <Solver_265> <Solver_266> <Solver_267> <Solver_268> <Solver_269> <Solver_271> <Solver_272> <Solver_273> <Solver_274> <Solver_275> <Solver_276> <Solver_277> <Solver_278> <Solver_279> <Solver_281> <Solver_282> <Solver_302> <Solver_303> <Solver_304> <Solver_305> <Solver_309> <Solver_310> <Solver_311> <Solver_313> <Solver_314> <Solver_315> <Solver_316> <Solver_318> <Solver_319> <Solver_320> <Solver_321> <Solver_323> <Solver_324> <Solver_325> <Solver_327> <Solver_328> <Solver_329> <Solver_330> <Solver_331> <Solver_332> <Solver_333> <Solver_334> <Solver_335> <Solver_336> <Solver_337> <Solver_338> <Solver_339> <Solver_340> <Solver_341> <Solver_342> <Solver_343> <Solver_344> <Solver_347> <Solver_348> <Solver_349> <Solver_350> <Solver_351> <Solver_353> <Solver_354> <Solver_355> <Solver_359> <Solver_360> <Solver_361> <Solver_362> <Solver_363> <Solver_364> <Solver_365> <Solver_366> <Solver_368> <Solver_370> <Solver_371> <Solver_372> <Solver_373> <Solver_374> <Solver_375> <Solver_376> <Solver_377> <Solver_378> <Solver_379> <Solver_380> <Solver_381> <Solver_382> <Solver_383> <Solver_384> <Solver_385> <Solver_386> <Solver_387> <Solver_388> <Solver_389> <Solver_390> <Solver_391> <Solver_392> <Solver_394> <Solver_395> <Solver_396> <Solver_397> <Solver_398> <Solver_399> <Solver_400> <Solver_401> <Solver_402> <Solver_403> <Solver_404> <Solver_405> <Solver_406> <Solver_407> <Solver_408> <Solver_409> <Solver_410> <Solver_411> <Solver_412> <Solver_413> <Solver_414> <Solver_415> <Solver_416> <Solver_417> <Solver_418> <Solver_419> <Solver_420> <Solver_421> <Solver_422> <Solver_423> <Solver_424> <Solver_425> <Solver_426> <Solver_427> <Solver_428> <Solver_432> <Solver_433> <Solver_434> <Solver_435> <Solver_436> <Solver_437> <Solver_438> <Solver_439> <Solver_440> <Solver_441> <Solver_442> <Solver_443> <Solver_444> <Solver_445> <Solver_446> <Solver_447> <Solver_448> <Solver_449> <Solver_450> <Solver_453> <Solver_454> <Solver_455> <Solver_456> <Solver_457> <Solver_462> <Solver_463> <Solver_464> <Solver_465> <Solver_466> <Solver_467> <Solver_468> <Solver_469> <Solver_471> <Solver_472> <Solver_473> <Solver_474> <Solver_475> <Solver_476> <Solver_477> <Solver_478> <Solver_479> <Solver_480> <Solver_481> <Solver_482> <Solver_483> <Solver_484> <Solver_485> <Solver_486> <Solver_487> <Solver_488> <Solver_489> <Solver_490> <Solver_491> <Solver_492> <Solver_493> <Solver_495> <Solver_496> <Solver_508> <Solver_509> <Solver_510> <Solver_511> <Solver_513> <Solver_514> <Solver_515> <Solver_516> <Solver_518> <Solver_520> <Solver_521> <Solver_522> <Solver_523> <Solver_524> <Solver_525> <Solver_526> <Solver_527> <Solver_528> <Solver_529> <Solver_530> <Solver_531> <Solver_532> <Solver_533> <Solver_534> <Solver_535> <Solver_536> <Solver_537> <Solver_538> <Solver_539> <Solver_540> <Solver_541> <Solver_542> <Solver_543> <Solver_545> <Solver_546> <Solver_549> <Solver_550> <Solver_551> <Solver_552> <Solver_553> <Solver_554> <Solver_555> <Solver_556> <Solver_557> <Solver_558> <Solver_559> <Solver_560> <Solver_574> <Solver_575> <Solver_576> <Solver_577> <Solver_579> <Solver_580> <Solver_581> <Solver_582> <Solver_583> <Solver_584> <Solver_586> <Solver_587> <Solver_588> <Solver_591> <Solver_592> <Solver_593> <Solver_594> <Solver_595> <Solver_597> <Solver_600> <Solver_601> <Solver_602> <Solver_603> <Solver_604> <Solver_605> <Solver_606> <Solver_608> <Solver_609> <Solver_610> <Solver_611> <Solver_612> <Solver_613> <Solver_614> <Solver_615> <Solver_616> <Solver_619> <Solver_620> <Solver_621> <Solver_622> <Solver_623> <Solver_625> <Solver_626> <Solver_627> <Solver_628> <Solver_629> <Solver_630> <Solver_631> <Solver_632> <Solver_633> <Solver_634> <Solver_635> <Solver_636> <Solver_637> <Solver_638> <Solver_639> <Solver_640> <Solver_642> <Solver_643> <Solver_653> <Solver_654> <Solver_655> <Solver_656> <Solver_657> <Solver_659> <Solver_660> <Solver_661> <Solver_662> <Solver_663> <Solver_664> <Solver_665> <Solver_666> <Solver_667> <Solver_668> <Solver_669> <Solver_670> <Solver_671> <Solver_672> <Solver_673> <Solver_674> <Solver_675> <Solver_676> <Solver_677> <Solver_678> <Solver_679> <Solver_680> <Solver_681> <Solver_682> <Solver_683> <Solver_684> <Solver_685> <Solver_686> <Solver_687> <Solver_690> <Solver_691> <Solver_692> <Solver_693> <Solver_694> <Solver_695> <Solver_696> <Solver_697> <Solver_698> <Solver_699> <Solver_700> <Solver_701> <Solver_702> <Solver_703> <Solver_704> <Solver_705> <Solver_716> <Solver_717> <Solver_718> <Solver_720> <Solver_721> <Solver_722> <Solver_723> <Solver_725> <Solver_726> <Solver_727> <Solver_728> <Solver_731> <Solver_732> <Solver_733> <Solver_734> <Solver_735> <Solver_738> <Solver_740> <Solver_741> <Solver_743> <Solver_744> <Solver_761> <Solver_762> <Solver_763> <Solver_764> <Solver_765> <Solver_766> <Solver_768> <Solver_770> <Solver_772> <Solver_773> <Solver_774> <Solver_775> <Solver_776> <Solver_778> <Solver_779> <Solver_781> <Solver_783> <Solver_784> <Solver_785> <Solver_786> <Solver_788> <Solver_789> <Solver_790> <Solver_791> <Solver_793> <Solver_794> <Solver_795> <Solver_796> <Solver_797> <Solver_798> <Solver_799> <Solver_800> <Solver_801> <Solver_802> <Solver_803> <Solver_804> <Solver_806> <Solver_807> <Solver_809> <Solver_810> <Solver_811> <Solver_814> <Solver_815> <Solver_816> <Solver_817> <Solver_818> <Solver_819> <Solver_821> <Solver_822> <Solver_823> <Solver_824> <Solver_825> <Solver_826> <Solver_827> <Solver_828> <Solver_829> <Solver_830> <Solver_831> <Solver_832> <Solver_834> <Solver_835> <Solver_836> <Solver_837> <Solver_838> <Solver_839> <Solver_840> <Solver_841> <Solver_843> <Solver_844> <Solver_845> <Solver_846> <Solver_848> <Solver_849> <Solver_850> <Solver_851> <Solver_852> <Solver_855> <Solver_856> <Solver_857> <Solver_858> <Solver_860> <Solver_861> <Solver_863> <Solver_864> <Solver_866> <Solver_867> <Solver_868> <Solver_870> <Solver_871> <Solver_872> <Solver_874> <Solver_875> <Solver_876> <Solver_877> <Solver_878> <Solver_879> <Solver_880> <Solver_881> <Solver_882> <Solver_883> <Solver_884> <Solver_885> <Solver_886> <Solver_888> <Solver_889> <Solver_891> <Solver_892> <Solver_894> <Solver_895> <Solver_897> <Solver_898> <Solver_899> <Solver_902> <Solver_903> <Solver_904> <Solver_905> <Solver_906> <Solver_907> <Solver_910> <Solver_911> <Solver_912> <Solver_913> <Solver_915> <Solver_916> <Solver_917> <Solver_918> <Solver_919> <Solver_920> <Solver_922> <Solver_923> <Solver_926> <Solver_927> <Solver_928> <Solver_929> <Solver_931> <Solver_932> <Solver_933> <Solver_934> <Solver_936> <Solver_939> <Solver_940> <Solver_941> <Solver_942> <Solver_943> <Solver_944> <Solver_945> <Solver_946> <Solver_947> <Solver_948> <Solver_949> <Solver_951> <Solver_961> <Solver_962> <Solver_965> <Solver_966> <Solver_967> <Solver_968> <Solver_974> <Solver_975> <Solver_977> <Solver_978> <Solver_979> <Solver_980> <Solver_981> <Solver_983> <Solver_985> <Solver_986> <Solver_987> <Solver_988> <Solver_989> <Solver_990> <Solver_991> <Solver_992> <Solver_993> <Solver_995> <Solver_996> <Solver_997> <Solver_1003> <Solver_1004> <Solver_1005> <Solver_1006> <Solver_1007> <Solver_1008> <Solver_1009> <Solver_1010> <Solver_1011> <Solver_1012> <Solver_1013> <Solver_1014> <Solver_1015> <Solver_1016> <Solver_1021> <Solver_1022> <Solver_1023> <Solver_1025> <Solver_1028> <Solver_1031> <Solver_1032> <Solver_1034> <Solver_1035> <Solver_1036> <Solver_1037> <Solver_1038> <Solver_1039> <Solver_1040> <Solver_1041> <Solver_1043> <Solver_1044> <Solver_1046> <Solver_1047> <Solver_1048> <Solver_1052> <Solver_1053> <Solver_1054> <Solver_1055> <Solver_1056> <Solver_1057> <Solver_1058> <Solver_1059> <Solver_1060> <Solver_1061> <Solver_1062> <Solver_1063> <Solver_1064> <Solver_1065> <Solver_1067> <Solver_1068> <Solver_1069> <Solver_1070> <Solver_1071> <Solver_1072> <Solver_1079> <Solver_1080> <Solver_1081> <Solver_1082> <Solver_1083> <Solver_1084> <Solver_1085> <Solver_1087> <Solver_1088> <Solver_1089> <Solver_1090> <Solver_1091> <Solver_1092> <Solver_1093> <Solver_1095> <Solver_1096> <Solver_1099> <Solver_1100> <Solver_1101> <Solver_1102> <Solver_1103> <Solver_1104> <Solver_1105> <Solver_1106> <Solver_1107> <Solver_1108> <Solver_1109> <Solver_1110> <Solver_1111> <Solver_1112> <Solver_1114> <Solver_1115> <Solver_1116> <Solver_1117> <Solver_1118> <Solver_1119> <Solver_1120> <Solver_1121> <Solver_1122> <Solver_1123> <Solver_1124> <Solver_1125> <Solver_1126> <Solver_1127> <Solver_1128> <Solver_1129> <Solver_1131> <Solver_1132> <Solver_1133> <Solver_1134> <Solver_1135> <Solver_1136> <Solver_1138> <Solver_1139> <Solver_1140> <Solver_1141> <Solver_1142> <Solver_1143> <Solver_1144> <Solver_1146> <Solver_1147> <Solver_1148> <Solver_1149> <Solver_1150> <Solver_1151> <Solver_1152> <Solver_1153> <Solver_1154> <Solver_1155> <Solver_1156> <Solver_1157> <Solver_1158> <Solver_1159> <Solver_1160> <Solver_1161> <Solver_1162> <Solver_1163> <Solver_1164> <Solver_1165> <Solver_1167> <Solver_1168> <Solver_1169> <Solver_1170> <Solver_1171> <Solver_1172> <Solver_1173> <Solver_1174> <Solver_1175> <Solver_1176> <Solver_1178> <Solver_1179> <Solver_1180> <Solver_1181> <Solver_1182> <Solver_1183> <Solver_1184> <Solver_1185> <Solver_1186> <Solver_1187> <Solver_1188> <Solver_1189> 
<start>	::= <Solver>
