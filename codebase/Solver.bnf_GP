#pre_syntax3.awk Revision: 1.31  /dev/null Thu Mar 08 15:57:17 GMT 2012
#sources/mtl/Alg.h sources/mtl/Alloc.h sources/mtl/Heap.h sources/mtl/IntTypes.h sources/mtl/Map.h sources/mtl/Queue.h sources/mtl/Sort.h sources/mtl/Vec.h sources/mtl/XAlloc.h sources/core/Dimacs.h sources/core/Solver.h sources/core/SolverTypes.h sources/simp/SimpSolver.h Solver_E.cc Solver.bnf 
#create_syntax.awk Revision: 1.51  Tue Jul 11 17:14:53 BST 2017
#clean_cpp.awk Revision: 1.2  "/home/justyna/Documents/minisatgirelease/sources/core/Solver.cc" Tue Jul 11 17:14:09 BST 2017
<Solver_3>	::=	"using namespace Minisat;\n"
<Solver_4>	::=	"static const char* _cat = \"CORE\";\n"
<Solver_5>	::=	"static DoubleOption opt_var_decay (_cat, \"var-decay\", \"The variable activity decay factor\", 0.95, DoubleRange(0, false, 1, false));\n"
<Solver_6>	::=	"static DoubleOption opt_clause_decay (_cat, \"cla-decay\", \"The clause activity decay factor\", 0.999, DoubleRange(0, false, 1, false));\n"
<Solver_7>	::=	"static DoubleOption opt_random_var_freq (_cat, \"rnd-freq\", \"The frequency with which the decision heuristic tries to choose a random variable\", 0, DoubleRange(0, true, 1, true));\n"
<Solver_8>	::=	"static DoubleOption opt_random_seed (_cat, \"rnd-seed\", \"Used by the random variable selection\", 91648253, DoubleRange(0, false,\n"
<Solver_9>	::=	"(__builtin_huge_val())\n"
<Solver_10>	::=	", false));\n"
<Solver_11>	::=	"static IntOption opt_ccmin_mode (_cat, \"ccmin-mode\", \"Controls conflict clause minimization (0=none, 1=basic, 2=deep)\", 2, IntRange(0, 2));\n"
<Solver_12>	::=	"static IntOption opt_phase_saving (_cat, \"phase-saving\", \"Controls the level of phase saving (0=none, 1=limited, 2=full)\", 2, IntRange(0, 2));\n"
<Solver_13>	::=	"static BoolOption opt_rnd_init_act (_cat, \"rnd-init\", \"Randomize the initial activity\", false);\n"
<Solver_14>	::=	"static BoolOption opt_luby_restart (_cat, \"luby\", \"Use the Luby restart sequence\", true);\n"
<Solver_15>	::=	"static IntOption opt_restart_first (_cat, \"rfirst\", \"The base restart interval\", 100, IntRange(1, (2147483647)));\n"
<Solver_16>	::=	"static DoubleOption opt_restart_inc (_cat, \"rinc\", \"Restart interval increase factor\", 2, DoubleRange(1, false, (__builtin_huge_val()) , false));\n"
<Solver_17>	::=	"static DoubleOption opt_garbage_frac (_cat, \"gc-frac\", \"The fraction of wasted memory allowed before a garbage collection is triggered\", 0.20, DoubleRange(0, false, (__builtin_huge_val()) , false));\n"
<Solver_18>	::=	"Solver::Solver() :\n"
<Solver_19>	::=	"verbosity (0)\n"
<Solver_20>	::=	", var_decay (opt_var_decay)\n"
<Solver_21>	::=	", clause_decay (opt_clause_decay)\n"
<Solver_22>	::=	", random_var_freq (opt_random_var_freq)\n"
<Solver_23>	::=	", random_seed (opt_random_seed)\n"
<Solver_24>	::=	", luby_restart (opt_luby_restart)\n"
<Solver_25>	::=	", ccmin_mode (opt_ccmin_mode)\n"
<Solver_26>	::=	", phase_saving (opt_phase_saving)\n"
<Solver_27>	::=	", rnd_pol (false)\n"
<Solver_28>	::=	", rnd_init_act (opt_rnd_init_act)\n"
<Solver_29>	::=	", garbage_frac (opt_garbage_frac)\n"
<Solver_30>	::=	", restart_first (opt_restart_first)\n"
<Solver_31>	::=	", restart_inc (opt_restart_inc)\n"
<Solver_32>	::=	", learntsize_factor((double)1/(double)3), learntsize_inc(1.1)\n"
<Solver_33>	::=	", learntsize_adjust_start_confl (100)\n"
<Solver_34>	::=	", learntsize_adjust_inc (1.5)\n"
<Solver_35>	::=	", solves(0), starts(0), decisions(0), rnd_decisions(0), propagations(0), conflicts(0)\n"
<Solver_36>	::=	", dec_vars(0), clauses_literals(0), learnts_literals(0), max_literals(0), tot_literals(0)\n"
<Solver_37>	::=	", ok (true)\n"
<Solver_38>	::=	", cla_inc (1)\n"
<Solver_39>	::=	", var_inc (1)\n"
<Solver_40>	::=	", watches (WatcherDeleted(ca))\n"
<Solver_41>	::=	", qhead (0)\n"
<Solver_42>	::=	", simpDB_assigns (-1)\n"
<Solver_43>	::=	", simpDB_props (0)\n"
<Solver_44>	::=	", order_heap (VarOrderLt(activity))\n"
<Solver_45>	::=	", progress_estimate (0)\n"
<Solver_46>	::=	", remove_satisfied (true)\n"
<Solver_47>	::=	", conflict_budget (-1)\n"
<Solver_48>	::=	", propagation_budget (-1)\n"
<Solver_49>	::=	", asynch_interrupt (false)\n"
<Solver_50>	::=	"{\n"
<Solver_51>	::=	"}\n"
<Solver_52>	::=	"Solver::~Solver()\n"
<Solver_53>	::=	"{\n"
<Solver_54>	::=	"}\n"
<Solver_55>	::=	"Var Solver::newVar(bool sign, bool dvar)\n"
<Solver_56>	::=	"{\n"
<Solver_57>	::=	"int v = nVars();\n"
<Solver_58>	::=	"" <_Solver_58> "{Log_count64++;/*58*/}\n"
#other
<_Solver_58>	::=	"watches .init(mkLit(v, false));"
<Solver_59>	::=	"" <_Solver_59> "{Log_count64++;/*59*/}\n"
#other
<_Solver_59>	::=	"watches .init(mkLit(v, true ));"
<Solver_60>	::=	"" <_Solver_60> "{Log_count64++;/*60*/}\n"
#other
<_Solver_60>	::=	"assigns .push((lbool((uint8_t)2)));"
<Solver_61>	::=	"" <_Solver_61> "{Log_count64++;/*61*/}\n"
#other
<_Solver_61>	::=	"vardata .push(mkVarData(CRef_Undef, 0));"
<Solver_62>	::=	"" <_Solver_62> "{Log_count64++;/*62*/}\n"
#other
<_Solver_62>	::=	"activity .push(rnd_init_act ? drand(random_seed) * 0.00001 : 0);"
<Solver_63>	::=	"" <_Solver_63> "{Log_count64++;/*63*/}\n"
#other
<_Solver_63>	::=	"seen .push(0);"
<Solver_64>	::=	"" <_Solver_64> "{Log_count64++;/*64*/}\n"
#other
<_Solver_64>	::=	"polarity .push(sign);"
<Solver_65>	::=	"" <_Solver_65> "{Log_count64++;/*65*/}\n"
#other
<_Solver_65>	::=	"decision .push();"
<Solver_66>	::=	"" <_Solver_66> "{Log_count64++;/*66*/}\n"
#other
<_Solver_66>	::=	"trail .capacity(v+1);"
<Solver_67>	::=	"" <_Solver_67> "{Log_count64++;/*67*/}\n"
#other
<_Solver_67>	::=	"setDecisionVar(v, dvar);"
<Solver_68>	::=	"{Log_count64++;/*68*/} return v;\n"
<Solver_69>	::=	"}\n"
<Solver_70>	::=	"bool Solver::addClause_(vec<Lit>& ps)\n"
<Solver_71>	::=	"{\n"
<Solver_73>	::=	"" <_Solver_73> "{Log_count64++;/*73*/}\n"
#other
<_Solver_73>	::=	"assert(decisionLevel() == 0);"
<Solver_74>	::=	"{Log_count64++;/*74*/} if" <IF_Solver_74> " \n"
#"if
<IF_Solver_74>	::=	"(!ok)"
<Solver_75>	::=	"{\n"
<Solver_76>	::=	"{Log_count64++;/*76*/} return false;\n"
<Solver_77>	::=	"}\n"
<Solver_78>	::=	"" <_Solver_78> "{Log_count64++;/*78*/}\n"
#other
<_Solver_78>	::=	"sort(ps);"
<Solver_79>	::=	"Lit p; int i, j;\n"
<Solver_80>	::=	"for(" <for1_Solver_80> ";" <for2_Solver_80> ";" <for3_Solver_80> ") \n"
<for1_Solver_80>	::=	"i = j = 0, p = lit_Undef"
<for2_Solver_80>	::=	"i < ps.size()"
<for3_Solver_80>	::=	"i++"
<Solver_81>	::=	"{\n"
<Solver_82>	::=	"{Log_count64++;/*82*/} if" <IF_Solver_82> " \n"
#"if
<IF_Solver_82>	::=	"(value(ps[i]) == (lbool((uint8_t)0)) || ps[i] == ~p)"
<Solver_83>	::=	"{\n"
<Solver_84>	::=	"{Log_count64++;/*84*/} return true;\n"
<Solver_85>	::=	"}\n"
<Solver_86>	::=	"else if" <IF_Solver_86> " \n"
#if2
<IF_Solver_86>	::=	"(value(ps[i]) != (lbool((uint8_t)1)) && ps[i] != p)"
<Solver_87>	::=	"{\n"
<Solver_88>	::=	"" <_Solver_88> "{Log_count64++;/*88*/}\n"
#other
<_Solver_88>	::=	"ps[j++] = p = ps[i];"
<Solver_89>	::=	"}\n"
<Solver_90>	::=	"}\n"
<Solver_91>	::=	"" <_Solver_91> "{Log_count64++;/*91*/}\n"
#other
<_Solver_91>	::=	"ps.shrink(i - j);"
<Solver_92>	::=	"{Log_count64++;/*92*/} if" <IF_Solver_92> " \n"
#"if
<IF_Solver_92>	::=	"(ps.size() == 0)"
<Solver_93>	::=	"{\n"
<Solver_94>	::=	"{Log_count64++;/*94*/} return ok = false;\n"
<Solver_95>	::=	"}\n"
<Solver_96>	::=	"else if" <IF_Solver_96> " \n"
#if2
<IF_Solver_96>	::=	"(ps.size() == 1)"
<Solver_97>	::=	"{\n"
<Solver_98>	::=	"" <_Solver_98> "{Log_count64++;/*98*/}\n"
#other
<_Solver_98>	::=	"uncheckedEnqueue(ps[0]);"
<Solver_99>	::=	"{Log_count64++;/*99*/} return ok = (propagate() == CRef_Undef);\n"
<Solver_100>	::=	"}\n"
<Solver_101>	::=	"else\n"
<Solver_102>	::=	"{\n"
<Solver_103>	::=	"CRef cr = ca.alloc(ps, false);\n"
<Solver_104>	::=	"" <_Solver_104> "{Log_count64++;/*104*/}\n"
#other
<_Solver_104>	::=	"clauses.push(cr);"
<Solver_105>	::=	"" <_Solver_105> "{Log_count64++;/*105*/}\n"
#other
<_Solver_105>	::=	"attachClause(cr);"
<Solver_106>	::=	"}\n"
<Solver_107>	::=	"{Log_count64++;/*107*/} return true;\n"
<Solver_108>	::=	"}\n"
<Solver_109>	::=	"void Solver::attachClause(CRef cr)\n"
<Solver_110>	::=	"{\n"
<Solver_111>	::=	"const Clause& c = ca[cr];\n"
<Solver_113>	::=	"" <_Solver_113> "{Log_count64++;/*113*/}\n"
#other
<_Solver_113>	::=	"assert(c.size() > 1);"
<Solver_114>	::=	"" <_Solver_114> "{Log_count64++;/*114*/}\n"
#other
<_Solver_114>	::=	"watches[~c[0]].push(Watcher(cr, c[1]));"
<Solver_115>	::=	"" <_Solver_115> "{Log_count64++;/*115*/}\n"
#other
<_Solver_115>	::=	"watches[~c[1]].push(Watcher(cr, c[0]));"
<Solver_116>	::=	"{Log_count64++;/*116*/} if" <IF_Solver_116> "  learnts_literals += c.size();\n"
#"if
<IF_Solver_116>	::=	"(c.learnt())"
<Solver_117>	::=	"else {" <ELSE_Solver_117> " {Log_count64++;/*117*/}};\n"
#ELSE
<ELSE_Solver_117>	::=	"clauses_literals += c.size();"
<Solver_118>	::=	"}\n"
<Solver_119>	::=	"void Solver::detachClause(CRef cr, bool strict)\n"
<Solver_120>	::=	"{\n"
<Solver_121>	::=	"const Clause& c = ca[cr];\n"
<Solver_123>	::=	"" <_Solver_123> "{Log_count64++;/*123*/}\n"
#other
<_Solver_123>	::=	"assert(c.size() > 1);"
<Solver_124>	::=	"{Log_count64++;/*124*/} if" <IF_Solver_124> " \n"
#"if
<IF_Solver_124>	::=	"(strict)"
<Solver_125>	::=	"{\n"
<Solver_126>	::=	"" <_Solver_126> "{Log_count64++;/*126*/}\n"
#other
<_Solver_126>	::=	"remove(watches[~c[0]], Watcher(cr, c[1]));"
<Solver_127>	::=	"" <_Solver_127> "{Log_count64++;/*127*/}\n"
#other
<_Solver_127>	::=	"remove(watches[~c[1]], Watcher(cr, c[0]));"
<Solver_128>	::=	"}\n"
<Solver_129>	::=	"else\n"
<Solver_130>	::=	"{\n"
<Solver_131>	::=	"" <_Solver_131> "{Log_count64++;/*131*/}\n"
#other
<_Solver_131>	::=	"watches.smudge(~c[0]);"
<Solver_132>	::=	"" <_Solver_132> "{Log_count64++;/*132*/}\n"
#other
<_Solver_132>	::=	"watches.smudge(~c[1]);"
<Solver_133>	::=	"}\n"
<Solver_134>	::=	"{Log_count64++;/*134*/} if" <IF_Solver_134> " \n"
#"if
<IF_Solver_134>	::=	"(c.learnt())"
<Solver_135>	::=	"{\n"
<Solver_136>	::=	"" <_Solver_136> "{Log_count64++;/*136*/}\n"
#other
<_Solver_136>	::=	"learnts_literals -= c.size();"
<Solver_137>	::=	"}\n"
<Solver_138>	::=	"else\n"
<Solver_139>	::=	"{\n"
<Solver_140>	::=	"" <_Solver_140> "{Log_count64++;/*140*/}\n"
#other
<_Solver_140>	::=	"clauses_literals -= c.size();"
<Solver_141>	::=	"}\n"
<Solver_142>	::=	"}\n"
<Solver_143>	::=	"void Solver::removeClause(CRef cr)\n"
<Solver_144>	::=	"{\n"
<Solver_145>	::=	"Clause& c = ca[cr];\n"
<Solver_146>	::=	"" <_Solver_146> "{Log_count64++;/*146*/}\n"
#other
<_Solver_146>	::=	"detachClause(cr);"
<Solver_147>	::=	"{Log_count64++;/*147*/} if" <IF_Solver_147> " \n"
#"if
<IF_Solver_147>	::=	"(locked(c))"
<Solver_148>	::=	"{\n"
<Solver_149>	::=	"" <_Solver_149> "{Log_count64++;/*149*/}\n"
#other
<_Solver_149>	::=	"vardata[var(c[0])].reason = CRef_Undef;"
<Solver_150>	::=	"}\n"
<Solver_151>	::=	"" <_Solver_151> "{Log_count64++;/*151*/}\n"
#other
<_Solver_151>	::=	"c.mark(1);"
<Solver_152>	::=	"" <_Solver_152> "{Log_count64++;/*152*/}\n"
#other
<_Solver_152>	::=	"ca.free(cr);"
<Solver_153>	::=	"}\n"
<Solver_154>	::=	"bool Solver::satisfied(const Clause& c) const\n"
<Solver_155>	::=	"{\n"
<Solver_156>	::=	"for(" <for1_Solver_156> ";" <for2_Solver_156> ";" <for3_Solver_156> ") \n"
<for1_Solver_156>	::=	"int i = 0"
<for2_Solver_156>	::=	"i < c.size()"
<for3_Solver_156>	::=	"i++"
<Solver_157>	::=	"{\n"
<Solver_158>	::=	"{Log_count64++;/*158*/} if" <IF_Solver_158> " \n"
#"if
<IF_Solver_158>	::=	"(value(c[i]) == (lbool((uint8_t)0)))"
<Solver_159>	::=	"{\n"
<Solver_160>	::=	"{Log_count64++;/*160*/} return true;\n"
<Solver_161>	::=	"}\n"
<Solver_162>	::=	"}\n"
<Solver_163>	::=	"{Log_count64++;/*163*/} return false;\n"
<Solver_164>	::=	"}\n"
<Solver_165>	::=	"void Solver::cancelUntil(int level)\n"
<Solver_166>	::=	"{\n"
<Solver_167>	::=	"{Log_count64++;/*167*/} if" <IF_Solver_167> " \n"
#"if
<IF_Solver_167>	::=	"(decisionLevel() > level)"
<Solver_168>	::=	"{\n"
<Solver_169>	::=	"for(" <for1_Solver_169> ";" <for2_Solver_169> ";" <for3_Solver_169> ") \n"
<for1_Solver_169>	::=	"int c = trail.size()-1"
<for2_Solver_169>	::=	"c >= trail_lim[level]"
<for3_Solver_169>	::=	"c--"
<Solver_170>	::=	"{\n"
<Solver_171>	::=	"Var x = var(trail[c]);\n"
<Solver_172>	::=	"" <_Solver_172> "{Log_count64++;/*172*/}\n"
#other
<_Solver_172>	::=	"assigns [x] = (lbool((uint8_t)2));"
<Solver_173>	::=	"{Log_count64++;/*173*/} if" <IF_Solver_173> " \n"
#"if
<IF_Solver_173>	::=	"(phase_saving > 1 || (phase_saving == 1) && c > trail_lim.last())"
<Solver_174>	::=	"{\n"
<Solver_175>	::=	"" <_Solver_175> "{Log_count64++;/*175*/}\n"
#other
<_Solver_175>	::=	"polarity[x] = sign(trail[c]);"
<Solver_176>	::=	"}\n"
<Solver_177>	::=	"" <_Solver_177> "{Log_count64++;/*177*/}\n"
#other
<_Solver_177>	::=	"insertVarOrder(x);"
<Solver_178>	::=	"}\n"
<Solver_179>	::=	"" <_Solver_179> "{Log_count64++;/*179*/}\n"
#other
<_Solver_179>	::=	"qhead = trail_lim[level];"
<Solver_180>	::=	"" <_Solver_180> "{Log_count64++;/*180*/}\n"
#other
<_Solver_180>	::=	"trail.shrink(trail.size() - trail_lim[level]);"
<Solver_181>	::=	"" <_Solver_181> "{Log_count64++;/*181*/}\n"
#other
<_Solver_181>	::=	"trail_lim.shrink(trail_lim.size() - level);"
<Solver_182>	::=	"}\n"
<Solver_183>	::=	"}\n"
<Solver_184>	::=	"Lit Solver::pickBranchLit()\n"
<Solver_185>	::=	"{\n"
<Solver_186>	::=	"Var next = (-1);\n"
<Solver_187>	::=	"{Log_count64++;/*187*/} if" <IF_Solver_187> " \n"
#"if
<IF_Solver_187>	::=	"(drand(random_seed) < random_var_freq && !order_heap.empty())"
<Solver_188>	::=	"{\n"
<Solver_189>	::=	"" <_Solver_189> "{Log_count64++;/*189*/}\n"
#other
<_Solver_189>	::=	"next = order_heap[irand(random_seed,order_heap.size())];"
<Solver_190>	::=	"{Log_count64++;/*190*/} if" <IF_Solver_190> " \n"
#"if
<IF_Solver_190>	::=	"(value(next) == (lbool((uint8_t)2)) && decision[next])"
<Solver_191>	::=	"{\n"
<Solver_192>	::=	"" <_Solver_192> "{Log_count64++;/*192*/}\n"
#other
<_Solver_192>	::=	"rnd_decisions++;"
<Solver_193>	::=	"}\n"
<Solver_194>	::=	"}\n"
<Solver_195>	::=	"while" <WHILE_Solver_195> " \n"
#WHILE
<WHILE_Solver_195>	::=	"(next == (-1) || value(next) != (lbool((uint8_t)2)) || !decision[next])"
<Solver_196>	::=	"{\n"
<Solver_197>	::=	"{Log_count64++;/*197*/} if" <IF_Solver_197> " \n"
#"if
<IF_Solver_197>	::=	"(order_heap.empty())"
<Solver_198>	::=	"{\n"
<Solver_199>	::=	"" <_Solver_199> "{Log_count64++;/*199*/}\n"
#other
<_Solver_199>	::=	"next = (-1);"
<Solver_200>	::=	"{Log_count64++;/*200*/} break;\n"
<Solver_201>	::=	"}\n"
<Solver_202>	::=	"else\n"
<Solver_203>	::=	"{\n"
<Solver_204>	::=	"" <_Solver_204> "{Log_count64++;/*204*/}\n"
#other
<_Solver_204>	::=	"next = order_heap.removeMin();"
<Solver_205>	::=	"}\n"
<Solver_206>	::=	"}\n"
<Solver_207>	::=	"{Log_count64++;/*207*/} return next == (-1) ? lit_Undef : mkLit(next, rnd_pol ? drand(random_seed) < 0.5 : polarity[next]);\n"
<Solver_208>	::=	"}\n"
<Solver_209>	::=	"void Solver::analyze(CRef confl, vec<Lit>& out_learnt, int& out_btlevel)\n"
<Solver_210>	::=	"{\n"
<Solver_211>	::=	"int pathC = 0;\n"
<Solver_212>	::=	"Lit p = lit_Undef;\n"
<Solver_213>	::=	"" <_Solver_213> "{Log_count64++;/*213*/}\n"
#other
<_Solver_213>	::=	"out_learnt.push();"
<Solver_214>	::=	"int index = trail.size() - 1;\n"
<Solver_215>	::=	"do\n"
<Solver_216>	::=	"{\n"
<Solver_218>	::=	"" <_Solver_218> "{Log_count64++;/*218*/}\n"
#other
<_Solver_218>	::=	"assert(confl != CRef_Undef);"
<Solver_219>	::=	"Clause& c = ca[confl];\n"
<Solver_220>	::=	"{Log_count64++;/*220*/} if" <IF_Solver_220> " \n"
#"if
<IF_Solver_220>	::=	"(c.learnt())"
<Solver_221>	::=	"{\n"
<Solver_222>	::=	"" <_Solver_222> "{Log_count64++;/*222*/}\n"
#other
<_Solver_222>	::=	"claBumpActivity(c);"
<Solver_223>	::=	"}\n"
<Solver_224>	::=	"for(" <for1_Solver_224> ";" <for2_Solver_224> ";" <for3_Solver_224> ") \n"
<for1_Solver_224>	::=	"int j = (p == lit_Undef) ? 0 : 1"
<for2_Solver_224>	::=	"j < c.size()"
<for3_Solver_224>	::=	"j++"
<Solver_225>	::=	"{\n"
<Solver_226>	::=	"Lit q = c[j];\n"
<Solver_227>	::=	"{Log_count64++;/*227*/} if" <IF_Solver_227> " \n"
#"if
<IF_Solver_227>	::=	"(!seen[var(q)] && level(var(q)) > 0)"
<Solver_228>	::=	"{\n"
<Solver_229>	::=	"" <_Solver_229> "{Log_count64++;/*229*/}\n"
#other
<_Solver_229>	::=	"varBumpActivity(var(q));"
<Solver_230>	::=	"" <_Solver_230> "{Log_count64++;/*230*/}\n"
#other
<_Solver_230>	::=	"seen[var(q)] = 1;"
<Solver_231>	::=	"{Log_count64++;/*231*/} if" <IF_Solver_231> " \n"
#"if
<IF_Solver_231>	::=	"(level(var(q)) >= decisionLevel())"
<Solver_232>	::=	"{\n"
<Solver_233>	::=	"" <_Solver_233> "{Log_count64++;/*233*/}\n"
#other
<_Solver_233>	::=	"pathC++;"
<Solver_234>	::=	"}\n"
<Solver_235>	::=	"else\n"
<Solver_236>	::=	"{\n"
<Solver_237>	::=	"" <_Solver_237> "{Log_count64++;/*237*/}\n"
#other
<_Solver_237>	::=	"out_learnt.push(q);"
<Solver_238>	::=	"}\n"
<Solver_239>	::=	"}\n"
<Solver_240>	::=	"}\n"
<Solver_241>	::=	"while" <WHILE_Solver_241> " ;\n"
#WHILE
<WHILE_Solver_241>	::=	"(!seen[var(trail[index--])])"
<Solver_242>	::=	"" <_Solver_242> "{Log_count64++;/*242*/}\n"
#other
<_Solver_242>	::=	"p = trail[index+1];"
<Solver_243>	::=	"" <_Solver_243> "{Log_count64++;/*243*/}\n"
#other
<_Solver_243>	::=	"confl = reason(var(p));"
<Solver_244>	::=	"" <_Solver_244> "{Log_count64++;/*244*/}\n"
#other
<_Solver_244>	::=	"seen[var(p)] = 0;"
<Solver_245>	::=	"" <_Solver_245> "{Log_count64++;/*245*/}\n"
#other
<_Solver_245>	::=	"pathC--;"
<Solver_246>	::=	"}\n"
<Solver_247>	::=	"while" <WHILE_Solver_247> " ;\n"
#WHILE
<WHILE_Solver_247>	::=	"(pathC > 0)"
<Solver_248>	::=	"" <_Solver_248> "{Log_count64++;/*248*/}\n"
#other
<_Solver_248>	::=	"out_learnt[0] = ~p;"
<Solver_249>	::=	"int i, j;\n"
<Solver_250>	::=	"" <_Solver_250> "{Log_count64++;/*250*/}\n"
#other
<_Solver_250>	::=	"out_learnt.copyTo(analyze_toclear);"
<Solver_251>	::=	"{Log_count64++;/*251*/} if" <IF_Solver_251> " \n"
#"if
<IF_Solver_251>	::=	"(ccmin_mode == 2)"
<Solver_252>	::=	"{\n"
<Solver_253>	::=	"uint32_t abstract_level = 0;\n"
<Solver_254>	::=	"for(" <for1_Solver_254> ";" <for2_Solver_254> ";" <for3_Solver_254> ") \n"
<for1_Solver_254>	::=	"i = 1"
<for2_Solver_254>	::=	"i < out_learnt.size()"
<for3_Solver_254>	::=	"i++"
<Solver_255>	::=	"{\n"
<Solver_256>	::=	"" <_Solver_256> "{Log_count64++;/*256*/}\n"
#other
<_Solver_256>	::=	"abstract_level |= abstractLevel(var(out_learnt[i]));"
<Solver_257>	::=	"}\n"
<Solver_258>	::=	"for(" <for1_Solver_258> ";" <for2_Solver_258> ";" <for3_Solver_258> ") \n"
<for1_Solver_258>	::=	"i = j = 1"
<for2_Solver_258>	::=	"i < out_learnt.size()"
<for3_Solver_258>	::=	"i++"
<Solver_259>	::=	"{\n"
<Solver_260>	::=	"{Log_count64++;/*260*/} if" <IF_Solver_260> " \n"
#"if
<IF_Solver_260>	::=	"(reason(var(out_learnt[i])) == CRef_Undef || !litRedundant(out_learnt[i], abstract_level))"
<Solver_261>	::=	"{\n"
<Solver_262>	::=	"" <_Solver_262> "{Log_count64++;/*262*/}\n"
#other
<_Solver_262>	::=	"out_learnt[j++] = out_learnt[i];"
<Solver_263>	::=	"}\n"
<Solver_264>	::=	"}\n"
<Solver_265>	::=	"}\n"
<Solver_266>	::=	"else if" <IF_Solver_266> " \n"
#if2
<IF_Solver_266>	::=	"(ccmin_mode == 1)"
<Solver_267>	::=	"{\n"
<Solver_268>	::=	"for(" <for1_Solver_268> ";" <for2_Solver_268> ";" <for3_Solver_268> ") \n"
<for1_Solver_268>	::=	"i = j = 1"
<for2_Solver_268>	::=	"i < out_learnt.size()"
<for3_Solver_268>	::=	"i++"
<Solver_269>	::=	"{\n"
<Solver_270>	::=	"Var x = var(out_learnt[i]);\n"
<Solver_271>	::=	"{Log_count64++;/*271*/} if" <IF_Solver_271> " \n"
#"if
<IF_Solver_271>	::=	"(reason(x) == CRef_Undef)"
<Solver_272>	::=	"{\n"
<Solver_273>	::=	"" <_Solver_273> "{Log_count64++;/*273*/}\n"
#other
<_Solver_273>	::=	"out_learnt[j++] = out_learnt[i];"
<Solver_274>	::=	"}\n"
<Solver_275>	::=	"else\n"
<Solver_276>	::=	"{\n"
<Solver_277>	::=	"Clause& c = ca[reason(var(out_learnt[i]))];\n"
<Solver_278>	::=	"for(" <for1_Solver_278> ";" <for2_Solver_278> ";" <for3_Solver_278> ") \n"
<for1_Solver_278>	::=	"int k = 1"
<for2_Solver_278>	::=	"k < c.size()"
<for3_Solver_278>	::=	"k++"
<Solver_279>	::=	"{\n"
<Solver_280>	::=	"{Log_count64++;/*280*/} if" <IF_Solver_280> " \n"
#"if
<IF_Solver_280>	::=	"(!seen[var(c[k])] && level(var(c[k])) > 0)"
<Solver_281>	::=	"{\n"
<Solver_282>	::=	"" <_Solver_282> "{Log_count64++;/*282*/}\n"
#other
<_Solver_282>	::=	"out_learnt[j++] = out_learnt[i];"
<Solver_283>	::=	"{Log_count64++;/*283*/} break;\n"
<Solver_284>	::=	"}\n"
<Solver_285>	::=	"}\n"
<Solver_286>	::=	"}\n"
<Solver_287>	::=	"}\n"
<Solver_288>	::=	"}\n"
<Solver_289>	::=	"else\n"
<Solver_290>	::=	"{\n"
<Solver_291>	::=	"" <_Solver_291> "{Log_count64++;/*291*/}\n"
#other
<_Solver_291>	::=	"i = j = out_learnt.size();"
<Solver_292>	::=	"}\n"
<Solver_293>	::=	"" <_Solver_293> "{Log_count64++;/*293*/}\n"
#other
<_Solver_293>	::=	"max_literals += out_learnt.size();"
<Solver_294>	::=	"" <_Solver_294> "{Log_count64++;/*294*/}\n"
#other
<_Solver_294>	::=	"out_learnt.shrink(i - j);"
<Solver_295>	::=	"" <_Solver_295> "{Log_count64++;/*295*/}\n"
#other
<_Solver_295>	::=	"tot_literals += out_learnt.size();"
<Solver_296>	::=	"{Log_count64++;/*296*/} if" <IF_Solver_296> " \n"
#"if
<IF_Solver_296>	::=	"(out_learnt.size() == 1)"
<Solver_297>	::=	"{\n"
<Solver_298>	::=	"" <_Solver_298> "{Log_count64++;/*298*/}\n"
#other
<_Solver_298>	::=	"out_btlevel = 0;"
<Solver_299>	::=	"}\n"
<Solver_300>	::=	"else\n"
<Solver_301>	::=	"{\n"
<Solver_302>	::=	"int max_i = 1;\n"
<Solver_303>	::=	"for(" <for1_Solver_303> ";" <for2_Solver_303> ";" <for3_Solver_303> ") \n"
<for1_Solver_303>	::=	"int i = 2"
<for2_Solver_303>	::=	"i < out_learnt.size()"
<for3_Solver_303>	::=	"i++"
<Solver_304>	::=	"{\n"
<Solver_305>	::=	"{Log_count64++;/*305*/} if" <IF_Solver_305> " \n"
#"if
<IF_Solver_305>	::=	"(level(var(out_learnt[i])) > level(var(out_learnt[max_i])))"
<Solver_306>	::=	"{\n"
<Solver_307>	::=	"" <_Solver_307> "{Log_count64++;/*307*/}\n"
#other
<_Solver_307>	::=	"max_i = i;"
<Solver_308>	::=	"}\n"
<Solver_309>	::=	"}\n"
<Solver_310>	::=	"Lit p = out_learnt[max_i];\n"
<Solver_311>	::=	"" <_Solver_311> "{Log_count64++;/*311*/}\n"
#other
<_Solver_311>	::=	"out_learnt[max_i] = out_learnt[1];"
<Solver_312>	::=	"" <_Solver_312> "{Log_count64++;/*312*/}\n"
#other
<_Solver_312>	::=	"out_learnt[1] = p;"
<Solver_313>	::=	"" <_Solver_313> "{Log_count64++;/*313*/}\n"
#other
<_Solver_313>	::=	"out_btlevel = level(var(p));"
<Solver_314>	::=	"}\n"
<Solver_315>	::=	"for(" <for1_Solver_315> ";" <for2_Solver_315> ";" <for3_Solver_315> ") \n"
<for1_Solver_315>	::=	"int j = 0"
<for2_Solver_315>	::=	"j < analyze_toclear.size()"
<for3_Solver_315>	::=	"j++"
<Solver_316>	::=	"{\n"
<Solver_317>	::=	"" <_Solver_317> "{Log_count64++;/*317*/}\n"
#other
<_Solver_317>	::=	"seen[var(analyze_toclear[j])] = 0;"
<Solver_318>	::=	"}\n"
<Solver_319>	::=	"}\n"
<Solver_320>	::=	"bool Solver::litRedundant(Lit p, uint32_t abstract_levels)\n"
<Solver_321>	::=	"{\n"
<Solver_322>	::=	"" <_Solver_322> "{Log_count64++;/*322*/}\n"
#other
<_Solver_322>	::=	"analyze_stack.clear(); analyze_stack.push(p);"
<Solver_323>	::=	"int top = analyze_toclear.size();\n"
<Solver_324>	::=	"while" <WHILE_Solver_324> " \n"
#WHILE
<WHILE_Solver_324>	::=	"(analyze_stack.size() > 0)"
<Solver_325>	::=	"{\n"
<Solver_327>	::=	"" <_Solver_327> "{Log_count64++;/*327*/}\n"
#other
<_Solver_327>	::=	"assert(reason(var(analyze_stack.last())) != CRef_Undef);"
<Solver_328>	::=	"Clause& c = ca[reason(var(analyze_stack.last()))]; analyze_stack.pop();\n"
<Solver_329>	::=	"for(" <for1_Solver_329> ";" <for2_Solver_329> ";" <for3_Solver_329> ") \n"
<for1_Solver_329>	::=	"int i = 1"
<for2_Solver_329>	::=	"i < c.size()"
<for3_Solver_329>	::=	"i++"
<Solver_330>	::=	"{\n"
<Solver_331>	::=	"Lit p = c[i];\n"
<Solver_332>	::=	"{Log_count64++;/*332*/} if" <IF_Solver_332> " \n"
#"if
<IF_Solver_332>	::=	"(!seen[var(p)] && level(var(p)) > 0)"
<Solver_333>	::=	"{\n"
<Solver_334>	::=	"{Log_count64++;/*334*/} if" <IF_Solver_334> " \n"
#"if
<IF_Solver_334>	::=	"(reason(var(p)) != CRef_Undef && (abstractLevel(var(p)) & abstract_levels) != 0)"
<Solver_335>	::=	"{\n"
<Solver_336>	::=	"" <_Solver_336> "{Log_count64++;/*336*/}\n"
#other
<_Solver_336>	::=	"seen[var(p)] = 1;"
<Solver_337>	::=	"" <_Solver_337> "{Log_count64++;/*337*/}\n"
#other
<_Solver_337>	::=	"analyze_stack.push(p);"
<Solver_338>	::=	"" <_Solver_338> "{Log_count64++;/*338*/}\n"
#other
<_Solver_338>	::=	"analyze_toclear.push(p);"
<Solver_339>	::=	"}\n"
<Solver_340>	::=	"else\n"
<Solver_341>	::=	"{\n"
<Solver_342>	::=	"for(" <for1_Solver_342> ";" <for2_Solver_342> ";" <for3_Solver_342> ") \n"
<for1_Solver_342>	::=	"int j = top"
<for2_Solver_342>	::=	"j < analyze_toclear.size()"
<for3_Solver_342>	::=	"j++"
<Solver_343>	::=	"{\n"
<Solver_344>	::=	"" <_Solver_344> "{Log_count64++;/*344*/}\n"
#other
<_Solver_344>	::=	"seen[var(analyze_toclear[j])] = 0;"
<Solver_345>	::=	"}\n"
<Solver_346>	::=	"" <_Solver_346> "{Log_count64++;/*346*/}\n"
#other
<_Solver_346>	::=	"analyze_toclear.shrink(analyze_toclear.size() - top);"
<Solver_347>	::=	"{Log_count64++;/*347*/} return false;\n"
<Solver_348>	::=	"}\n"
<Solver_349>	::=	"}\n"
<Solver_350>	::=	"}\n"
<Solver_351>	::=	"}\n"
<Solver_352>	::=	"{Log_count64++;/*352*/} return true;\n"
<Solver_353>	::=	"}\n"
<Solver_354>	::=	"void Solver::analyzeFinal(Lit p, vec<Lit>& out_conflict)\n"
<Solver_355>	::=	"{\n"
<Solver_356>	::=	"" <_Solver_356> "{Log_count64++;/*356*/}\n"
#other
<_Solver_356>	::=	"out_conflict.clear();"
<Solver_357>	::=	"" <_Solver_357> "{Log_count64++;/*357*/}\n"
#other
<_Solver_357>	::=	"out_conflict.push(p);"
<Solver_358>	::=	"{Log_count64++;/*358*/} if" <IF_Solver_358> " \n"
#"if
<IF_Solver_358>	::=	"(decisionLevel() == 0)"
<Solver_359>	::=	"{\n"
<Solver_360>	::=	"{Log_count64++;/*360*/} return;\n"
<Solver_361>	::=	"}\n"
<Solver_362>	::=	"" <_Solver_362> "{Log_count64++;/*362*/}\n"
#other
<_Solver_362>	::=	"seen[var(p)] = 1;"
<Solver_363>	::=	"for(" <for1_Solver_363> ";" <for2_Solver_363> ";" <for3_Solver_363> ") \n"
<for1_Solver_363>	::=	"int i = trail.size()-1"
<for2_Solver_363>	::=	"i >= trail_lim[0]"
<for3_Solver_363>	::=	"i--"
<Solver_364>	::=	"{\n"
<Solver_365>	::=	"Var x = var(trail[i]);\n"
<Solver_366>	::=	"{Log_count64++;/*366*/} if" <IF_Solver_366> " \n"
#"if
<IF_Solver_366>	::=	"(seen[x])"
<Solver_367>	::=	"{\n"
<Solver_368>	::=	"{Log_count64++;/*368*/} if" <IF_Solver_368> " \n"
#"if
<IF_Solver_368>	::=	"(reason(x) == CRef_Undef)"
<Solver_369>	::=	"{\n"
<Solver_371>	::=	"" <_Solver_371> "{Log_count64++;/*371*/}\n"
#other
<_Solver_371>	::=	"assert(level(x) > 0);"
<Solver_372>	::=	"" <_Solver_372> "{Log_count64++;/*372*/}\n"
#other
<_Solver_372>	::=	"out_conflict.push(~trail[i]);"
<Solver_373>	::=	"}\n"
<Solver_374>	::=	"else\n"
<Solver_375>	::=	"{\n"
<Solver_376>	::=	"Clause& c = ca[reason(x)];\n"
<Solver_377>	::=	"for(" <for1_Solver_377> ";" <for2_Solver_377> ";" <for3_Solver_377> ") \n"
<for1_Solver_377>	::=	"int j = 1"
<for2_Solver_377>	::=	"j < c.size()"
<for3_Solver_377>	::=	"j++"
<Solver_378>	::=	"{\n"
<Solver_379>	::=	"{Log_count64++;/*379*/} if" <IF_Solver_379> " \n"
#"if
<IF_Solver_379>	::=	"(level(var(c[j])) > 0)"
<Solver_380>	::=	"{\n"
<Solver_381>	::=	"" <_Solver_381> "{Log_count64++;/*381*/}\n"
#other
<_Solver_381>	::=	"seen[var(c[j])] = 1;"
<Solver_382>	::=	"}\n"
<Solver_383>	::=	"}\n"
<Solver_384>	::=	"}\n"
<Solver_385>	::=	"" <_Solver_385> "{Log_count64++;/*385*/}\n"
#other
<_Solver_385>	::=	"seen[x] = 0;"
<Solver_386>	::=	"}\n"
<Solver_387>	::=	"}\n"
<Solver_388>	::=	"" <_Solver_388> "{Log_count64++;/*388*/}\n"
#other
<_Solver_388>	::=	"seen[var(p)] = 0;"
<Solver_389>	::=	"}\n"
<Solver_390>	::=	"void Solver::uncheckedEnqueue(Lit p, CRef from)\n"
<Solver_391>	::=	"{\n"
<Solver_393>	::=	"" <_Solver_393> "{Log_count64++;/*393*/}\n"
#other
<_Solver_393>	::=	"assert(value(p) == l_Undef);"
<Solver_394>	::=	"" <_Solver_394> "{Log_count64++;/*394*/}\n"
#other
<_Solver_394>	::=	"assigns[var(p)] = lbool(!sign(p));"
<Solver_395>	::=	"" <_Solver_395> "{Log_count64++;/*395*/}\n"
#other
<_Solver_395>	::=	"vardata[var(p)] = mkVarData(from, decisionLevel());"
<Solver_396>	::=	"" <_Solver_396> "{Log_count64++;/*396*/}\n"
#other
<_Solver_396>	::=	"trail.push_(p);"
<Solver_397>	::=	"}\n"
<Solver_398>	::=	"CRef Solver::propagate()\n"
<Solver_399>	::=	"{\n"
<Solver_400>	::=	"CRef confl = CRef_Undef;\n"
<Solver_401>	::=	"int num_props = 0;\n"
<Solver_402>	::=	"" <_Solver_402> "{Log_count64++;/*402*/}\n"
#other
<_Solver_402>	::=	"watches.cleanAll();"
<Solver_403>	::=	"while" <WHILE_Solver_403> " \n"
#WHILE
<WHILE_Solver_403>	::=	"(qhead < trail.size())"
<Solver_404>	::=	"{\n"
<Solver_405>	::=	"Lit p = trail[qhead++];\n"
<Solver_406>	::=	"vec<Watcher>& ws = watches[p];\n"
<Solver_407>	::=	"Watcher *i, *j, *end;\n"
<Solver_408>	::=	"" <_Solver_408> "{Log_count64++;/*408*/}\n"
#other
<_Solver_408>	::=	"num_props++;"
<Solver_409>	::=	"for(" <for1_Solver_409> ";" <for2_Solver_409> ";" <for3_Solver_409> ") \n"
<for1_Solver_409>	::=	"i = j = (Watcher*)ws, end = i + ws.size()"
<for2_Solver_409>	::=	"i != end"
<for3_Solver_409>	::=	""
<Solver_410>	::=	"{\n"
<Solver_411>	::=	"Lit blocker = i->blocker;\n"
<Solver_412>	::=	"{Log_count64++;/*412*/} if" <IF_Solver_412> " \n"
#"if
<IF_Solver_412>	::=	"(value(blocker) == (lbool((uint8_t)0)))"
<Solver_413>	::=	"{\n"
<Solver_414>	::=	"*j++ = *i++; {Log_count64++;/*414*/} continue;\n"
<Solver_415>	::=	"}\n"
<Solver_416>	::=	"CRef cr = i->cref;\n"
<Solver_417>	::=	"Clause& c = ca[cr];\n"
<Solver_418>	::=	"Lit false_lit = ~p;\n"
<Solver_419>	::=	"{Log_count64++;/*419*/} if" <IF_Solver_419> " \n"
#"if
<IF_Solver_419>	::=	"(c[0] == false_lit)"
<Solver_420>	::=	"{\n"
<Solver_421>	::=	"" <_Solver_421> "{Log_count64++;/*421*/}\n"
#other
<_Solver_421>	::=	"c[0] = c[1], c[1] = false_lit;"
<Solver_422>	::=	"}\n"
<Solver_424>	::=	"" <_Solver_424> "{Log_count64++;/*424*/}\n"
#other
<_Solver_424>	::=	"assert(c[1] == false_lit);"
<Solver_425>	::=	"" <_Solver_425> "{Log_count64++;/*425*/}\n"
#other
<_Solver_425>	::=	"i++;"
<Solver_426>	::=	"Lit first = c[0];\n"
<Solver_427>	::=	"Watcher w = Watcher(cr, first);\n"
<Solver_428>	::=	"{Log_count64++;/*428*/} if" <IF_Solver_428> " \n"
#"if
<IF_Solver_428>	::=	"(first != blocker && value(first) == (lbool((uint8_t)0)))"
<Solver_429>	::=	"{\n"
<Solver_430>	::=	"*j++ = w; {Log_count64++;/*430*/} continue;\n"
<Solver_431>	::=	"}\n"
<Solver_432>	::=	"for(" <for1_Solver_432> ";" <for2_Solver_432> ";" <for3_Solver_432> ") \n"
<for1_Solver_432>	::=	"int k = 2"
<for2_Solver_432>	::=	"k < c.size()"
<for3_Solver_432>	::=	"k++"
<Solver_433>	::=	"if" <IF_Solver_433> " \n"
#"if
<IF_Solver_433>	::=	"(value(c[k]) != (lbool((uint8_t)1)))"
<Solver_434>	::=	"{{Log_count64++;/*433*/} \n"
<Solver_435>	::=	"" <_Solver_435> "{Log_count64++;/*435*/}\n"
#other
<_Solver_435>	::=	"c[1] = c[k]; c[k] = false_lit;"
<Solver_436>	::=	"" <_Solver_436> "{Log_count64++;/*436*/}\n"
#other
<_Solver_436>	::=	"watches[~c[1]].push(w);"
<Solver_437>	::=	"" <_Solver_437> "{Log_count64++;/*437*/}\n"
#other
<_Solver_437>	::=	"goto NextClause;"
<Solver_438>	::=	"}\n"
<Solver_439>	::=	"" <_Solver_439> "{Log_count64++;/*439*/}\n"
#other
<_Solver_439>	::=	"*j++ = w;"
<Solver_440>	::=	"{Log_count64++;/*440*/} if" <IF_Solver_440> " \n"
#"if
<IF_Solver_440>	::=	"(value(first) == (lbool((uint8_t)1)))"
<Solver_441>	::=	"{\n"
<Solver_442>	::=	"" <_Solver_442> "{Log_count64++;/*442*/}\n"
#other
<_Solver_442>	::=	"confl = cr;"
<Solver_443>	::=	"" <_Solver_443> "{Log_count64++;/*443*/}\n"
#other
<_Solver_443>	::=	"qhead = trail.size();"
<Solver_444>	::=	"while" <WHILE_Solver_444> " \n"
#WHILE
<WHILE_Solver_444>	::=	"(i < end)"
<Solver_445>	::=	"" <_Solver_445> "{Log_count64++;/*445*/}\n"
#other
<_Solver_445>	::=	"*j++ = *i++;"
<Solver_446>	::=	"}\n"
<Solver_447>	::=	"else\n"
<Solver_448>	::=	"{\n"
<Solver_449>	::=	"" <_Solver_449> "{Log_count64++;/*449*/}\n"
#other
<_Solver_449>	::=	"uncheckedEnqueue(first, cr);"
<Solver_450>	::=	"}\n"
<Solver_451>	::=	"" <_Solver_451> "{Log_count64++;/*451*/}\n"
#other
<_Solver_451>	::=	"NextClause:;"
<Solver_452>	::=	"}\n"
<Solver_453>	::=	"" <_Solver_453> "{Log_count64++;/*453*/}\n"
#other
<_Solver_453>	::=	"ws.shrink(i - j);"
<Solver_454>	::=	"}\n"
<Solver_455>	::=	"" <_Solver_455> "{Log_count64++;/*455*/}\n"
#other
<_Solver_455>	::=	"propagations += num_props;"
<Solver_456>	::=	"" <_Solver_456> "{Log_count64++;/*456*/}\n"
#other
<_Solver_456>	::=	"simpDB_props -= num_props;"
<Solver_457>	::=	"{Log_count64++;/*457*/} return confl;\n"
<Solver_458>	::=	"}\n"
<Solver_459>	::=	"struct reduceDB_lt\n"
<Solver_460>	::=	"{\n"
<Solver_461>	::=	"ClauseAllocator& ca;\n"
<Solver_462>	::=	"reduceDB_lt(ClauseAllocator& ca_) : ca(ca_)\n"
<Solver_463>	::=	"{\n"
<Solver_464>	::=	"}\n"
<Solver_465>	::=	"bool operator () (CRef x, CRef y)\n"
<Solver_466>	::=	"{\n"
<Solver_467>	::=	"{Log_count64++;/*467*/} return ca[x].size() > 2 && (ca[y].size() == 2 || ca[x].activity() < ca[y].activity());\n"
<Solver_468>	::=	"}\n"
<Solver_469>	::=	"}\n"
<Solver_470>	::=	";\n"
<Solver_471>	::=	"void Solver::reduceDB()\n"
<Solver_472>	::=	"{\n"
<Solver_473>	::=	"int i, j;\n"
<Solver_474>	::=	"double extra_lim = cla_inc / learnts.size();\n"
<Solver_475>	::=	"" <_Solver_475> "{Log_count64++;/*475*/}\n"
#other
<_Solver_475>	::=	"sort(learnts, reduceDB_lt(ca));"
<Solver_476>	::=	"for(" <for1_Solver_476> ";" <for2_Solver_476> ";" <for3_Solver_476> ") \n"
<for1_Solver_476>	::=	"i = j = 0"
<for2_Solver_476>	::=	"i < learnts.size()"
<for3_Solver_476>	::=	"i++"
<Solver_477>	::=	"{\n"
<Solver_478>	::=	"Clause& c = ca[learnts[i]];\n"
<Solver_479>	::=	"{Log_count64++;/*479*/} if" <IF_Solver_479> " \n"
#"if
<IF_Solver_479>	::=	"(c.size() > 2 && !locked(c) && (i < learnts.size() / 2 || c.activity() < extra_lim))"
<Solver_480>	::=	"{\n"
<Solver_481>	::=	"" <_Solver_481> "{Log_count64++;/*481*/}\n"
#other
<_Solver_481>	::=	"removeClause(learnts[i]);"
<Solver_482>	::=	"}\n"
<Solver_483>	::=	"else\n"
<Solver_484>	::=	"{\n"
<Solver_485>	::=	"" <_Solver_485> "{Log_count64++;/*485*/}\n"
#other
<_Solver_485>	::=	"learnts[j++] = learnts[i];"
<Solver_486>	::=	"}\n"
<Solver_487>	::=	"}\n"
<Solver_488>	::=	"" <_Solver_488> "{Log_count64++;/*488*/}\n"
#other
<_Solver_488>	::=	"learnts.shrink(i - j);"
<Solver_489>	::=	"" <_Solver_489> "{Log_count64++;/*489*/}\n"
#other
<_Solver_489>	::=	"checkGarbage();"
<Solver_490>	::=	"}\n"
<Solver_491>	::=	"void Solver::removeSatisfied(vec<CRef>& cs)\n"
<Solver_492>	::=	"{\n"
<Solver_493>	::=	"int i, j;\n"
<Solver_494>	::=	"for(" <for1_Solver_494> ";" <for2_Solver_494> ";" <for3_Solver_494> ") \n"
<for1_Solver_494>	::=	"i = j = 0"
<for2_Solver_494>	::=	"i < cs.size()"
<for3_Solver_494>	::=	"i++"
<Solver_495>	::=	"{\n"
<Solver_496>	::=	"Clause& c = ca[cs[i]];\n"
<Solver_497>	::=	"{Log_count64++;/*497*/} if" <IF_Solver_497> " \n"
#"if
<IF_Solver_497>	::=	"(satisfied(c))"
<Solver_498>	::=	"{\n"
<Solver_499>	::=	"" <_Solver_499> "{Log_count64++;/*499*/}\n"
#other
<_Solver_499>	::=	"removeClause(cs[i]);"
<Solver_500>	::=	"}\n"
<Solver_501>	::=	"else\n"
<Solver_502>	::=	"{\n"
<Solver_503>	::=	"" <_Solver_503> "{Log_count64++;/*503*/}\n"
#other
<_Solver_503>	::=	"cs[j++] = cs[i];"
<Solver_504>	::=	"}\n"
<Solver_505>	::=	"}\n"
<Solver_506>	::=	"" <_Solver_506> "{Log_count64++;/*506*/}\n"
#other
<_Solver_506>	::=	"cs.shrink(i - j);"
<Solver_507>	::=	"}\n"
<Solver_508>	::=	"void Solver::rebuildOrderHeap()\n"
<Solver_509>	::=	"{\n"
<Solver_510>	::=	"vec<Var> vs;\n"
<Solver_511>	::=	"for(" <for1_Solver_511> ";" <for2_Solver_511> ";" <for3_Solver_511> ") \n"
<for1_Solver_511>	::=	"Var v = 0"
<for2_Solver_511>	::=	"v < nVars()"
<for3_Solver_511>	::=	"v++"
<Solver_512>	::=	"{\n"
<Solver_513>	::=	"{Log_count64++;/*513*/} if" <IF_Solver_513> " \n"
#"if
<IF_Solver_513>	::=	"(decision[v] && value(v) == (lbool((uint8_t)2)))"
<Solver_514>	::=	"{\n"
<Solver_515>	::=	"" <_Solver_515> "{Log_count64++;/*515*/}\n"
#other
<_Solver_515>	::=	"vs.push(v);"
<Solver_516>	::=	"}\n"
<Solver_517>	::=	"}\n"
<Solver_518>	::=	"" <_Solver_518> "{Log_count64++;/*518*/}\n"
#other
<_Solver_518>	::=	"order_heap.build(vs);"
<Solver_519>	::=	"}\n"
<Solver_520>	::=	"bool Solver::simplify()\n"
<Solver_521>	::=	"{\n"
<Solver_523>	::=	"" <_Solver_523> "{Log_count64++;/*523*/}\n"
#other
<_Solver_523>	::=	"assert(decisionLevel() == 0);"
<Solver_524>	::=	"{Log_count64++;/*524*/} if" <IF_Solver_524> " \n"
#"if
<IF_Solver_524>	::=	"(!ok || propagate() != CRef_Undef)"
<Solver_525>	::=	"{\n"
<Solver_526>	::=	"{Log_count64++;/*526*/} return ok = false;\n"
<Solver_527>	::=	"}\n"
<Solver_528>	::=	"{Log_count64++;/*528*/} if" <IF_Solver_528> " \n"
#"if
<IF_Solver_528>	::=	"(nAssigns() == simpDB_assigns || (simpDB_props > 0))"
<Solver_529>	::=	"{\n"
<Solver_530>	::=	"{Log_count64++;/*530*/} return true;\n"
<Solver_531>	::=	"}\n"
<Solver_532>	::=	"" <_Solver_532> "{Log_count64++;/*532*/}\n"
#other
<_Solver_532>	::=	"removeSatisfied(learnts);"
<Solver_533>	::=	"{Log_count64++;/*533*/} if" <IF_Solver_533> " \n"
#"if
<IF_Solver_533>	::=	"(remove_satisfied)"
<Solver_534>	::=	"{\n"
<Solver_535>	::=	"" <_Solver_535> "{Log_count64++;/*535*/}\n"
#other
<_Solver_535>	::=	"removeSatisfied(clauses);"
<Solver_536>	::=	"}\n"
<Solver_537>	::=	"" <_Solver_537> "{Log_count64++;/*537*/}\n"
#other
<_Solver_537>	::=	"checkGarbage();"
<Solver_538>	::=	"" <_Solver_538> "{Log_count64++;/*538*/}\n"
#other
<_Solver_538>	::=	"rebuildOrderHeap();"
<Solver_539>	::=	"" <_Solver_539> "{Log_count64++;/*539*/}\n"
#other
<_Solver_539>	::=	"simpDB_assigns = nAssigns();"
<Solver_540>	::=	"" <_Solver_540> "{Log_count64++;/*540*/}\n"
#other
<_Solver_540>	::=	"simpDB_props = clauses_literals + learnts_literals;"
<Solver_541>	::=	"{Log_count64++;/*541*/} return true;\n"
<Solver_542>	::=	"}\n"
<Solver_543>	::=	"lbool Solver::search(int nof_conflicts)\n"
<Solver_544>	::=	"{\n"
<Solver_546>	::=	"" <_Solver_546> "{Log_count64++;/*546*/}\n"
#other
<_Solver_546>	::=	"assert(ok);"
<Solver_547>	::=	"int backtrack_level;\n"
<Solver_548>	::=	"int conflictC = 0;\n"
<Solver_549>	::=	"vec<Lit> learnt_clause;\n"
<Solver_550>	::=	"" <_Solver_550> "{Log_count64++;/*550*/}\n"
#other
<_Solver_550>	::=	"starts++;"
<Solver_551>	::=	"for(" <for1_Solver_551> ";" <for2_Solver_551> ";" <for3_Solver_551> ") \n"
<for1_Solver_551>	::=	""
<for2_Solver_551>	::=	""
<for3_Solver_551>	::=	""
<Solver_552>	::=	"{\n"
<Solver_553>	::=	"CRef confl = propagate();\n"
<Solver_554>	::=	"{Log_count64++;/*554*/} if" <IF_Solver_554> " \n"
#"if
<IF_Solver_554>	::=	"(confl != CRef_Undef)"
<Solver_555>	::=	"{\n"
<Solver_556>	::=	"" <_Solver_556> "{Log_count64++;/*556*/}\n"
#other
<_Solver_556>	::=	"conflicts++; conflictC++;"
<Solver_557>	::=	"{Log_count64++;/*557*/} if" <IF_Solver_557> " \n"
#"if
<IF_Solver_557>	::=	"(decisionLevel() == 0)"
<Solver_558>	::=	"{\n"
<Solver_559>	::=	"{Log_count64++;/*559*/} return (lbool((uint8_t)1));\n"
<Solver_560>	::=	"}\n"
<Solver_561>	::=	"" <_Solver_561> "{Log_count64++;/*561*/}\n"
#other
<_Solver_561>	::=	"learnt_clause.clear();"
<Solver_562>	::=	"" <_Solver_562> "{Log_count64++;/*562*/}\n"
#other
<_Solver_562>	::=	"analyze(confl, learnt_clause, backtrack_level);"
<Solver_563>	::=	"" <_Solver_563> "{Log_count64++;/*563*/}\n"
#other
<_Solver_563>	::=	"cancelUntil(backtrack_level);"
<Solver_564>	::=	"{Log_count64++;/*564*/} if" <IF_Solver_564> " \n"
#"if
<IF_Solver_564>	::=	"(learnt_clause.size() == 1)"
<Solver_565>	::=	"{\n"
<Solver_566>	::=	"" <_Solver_566> "{Log_count64++;/*566*/}\n"
#other
<_Solver_566>	::=	"uncheckedEnqueue(learnt_clause[0]);"
<Solver_567>	::=	"}\n"
<Solver_568>	::=	"else\n"
<Solver_569>	::=	"{\n"
<Solver_570>	::=	"CRef cr = ca.alloc(learnt_clause, true);\n"
<Solver_571>	::=	"" <_Solver_571> "{Log_count64++;/*571*/}\n"
#other
<_Solver_571>	::=	"learnts.push(cr);"
<Solver_572>	::=	"" <_Solver_572> "{Log_count64++;/*572*/}\n"
#other
<_Solver_572>	::=	"attachClause(cr);"
<Solver_573>	::=	"" <_Solver_573> "{Log_count64++;/*573*/}\n"
#other
<_Solver_573>	::=	"claBumpActivity(ca[cr]);"
<Solver_574>	::=	"" <_Solver_574> "{Log_count64++;/*574*/}\n"
#other
<_Solver_574>	::=	"uncheckedEnqueue(learnt_clause[0], cr);"
<Solver_575>	::=	"}\n"
<Solver_576>	::=	"" <_Solver_576> "{Log_count64++;/*576*/}\n"
#other
<_Solver_576>	::=	"varDecayActivity();"
<Solver_577>	::=	"" <_Solver_577> "{Log_count64++;/*577*/}\n"
#other
<_Solver_577>	::=	"claDecayActivity();"
<Solver_578>	::=	"{Log_count64++;/*578*/} if" <IF_Solver_578> " \n"
#"if
<IF_Solver_578>	::=	"(--learntsize_adjust_cnt == 0)"
<Solver_579>	::=	"{\n"
<Solver_580>	::=	"" <_Solver_580> "{Log_count64++;/*580*/}\n"
#other
<_Solver_580>	::=	"learntsize_adjust_confl *= learntsize_adjust_inc;"
<Solver_581>	::=	"" <_Solver_581> "{Log_count64++;/*581*/}\n"
#other
<_Solver_581>	::=	"learntsize_adjust_cnt = (int)learntsize_adjust_confl;"
<Solver_582>	::=	"" <_Solver_582> "{Log_count64++;/*582*/}\n"
#other
<_Solver_582>	::=	"max_learnts *= learntsize_inc;"
<Solver_583>	::=	"{Log_count64++;/*583*/} if" <IF_Solver_583> " \n"
#"if
<IF_Solver_583>	::=	"(verbosity >= 1)"
<Solver_584>	::=	"{\n"
<Solver_585>	::=	"printf(\"| %9d | %7d %8d %8d | %8d %8d %6.0f | %6.3f %% |\n\",\n"
<Solver_586>	::=	"(int)conflicts,\n"
<Solver_587>	::=	"(int)dec_vars - (trail_lim.size() == 0 ? trail.size() : trail_lim[0]), nClauses(), (int)clauses_literals,\n"
<Solver_588>	::=	"(int)max_learnts, nLearnts(), (double)learnts_literals/nLearnts(), progressEstimate()*100);\n"
<Solver_589>	::=	"}\n"
<Solver_590>	::=	"}\n"
<Solver_591>	::=	"}\n"
<Solver_592>	::=	"else\n"
<Solver_593>	::=	"{\n"
<Solver_594>	::=	"{Log_count64++;/*594*/} if" <IF_Solver_594> " \n"
#"if
<IF_Solver_594>	::=	"(nof_conflicts >= 0 && conflictC >= nof_conflicts || !withinBudget())"
<Solver_595>	::=	"{\n"
<Solver_596>	::=	"" <_Solver_596> "{Log_count64++;/*596*/}\n"
#other
<_Solver_596>	::=	"progress_estimate = progressEstimate();"
<Solver_597>	::=	"" <_Solver_597> "{Log_count64++;/*597*/}\n"
#other
<_Solver_597>	::=	"cancelUntil(0);"
<Solver_598>	::=	"{Log_count64++;/*598*/} return (lbool((uint8_t)2));\n"
<Solver_599>	::=	"}\n"
<Solver_600>	::=	"{Log_count64++;/*600*/} if" <IF_Solver_600> " \n"
#"if
<IF_Solver_600>	::=	"(decisionLevel() == 0 && !simplify())"
<Solver_601>	::=	"{\n"
<Solver_602>	::=	"{Log_count64++;/*602*/} return (lbool((uint8_t)1));\n"
<Solver_603>	::=	"}\n"
<Solver_604>	::=	"{Log_count64++;/*604*/} if" <IF_Solver_604> " \n"
#"if
<IF_Solver_604>	::=	"(learnts.size()-nAssigns() >= max_learnts)"
<Solver_605>	::=	"{\n"
<Solver_606>	::=	"" <_Solver_606> "{Log_count64++;/*606*/}\n"
#other
<_Solver_606>	::=	"reduceDB();"
<Solver_607>	::=	"}\n"
<Solver_608>	::=	"Lit next = lit_Undef;\n"
<Solver_609>	::=	"while" <WHILE_Solver_609> " \n"
#WHILE
<WHILE_Solver_609>	::=	"(decisionLevel() < assumptions.size())"
<Solver_610>	::=	"{\n"
<Solver_611>	::=	"Lit p = assumptions[decisionLevel()];\n"
<Solver_612>	::=	"{Log_count64++;/*612*/} if" <IF_Solver_612> " \n"
#"if
<IF_Solver_612>	::=	"(value(p) == (lbool((uint8_t)0)))"
<Solver_613>	::=	"{\n"
<Solver_614>	::=	"" <_Solver_614> "{Log_count64++;/*614*/}\n"
#other
<_Solver_614>	::=	"newDecisionLevel();"
<Solver_615>	::=	"}\n"
<Solver_616>	::=	"else if" <IF_Solver_616> " \n"
#if2
<IF_Solver_616>	::=	"(value(p) == (lbool((uint8_t)1)))"
<Solver_617>	::=	"{\n"
<Solver_618>	::=	"" <_Solver_618> "{Log_count64++;/*618*/}\n"
#other
<_Solver_618>	::=	"analyzeFinal(~p, conflict);"
<Solver_619>	::=	"{Log_count64++;/*619*/} return (lbool((uint8_t)1));\n"
<Solver_620>	::=	"}\n"
<Solver_621>	::=	"else\n"
<Solver_622>	::=	"{\n"
<Solver_623>	::=	"" <_Solver_623> "{Log_count64++;/*623*/}\n"
#other
<_Solver_623>	::=	"next = p;"
<Solver_624>	::=	"{Log_count64++;/*624*/} break;\n"
<Solver_625>	::=	"}\n"
<Solver_626>	::=	"}\n"
<Solver_627>	::=	"{Log_count64++;/*627*/} if" <IF_Solver_627> " \n"
#"if
<IF_Solver_627>	::=	"(next == lit_Undef)"
<Solver_628>	::=	"{\n"
<Solver_629>	::=	"" <_Solver_629> "{Log_count64++;/*629*/}\n"
#other
<_Solver_629>	::=	"decisions++;"
<Solver_630>	::=	"" <_Solver_630> "{Log_count64++;/*630*/}\n"
#other
<_Solver_630>	::=	"next = pickBranchLit();"
<Solver_631>	::=	"{Log_count64++;/*631*/} if" <IF_Solver_631> " \n"
#"if
<IF_Solver_631>	::=	"(next == lit_Undef)"
<Solver_632>	::=	"{\n"
<Solver_633>	::=	"{Log_count64++;/*633*/} return (lbool((uint8_t)0));\n"
<Solver_634>	::=	"}\n"
<Solver_635>	::=	"}\n"
<Solver_636>	::=	"" <_Solver_636> "{Log_count64++;/*636*/}\n"
#other
<_Solver_636>	::=	"newDecisionLevel();"
<Solver_637>	::=	"" <_Solver_637> "{Log_count64++;/*637*/}\n"
#other
<_Solver_637>	::=	"uncheckedEnqueue(next);"
<Solver_638>	::=	"}\n"
<Solver_639>	::=	"}\n"
<Solver_640>	::=	"}\n"
<Solver_641>	::=	"double Solver::progressEstimate() const\n"
<Solver_642>	::=	"{\n"
<Solver_643>	::=	"double progress = 0;\n"
<Solver_644>	::=	"double F = 1.0 / nVars();\n"
<Solver_645>	::=	"for(" <for1_Solver_645> ";" <for2_Solver_645> ";" <for3_Solver_645> ") \n"
<for1_Solver_645>	::=	"int i = 0"
<for2_Solver_645>	::=	"i <= decisionLevel()"
<for3_Solver_645>	::=	"i++"
<Solver_646>	::=	"{\n"
<Solver_647>	::=	"int beg = i == 0 ? 0 : trail_lim[i - 1];\n"
<Solver_648>	::=	"int end = i == decisionLevel() ? trail.size() : trail_lim[i];\n"
<Solver_649>	::=	"" <_Solver_649> "{Log_count64++;/*649*/}\n"
#other
<_Solver_649>	::=	"progress += pow(F, i) * (end - beg);"
<Solver_650>	::=	"}\n"
<Solver_651>	::=	"{Log_count64++;/*651*/} return progress / nVars();\n"
<Solver_652>	::=	"}\n"
<Solver_653>	::=	"static double luby(double y, int x)\n"
<Solver_654>	::=	"{\n"
<Solver_655>	::=	"int size, seq;\n"
<Solver_656>	::=	"for(" <for1_Solver_656> ";" <for2_Solver_656> ";" <for3_Solver_656> ") ;\n"
<for1_Solver_656>	::=	"size = 1, seq = 0"
<for2_Solver_656>	::=	"size < x+1"
<for3_Solver_656>	::=	"seq++, size = 2*size+1"
<Solver_657>	::=	"while" <WHILE_Solver_657> " \n"
#WHILE
<WHILE_Solver_657>	::=	"(size-1 != x)"
<Solver_658>	::=	"{\n"
<Solver_659>	::=	"" <_Solver_659> "{Log_count64++;/*659*/}\n"
#other
<_Solver_659>	::=	"size = (size-1)>>1;"
<Solver_660>	::=	"" <_Solver_660> "{Log_count64++;/*660*/}\n"
#other
<_Solver_660>	::=	"seq--;"
<Solver_661>	::=	"" <_Solver_661> "{Log_count64++;/*661*/}\n"
#other
<_Solver_661>	::=	"x = x % size;"
<Solver_662>	::=	"}\n"
<Solver_663>	::=	"{Log_count64++;/*663*/} return pow(y, seq);\n"
<Solver_664>	::=	"}\n"
<Solver_665>	::=	"lbool Solver::solve_()\n"
<Solver_666>	::=	"{\n"
<Solver_667>	::=	"" <_Solver_667> "{Log_count64++;/*667*/}\n"
#other
<_Solver_667>	::=	"model.clear();"
<Solver_668>	::=	"" <_Solver_668> "{Log_count64++;/*668*/}\n"
#other
<_Solver_668>	::=	"conflict.clear();"
<Solver_669>	::=	"{Log_count64++;/*669*/} if" <IF_Solver_669> "  return (lbool((uint8_t)1));\n"
#"if
<IF_Solver_669>	::=	"(!ok)"
<Solver_670>	::=	"" <_Solver_670> "{Log_count64++;/*670*/}\n"
#other
<_Solver_670>	::=	"solves++;"
<Solver_671>	::=	"" <_Solver_671> "{Log_count64++;/*671*/}\n"
#other
<_Solver_671>	::=	"max_learnts = nClauses() * learntsize_factor;"
<Solver_672>	::=	"" <_Solver_672> "{Log_count64++;/*672*/}\n"
#other
<_Solver_672>	::=	"learntsize_adjust_confl = learntsize_adjust_start_confl;"
<Solver_673>	::=	"" <_Solver_673> "{Log_count64++;/*673*/}\n"
#other
<_Solver_673>	::=	"learntsize_adjust_cnt = (int)learntsize_adjust_confl;"
<Solver_674>	::=	"lbool status = (lbool((uint8_t)2));\n"
<Solver_675>	::=	"{Log_count64++;/*675*/} if" <IF_Solver_675> " \n"
#"if
<IF_Solver_675>	::=	"(verbosity >= 1)"
<Solver_676>	::=	"{\n"
<Solver_677>	::=	"" <_Solver_677> "{Log_count64++;/*677*/}\n"
#other
<_Solver_677>	::=	"printf(\"============================[ Search Statistics ]==============================\n\");"
<Solver_678>	::=	"" <_Solver_678> "{Log_count64++;/*678*/}\n"
#other
<_Solver_678>	::=	"printf(\"| Conflicts | ORIGINAL | LEARNT | Progress |\n\");"
<Solver_679>	::=	"" <_Solver_679> "{Log_count64++;/*679*/}\n"
#other
<_Solver_679>	::=	"printf(\"| | Vars Clauses Literals | Limit Clauses Lit/Cl | |\n\");"
<Solver_680>	::=	"" <_Solver_680> "{Log_count64++;/*680*/}\n"
#other
<_Solver_680>	::=	"printf(\"===============================================================================\n\");"
<Solver_681>	::=	"}\n"
<Solver_682>	::=	"int curr_restarts = 0;\n"
<Solver_683>	::=	"while" <WHILE_Solver_683> " \n"
#WHILE
<WHILE_Solver_683>	::=	"(status == (lbool((uint8_t)2)))"
<Solver_684>	::=	"{\n"
<Solver_685>	::=	"double rest_base = luby_restart ? luby(restart_inc, curr_restarts) : pow(restart_inc, curr_restarts);\n"
<Solver_686>	::=	"" <_Solver_686> "{Log_count64++;/*686*/}\n"
#other
<_Solver_686>	::=	"status = search(rest_base * restart_first);"
<Solver_687>	::=	"{Log_count64++;/*687*/} if" <IF_Solver_687> "  break;\n"
#"if
<IF_Solver_687>	::=	"(!withinBudget())"
<Solver_688>	::=	"" <_Solver_688> "{Log_count64++;/*688*/}\n"
#other
<_Solver_688>	::=	"curr_restarts++;"
<Solver_689>	::=	"}\n"
<Solver_690>	::=	"{Log_count64++;/*690*/} if" <IF_Solver_690> " \n"
#"if
<IF_Solver_690>	::=	"(verbosity >= 1)"
<Solver_691>	::=	"{\n"
<Solver_692>	::=	"" <_Solver_692> "{Log_count64++;/*692*/}\n"
#other
<_Solver_692>	::=	"printf(\"===============================================================================\n\");"
<Solver_693>	::=	"}\n"
<Solver_694>	::=	"{Log_count64++;/*694*/} if" <IF_Solver_694> " \n"
#"if
<IF_Solver_694>	::=	"(status == (lbool((uint8_t)0)))"
<Solver_695>	::=	"{\n"
<Solver_696>	::=	"" <_Solver_696> "{Log_count64++;/*696*/}\n"
#other
<_Solver_696>	::=	"model.growTo(nVars());"
<Solver_697>	::=	"for(" <for1_Solver_697> ";" <for2_Solver_697> ";" <for3_Solver_697> ")  model[i] = value(i);\n"
<for1_Solver_697>	::=	"int i = 0"
<for2_Solver_697>	::=	"i < nVars()"
<for3_Solver_697>	::=	"i++"
<Solver_698>	::=	"}\n"
<Solver_699>	::=	"else if" <IF_Solver_699> " \n"
#if2
<IF_Solver_699>	::=	"(status == (lbool((uint8_t)1)) && conflict.size() == 0)"
<Solver_700>	::=	"{\n"
<Solver_701>	::=	"" <_Solver_701> "{Log_count64++;/*701*/}\n"
#other
<_Solver_701>	::=	"ok = false;"
<Solver_702>	::=	"}\n"
<Solver_703>	::=	"" <_Solver_703> "{Log_count64++;/*703*/}\n"
#other
<_Solver_703>	::=	"cancelUntil(0);"
<Solver_704>	::=	"{Log_count64++;/*704*/} return status;\n"
<Solver_705>	::=	"}\n"
<Solver_706>	::=	"static Var mapVar(Var x, vec<Var>& map, Var& max)\n"
<Solver_707>	::=	"{\n"
<Solver_708>	::=	"{Log_count64++;/*708*/} if" <IF_Solver_708> " \n"
#"if
<IF_Solver_708>	::=	"(map.size() <= x || map[x] == -1)"
<Solver_709>	::=	"{\n"
<Solver_710>	::=	"" <_Solver_710> "{Log_count64++;/*710*/}\n"
#other
<_Solver_710>	::=	"map.growTo(x+1, -1);"
<Solver_711>	::=	"" <_Solver_711> "{Log_count64++;/*711*/}\n"
#other
<_Solver_711>	::=	"map[x] = max++;"
<Solver_712>	::=	"}\n"
<Solver_713>	::=	"{Log_count64++;/*713*/} return map[x];\n"
<Solver_714>	::=	"}\n"
<Solver_715>	::=	"void Solver::toDimacs(FILE* f, Clause& c, vec<Var>& map, Var& max)\n"
<Solver_716>	::=	"{\n"
<Solver_717>	::=	"{Log_count64++;/*717*/} if" <IF_Solver_717> " \n"
#"if
<IF_Solver_717>	::=	"(satisfied(c))"
<Solver_718>	::=	"{\n"
<Solver_719>	::=	"{Log_count64++;/*719*/} return;\n"
<Solver_720>	::=	"}\n"
<Solver_721>	::=	"for(" <for1_Solver_721> ";" <for2_Solver_721> ";" <for3_Solver_721> ") \n"
<for1_Solver_721>	::=	"int i = 0"
<for2_Solver_721>	::=	"i < c.size()"
<for3_Solver_721>	::=	"i++"
<Solver_722>	::=	"{\n"
<Solver_723>	::=	"{Log_count64++;/*723*/} if" <IF_Solver_723> " \n"
#"if
<IF_Solver_723>	::=	"(value(c[i]) != (lbool((uint8_t)1)))"
<Solver_724>	::=	"{\n"
<Solver_725>	::=	"" <_Solver_725> "{Log_count64++;/*725*/}\n"
#other
<_Solver_725>	::=	"fprintf(f, \"%s%d \", sign(c[i]) ? \"-\" : \"\", mapVar(var(c[i]), map, max)+1);"
<Solver_726>	::=	"}\n"
<Solver_727>	::=	"}\n"
<Solver_728>	::=	"" <_Solver_728> "{Log_count64++;/*728*/}\n"
#other
<_Solver_728>	::=	"fprintf(f, \"0\n\");"
<Solver_729>	::=	"}\n"
<Solver_730>	::=	"void Solver::toDimacs(const char *file, const vec<Lit>& assumps)\n"
<Solver_731>	::=	"{\n"
<Solver_732>	::=	"FILE* f = fopen(file, \"wr\");\n"
<Solver_733>	::=	"{Log_count64++;/*733*/} if" <IF_Solver_733> " \n"
#"if
<IF_Solver_733>	::=	"(f == __null)"
<Solver_734>	::=	"{\n"
<Solver_735>	::=	"" <_Solver_735> "{Log_count64++;/*735*/}\n"
#other
<_Solver_735>	::=	"fprintf( stderr , \"could not open file %s\n\", file), exit(1);"
<Solver_736>	::=	"}\n"
<Solver_737>	::=	"" <_Solver_737> "{Log_count64++;/*737*/}\n"
#other
<_Solver_737>	::=	"toDimacs(f, assumps);"
<Solver_738>	::=	"" <_Solver_738> "{Log_count64++;/*738*/}\n"
#other
<_Solver_738>	::=	"fclose(f);"
<Solver_739>	::=	"}\n"
<Solver_740>	::=	"void Solver::toDimacs(FILE* f, const vec<Lit>& assumps)\n"
<Solver_741>	::=	"{\n"
<Solver_742>	::=	"{Log_count64++;/*742*/} if" <IF_Solver_742> " \n"
#"if
<IF_Solver_742>	::=	"(!ok)"
<Solver_743>	::=	"{\n"
<Solver_744>	::=	"" <_Solver_744> "{Log_count64++;/*744*/}\n"
#other
<_Solver_744>	::=	"fprintf(f, \"p cnf 1 2\n1 0\n-1 0\n\");"
<Solver_745>	::=	"{Log_count64++;/*745*/} return;\n"
<Solver_746>	::=	"}\n"
<Solver_747>	::=	"vec<Var> map; Var max = 0;\n"
<Solver_748>	::=	"int cnt = 0;\n"
<Solver_749>	::=	"for(" <for1_Solver_749> ";" <for2_Solver_749> ";" <for3_Solver_749> ") \n"
<for1_Solver_749>	::=	"int i = 0"
<for2_Solver_749>	::=	"i < clauses.size()"
<for3_Solver_749>	::=	"i++"
<Solver_750>	::=	"{\n"
<Solver_751>	::=	"{Log_count64++;/*751*/} if" <IF_Solver_751> " \n"
#"if
<IF_Solver_751>	::=	"(!satisfied(ca[clauses[i]]))"
<Solver_752>	::=	"{\n"
<Solver_753>	::=	"" <_Solver_753> "{Log_count64++;/*753*/}\n"
#other
<_Solver_753>	::=	"cnt++;"
<Solver_754>	::=	"}\n"
<Solver_755>	::=	"}\n"
<Solver_756>	::=	"for(" <for1_Solver_756> ";" <for2_Solver_756> ";" <for3_Solver_756> ") \n"
<for1_Solver_756>	::=	"int i = 0"
<for2_Solver_756>	::=	"i < clauses.size()"
<for3_Solver_756>	::=	"i++"
<Solver_757>	::=	"{\n"
<Solver_758>	::=	"{Log_count64++;/*758*/} if" <IF_Solver_758> " \n"
#"if
<IF_Solver_758>	::=	"(!satisfied(ca[clauses[i]]))"
<Solver_759>	::=	"{\n"
<Solver_760>	::=	"Clause& c = ca[clauses[i]];\n"
<Solver_761>	::=	"for(" <for1_Solver_761> ";" <for2_Solver_761> ";" <for3_Solver_761> ") \n"
<for1_Solver_761>	::=	"int j = 0"
<for2_Solver_761>	::=	"j < c.size()"
<for3_Solver_761>	::=	"j++"
<Solver_762>	::=	" if" <IF_Solver_762> " \n"
#"if
<IF_Solver_762>	::=	"(value(c[j]) != (lbool((uint8_t)1)))"
<Solver_763>	::=	"{{Log_count64++;/*762*/}\n"
<Solver_764>	::=	"" <_Solver_764> "{Log_count64++;/*764*/}\n"
#other
<_Solver_764>	::=	"mapVar(var(c[j]), map, max);"
<Solver_765>	::=	"}\n"
<Solver_766>	::=	"}\n"
<Solver_767>	::=	"}\n"
<Solver_768>	::=	"" <_Solver_768> "{Log_count64++;/*768*/}\n"
#other
<_Solver_768>	::=	"cnt += assumptions.size();"
<Solver_769>	::=	"" <_Solver_769> "{Log_count64++;/*769*/}\n"
#other
<_Solver_769>	::=	"fprintf(f, \"p cnf %d %d\n\", max, cnt);"
<Solver_770>	::=	"for(" <for1_Solver_770> ";" <for2_Solver_770> ";" <for3_Solver_770> ") \n"
<for1_Solver_770>	::=	"int i = 0"
<for2_Solver_770>	::=	"i < assumptions.size()"
<for3_Solver_770>	::=	"i++"
<Solver_771>	::=	"{\n"
<Solver_773>	::=	"" <_Solver_773> "{Log_count64++;/*773*/}\n"
#other
<_Solver_773>	::=	"assert(value(assumptions[i]) != l_False);"
<Solver_774>	::=	"" <_Solver_774> "{Log_count64++;/*774*/}\n"
#other
<_Solver_774>	::=	"fprintf(f, \"%s%d 0\n\", sign(assumptions[i]) ? \"-\" : \"\", mapVar(var(assumptions[i]), map, max)+1);"
<Solver_775>	::=	"}\n"
<Solver_776>	::=	"for(" <for1_Solver_776> ";" <for2_Solver_776> ";" <for3_Solver_776> ") \n"
<for1_Solver_776>	::=	"int i = 0"
<for2_Solver_776>	::=	"i < clauses.size()"
<for3_Solver_776>	::=	"i++"
<Solver_777>	::=	"{\n"
<Solver_778>	::=	"" <_Solver_778> "{Log_count64++;/*778*/}\n"
#other
<_Solver_778>	::=	"toDimacs(f, ca[clauses[i]], map, max);"
<Solver_779>	::=	"}\n"
<Solver_780>	::=	"{Log_count64++;/*780*/} if" <IF_Solver_780> " \n"
#"if
<IF_Solver_780>	::=	"(verbosity > 0)"
<Solver_781>	::=	"{\n"
<Solver_782>	::=	"" <_Solver_782> "{Log_count64++;/*782*/}\n"
#other
<_Solver_782>	::=	"printf(\"Wrote %d clauses with %d variables.\n\", cnt, max);"
<Solver_783>	::=	"}\n"
<Solver_784>	::=	"}\n"
<Solver_785>	::=	"void Solver::relocAll(ClauseAllocator& to)\n"
<Solver_786>	::=	"{\n"
<Solver_787>	::=	"" <_Solver_787> "{Log_count64++;/*787*/}\n"
#other
<_Solver_787>	::=	"watches.cleanAll();"
<Solver_788>	::=	"for(" <for1_Solver_788> ";" <for2_Solver_788> ";" <for3_Solver_788> ") \n"
<for1_Solver_788>	::=	"int v = 0"
<for2_Solver_788>	::=	"v < nVars()"
<for3_Solver_788>	::=	"v++"
<Solver_789>	::=	"{\n"
<Solver_790>	::=	"for(" <for1_Solver_790> ";" <for2_Solver_790> ";" <for3_Solver_790> ") \n"
<for1_Solver_790>	::=	"int s = 0"
<for2_Solver_790>	::=	"s < 2"
<for3_Solver_790>	::=	"s++"
<Solver_791>	::=	"{\n"
<Solver_792>	::=	"Lit p = mkLit(v, s);\n"
<Solver_793>	::=	"vec<Watcher>& ws = watches[p];\n"
<Solver_794>	::=	"for(" <for1_Solver_794> ";" <for2_Solver_794> ";" <for3_Solver_794> ") \n"
<for1_Solver_794>	::=	"int j = 0"
<for2_Solver_794>	::=	"j < ws.size()"
<for3_Solver_794>	::=	"j++"
<Solver_795>	::=	"{\n"
<Solver_796>	::=	"" <_Solver_796> "{Log_count64++;/*796*/}\n"
#other
<_Solver_796>	::=	"ca.reloc(ws[j].cref, to);"
<Solver_797>	::=	"}\n"
<Solver_798>	::=	"}\n"
<Solver_799>	::=	"}\n"
<Solver_800>	::=	"for(" <for1_Solver_800> ";" <for2_Solver_800> ";" <for3_Solver_800> ") \n"
<for1_Solver_800>	::=	"int i = 0"
<for2_Solver_800>	::=	"i < trail.size()"
<for3_Solver_800>	::=	"i++"
<Solver_801>	::=	"{\n"
<Solver_802>	::=	"Var v = var(trail[i]);\n"
<Solver_803>	::=	"{Log_count64++;/*803*/} if" <IF_Solver_803> " \n"
#"if
<IF_Solver_803>	::=	"(reason(v) != CRef_Undef && (ca[reason(v)].reloced() || locked(ca[reason(v)])))"
<Solver_804>	::=	"{\n"
<Solver_805>	::=	"" <_Solver_805> "{Log_count64++;/*805*/}\n"
#other
<_Solver_805>	::=	"ca.reloc(vardata[v].reason, to);"
<Solver_806>	::=	"}\n"
<Solver_807>	::=	"}\n"
<Solver_808>	::=	"for(" <for1_Solver_808> ";" <for2_Solver_808> ";" <for3_Solver_808> ") \n"
<for1_Solver_808>	::=	"int i = 0"
<for2_Solver_808>	::=	"i < learnts.size()"
<for3_Solver_808>	::=	"i++"
<Solver_809>	::=	"{\n"
<Solver_810>	::=	"" <_Solver_810> "{Log_count64++;/*810*/}\n"
#other
<_Solver_810>	::=	"ca.reloc(learnts[i], to);"
<Solver_811>	::=	"}\n"
<Solver_812>	::=	"for(" <for1_Solver_812> ";" <for2_Solver_812> ";" <for3_Solver_812> ") \n"
<for1_Solver_812>	::=	"int i = 0"
<for2_Solver_812>	::=	"i < clauses.size()"
<for3_Solver_812>	::=	"i++"
<Solver_813>	::=	"{\n"
<Solver_814>	::=	"" <_Solver_814> "{Log_count64++;/*814*/}\n"
#other
<_Solver_814>	::=	"ca.reloc(clauses[i], to);"
<Solver_815>	::=	"}\n"
<Solver_816>	::=	"}\n"
<Solver_817>	::=	"void Solver::garbageCollect()\n"
<Solver_818>	::=	"{\n"
<Solver_819>	::=	"ClauseAllocator to(ca.size() - ca.wasted());\n"
<Solver_820>	::=	"" <_Solver_820> "{Log_count64++;/*820*/}\n"
#other
<_Solver_820>	::=	"relocAll(to);"
<Solver_821>	::=	"{Log_count64++;/*821*/} if" <IF_Solver_821> " \n"
#"if
<IF_Solver_821>	::=	"(verbosity >= 2)"
<Solver_822>	::=	"{\n"
<Solver_823>	::=	"printf(\"| Garbage collection: %12d bytes => %12d bytes |\n\",\n"
<Solver_824>	::=	"ca.size()*ClauseAllocator::Unit_Size, to.size()*ClauseAllocator::Unit_Size);\n"
<Solver_825>	::=	"}\n"
<Solver_826>	::=	"" <_Solver_826> "{Log_count64++;/*826*/}\n"
#other
<_Solver_826>	::=	"to.moveTo(ca);"
<Solver_827>	::=	"}\n"
<Solver>	::=	<Solver_3> <Solver_4> <Solver_5> <Solver_6> <Solver_7> <Solver_8> <Solver_9> <Solver_10> <Solver_11> <Solver_12> <Solver_13> <Solver_14> <Solver_15> <Solver_16> <Solver_17> <Solver_18> <Solver_19> <Solver_20> <Solver_21> <Solver_22> <Solver_23> <Solver_24> <Solver_25> <Solver_26> <Solver_27> <Solver_28> <Solver_29> <Solver_30> <Solver_31> <Solver_32> <Solver_33> <Solver_34> <Solver_35> <Solver_36> <Solver_37> <Solver_38> <Solver_39> <Solver_40> <Solver_41> <Solver_42> <Solver_43> <Solver_44> <Solver_45> <Solver_46> <Solver_47> <Solver_48> <Solver_49> <Solver_50> <Solver_51> <Solver_52> <Solver_53> <Solver_54> <Solver_55> <Solver_56> <Solver_57> <Solver_58> <Solver_59> <Solver_60> <Solver_61> <Solver_62> <Solver_63> <Solver_64> <Solver_65> <Solver_66> <Solver_67> <Solver_68> <Solver_69> <Solver_70> <Solver_71> <Solver_73> <Solver_74> <Solver_75> <Solver_76> <Solver_77> <Solver_78> <Solver_79> <Solver_80> <Solver_81> <Solver_82> <Solver_83> <Solver_84> <Solver_85> <Solver_86> <Solver_87> <Solver_88> <Solver_89> <Solver_90> <Solver_91> <Solver_92> <Solver_93> <Solver_94> <Solver_95> <Solver_96> <Solver_97> <Solver_98> <Solver_99> <Solver_100> <Solver_101> <Solver_102> <Solver_103> <Solver_104> <Solver_105> <Solver_106> <Solver_107> <Solver_108> <Solver_109> <Solver_110> <Solver_111> <Solver_113> <Solver_114> <Solver_115> <Solver_116> <Solver_117> <Solver_118> <Solver_119> <Solver_120> <Solver_121> <Solver_123> <Solver_124> <Solver_125> <Solver_126> <Solver_127> <Solver_128> <Solver_129> <Solver_130> <Solver_131> <Solver_132> <Solver_133> <Solver_134> <Solver_135> <Solver_136> <Solver_137> <Solver_138> <Solver_139> <Solver_140> <Solver_141> <Solver_142> <Solver_143> <Solver_144> <Solver_145> <Solver_146> <Solver_147> <Solver_148> <Solver_149> <Solver_150> <Solver_151> <Solver_152> <Solver_153> <Solver_154> <Solver_155> <Solver_156> <Solver_157> <Solver_158> <Solver_159> <Solver_160> <Solver_161> <Solver_162> <Solver_163> <Solver_164> <Solver_165> <Solver_166> <Solver_167> <Solver_168> <Solver_169> <Solver_170> <Solver_171> <Solver_172> <Solver_173> <Solver_174> <Solver_175> <Solver_176> <Solver_177> <Solver_178> <Solver_179> <Solver_180> <Solver_181> <Solver_182> <Solver_183> <Solver_184> <Solver_185> <Solver_186> <Solver_187> <Solver_188> <Solver_189> <Solver_190> <Solver_191> <Solver_192> <Solver_193> <Solver_194> <Solver_195> <Solver_196> <Solver_197> <Solver_198> <Solver_199> <Solver_200> <Solver_201> <Solver_202> <Solver_203> <Solver_204> <Solver_205> <Solver_206> <Solver_207> <Solver_208> <Solver_209> <Solver_210> <Solver_211> <Solver_212> <Solver_213> <Solver_214> <Solver_215> <Solver_216> <Solver_218> <Solver_219> <Solver_220> <Solver_221> <Solver_222> <Solver_223> <Solver_224> <Solver_225> <Solver_226> <Solver_227> <Solver_228> <Solver_229> <Solver_230> <Solver_231> <Solver_232> <Solver_233> <Solver_234> <Solver_235> <Solver_236> <Solver_237> <Solver_238> <Solver_239> <Solver_240> <Solver_241> <Solver_242> <Solver_243> <Solver_244> <Solver_245> <Solver_246> <Solver_247> <Solver_248> <Solver_249> <Solver_250> <Solver_251> <Solver_252> <Solver_253> <Solver_254> <Solver_255> <Solver_256> <Solver_257> <Solver_258> <Solver_259> <Solver_260> <Solver_261> <Solver_262> <Solver_263> <Solver_264> <Solver_265> <Solver_266> <Solver_267> <Solver_268> <Solver_269> <Solver_270> <Solver_271> <Solver_272> <Solver_273> <Solver_274> <Solver_275> <Solver_276> <Solver_277> <Solver_278> <Solver_279> <Solver_280> <Solver_281> <Solver_282> <Solver_283> <Solver_284> <Solver_285> <Solver_286> <Solver_287> <Solver_288> <Solver_289> <Solver_290> <Solver_291> <Solver_292> <Solver_293> <Solver_294> <Solver_295> <Solver_296> <Solver_297> <Solver_298> <Solver_299> <Solver_300> <Solver_301> <Solver_302> <Solver_303> <Solver_304> <Solver_305> <Solver_306> <Solver_307> <Solver_308> <Solver_309> <Solver_310> <Solver_311> <Solver_312> <Solver_313> <Solver_314> <Solver_315> <Solver_316> <Solver_317> <Solver_318> <Solver_319> <Solver_320> <Solver_321> <Solver_322> <Solver_323> <Solver_324> <Solver_325> <Solver_327> <Solver_328> <Solver_329> <Solver_330> <Solver_331> <Solver_332> <Solver_333> <Solver_334> <Solver_335> <Solver_336> <Solver_337> <Solver_338> <Solver_339> <Solver_340> <Solver_341> <Solver_342> <Solver_343> <Solver_344> <Solver_345> <Solver_346> <Solver_347> <Solver_348> <Solver_349> <Solver_350> <Solver_351> <Solver_352> <Solver_353> <Solver_354> <Solver_355> <Solver_356> <Solver_357> <Solver_358> <Solver_359> <Solver_360> <Solver_361> <Solver_362> <Solver_363> <Solver_364> <Solver_365> <Solver_366> <Solver_367> <Solver_368> <Solver_369> <Solver_371> <Solver_372> <Solver_373> <Solver_374> <Solver_375> <Solver_376> <Solver_377> <Solver_378> <Solver_379> <Solver_380> <Solver_381> <Solver_382> <Solver_383> <Solver_384> <Solver_385> <Solver_386> <Solver_387> <Solver_388> <Solver_389> <Solver_390> <Solver_391> <Solver_393> <Solver_394> <Solver_395> <Solver_396> <Solver_397> <Solver_398> <Solver_399> <Solver_400> <Solver_401> <Solver_402> <Solver_403> <Solver_404> <Solver_405> <Solver_406> <Solver_407> <Solver_408> <Solver_409> <Solver_410> <Solver_411> <Solver_412> <Solver_413> <Solver_414> <Solver_415> <Solver_416> <Solver_417> <Solver_418> <Solver_419> <Solver_420> <Solver_421> <Solver_422> <Solver_424> <Solver_425> <Solver_426> <Solver_427> <Solver_428> <Solver_429> <Solver_430> <Solver_431> <Solver_432> <Solver_433> <Solver_434> <Solver_435> <Solver_436> <Solver_437> <Solver_438> <Solver_439> <Solver_440> <Solver_441> <Solver_442> <Solver_443> <Solver_444> <Solver_445> <Solver_446> <Solver_447> <Solver_448> <Solver_449> <Solver_450> <Solver_451> <Solver_452> <Solver_453> <Solver_454> <Solver_455> <Solver_456> <Solver_457> <Solver_458> <Solver_459> <Solver_460> <Solver_461> <Solver_462> <Solver_463> <Solver_464> <Solver_465> <Solver_466> <Solver_467> <Solver_468> <Solver_469> <Solver_470> <Solver_471> <Solver_472> <Solver_473> <Solver_474> <Solver_475> <Solver_476> <Solver_477> <Solver_478> <Solver_479> <Solver_480> <Solver_481> <Solver_482> <Solver_483> <Solver_484> <Solver_485> <Solver_486> <Solver_487> <Solver_488> <Solver_489> <Solver_490> <Solver_491> <Solver_492> <Solver_493> <Solver_494> <Solver_495> <Solver_496> <Solver_497> <Solver_498> <Solver_499> <Solver_500> <Solver_501> <Solver_502> <Solver_503> <Solver_504> <Solver_505> <Solver_506> <Solver_507> <Solver_508> <Solver_509> <Solver_510> <Solver_511> <Solver_512> <Solver_513> <Solver_514> <Solver_515> <Solver_516> <Solver_517> <Solver_518> <Solver_519> <Solver_520> <Solver_521> <Solver_523> <Solver_524> <Solver_525> <Solver_526> <Solver_527> <Solver_528> <Solver_529> <Solver_530> <Solver_531> <Solver_532> <Solver_533> <Solver_534> <Solver_535> <Solver_536> <Solver_537> <Solver_538> <Solver_539> <Solver_540> <Solver_541> <Solver_542> <Solver_543> <Solver_544> <Solver_546> <Solver_547> <Solver_548> <Solver_549> <Solver_550> <Solver_551> <Solver_552> <Solver_553> <Solver_554> <Solver_555> <Solver_556> <Solver_557> <Solver_558> <Solver_559> <Solver_560> <Solver_561> <Solver_562> <Solver_563> <Solver_564> <Solver_565> <Solver_566> <Solver_567> <Solver_568> <Solver_569> <Solver_570> <Solver_571> <Solver_572> <Solver_573> <Solver_574> <Solver_575> <Solver_576> <Solver_577> <Solver_578> <Solver_579> <Solver_580> <Solver_581> <Solver_582> <Solver_583> <Solver_584> <Solver_585> <Solver_586> <Solver_587> <Solver_588> <Solver_589> <Solver_590> <Solver_591> <Solver_592> <Solver_593> <Solver_594> <Solver_595> <Solver_596> <Solver_597> <Solver_598> <Solver_599> <Solver_600> <Solver_601> <Solver_602> <Solver_603> <Solver_604> <Solver_605> <Solver_606> <Solver_607> <Solver_608> <Solver_609> <Solver_610> <Solver_611> <Solver_612> <Solver_613> <Solver_614> <Solver_615> <Solver_616> <Solver_617> <Solver_618> <Solver_619> <Solver_620> <Solver_621> <Solver_622> <Solver_623> <Solver_624> <Solver_625> <Solver_626> <Solver_627> <Solver_628> <Solver_629> <Solver_630> <Solver_631> <Solver_632> <Solver_633> <Solver_634> <Solver_635> <Solver_636> <Solver_637> <Solver_638> <Solver_639> <Solver_640> <Solver_641> <Solver_642> <Solver_643> <Solver_644> <Solver_645> <Solver_646> <Solver_647> <Solver_648> <Solver_649> <Solver_650> <Solver_651> <Solver_652> <Solver_653> <Solver_654> <Solver_655> <Solver_656> <Solver_657> <Solver_658> <Solver_659> <Solver_660> <Solver_661> <Solver_662> <Solver_663> <Solver_664> <Solver_665> <Solver_666> <Solver_667> <Solver_668> <Solver_669> <Solver_670> <Solver_671> <Solver_672> <Solver_673> <Solver_674> <Solver_675> <Solver_676> <Solver_677> <Solver_678> <Solver_679> <Solver_680> <Solver_681> <Solver_682> <Solver_683> <Solver_684> <Solver_685> <Solver_686> <Solver_687> <Solver_688> <Solver_689> <Solver_690> <Solver_691> <Solver_692> <Solver_693> <Solver_694> <Solver_695> <Solver_696> <Solver_697> <Solver_698> <Solver_699> <Solver_700> <Solver_701> <Solver_702> <Solver_703> <Solver_704> <Solver_705> <Solver_706> <Solver_707> <Solver_708> <Solver_709> <Solver_710> <Solver_711> <Solver_712> <Solver_713> <Solver_714> <Solver_715> <Solver_716> <Solver_717> <Solver_718> <Solver_719> <Solver_720> <Solver_721> <Solver_722> <Solver_723> <Solver_724> <Solver_725> <Solver_726> <Solver_727> <Solver_728> <Solver_729> <Solver_730> <Solver_731> <Solver_732> <Solver_733> <Solver_734> <Solver_735> <Solver_736> <Solver_737> <Solver_738> <Solver_739> <Solver_740> <Solver_741> <Solver_742> <Solver_743> <Solver_744> <Solver_745> <Solver_746> <Solver_747> <Solver_748> <Solver_749> <Solver_750> <Solver_751> <Solver_752> <Solver_753> <Solver_754> <Solver_755> <Solver_756> <Solver_757> <Solver_758> <Solver_759> <Solver_760> <Solver_761> <Solver_762> <Solver_763> <Solver_764> <Solver_765> <Solver_766> <Solver_767> <Solver_768> <Solver_769> <Solver_770> <Solver_771> <Solver_773> <Solver_774> <Solver_775> <Solver_776> <Solver_777> <Solver_778> <Solver_779> <Solver_780> <Solver_781> <Solver_782> <Solver_783> <Solver_784> <Solver_785> <Solver_786> <Solver_787> <Solver_788> <Solver_789> <Solver_790> <Solver_791> <Solver_792> <Solver_793> <Solver_794> <Solver_795> <Solver_796> <Solver_797> <Solver_798> <Solver_799> <Solver_800> <Solver_801> <Solver_802> <Solver_803> <Solver_804> <Solver_805> <Solver_806> <Solver_807> <Solver_808> <Solver_809> <Solver_810> <Solver_811> <Solver_812> <Solver_813> <Solver_814> <Solver_815> <Solver_816> <Solver_817> <Solver_818> <Solver_819> <Solver_820> <Solver_821> <Solver_822> <Solver_823> <Solver_824> <Solver_825> <Solver_826> <Solver_827> 
<start>	::= <Solver>
